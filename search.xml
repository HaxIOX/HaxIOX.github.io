<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>199-蓝牙的相关知识</title>
      <link href="/2025/09/29/199-lan-ya-de-xiang-guan-zhi-shi/"/>
      <url>/2025/09/29/199-lan-ya-de-xiang-guan-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-蓝牙的两种“连接”"><a href="#1-蓝牙的两种“连接”" class="headerlink" title="1. 蓝牙的两种“连接”"></a>1. 蓝牙的两种“连接”</h2><ul><li><strong>经典蓝牙（BR&#x2F;EDR）</strong><ul><li>耳机、音箱、手柄这种，大部分都走经典蓝牙。</li><li>手机系统蓝牙 UI 原生支持，扫描后直接给你「配对」「连接」。</li></ul></li><li><strong>低功耗蓝牙（BLE，Bluetooth Low Energy）</strong><ul><li>心率带、手环、智能灯泡、BLE 键盘&#x2F;鼠标……</li><li>基于 <strong>GATT Profile</strong>（一堆服务&#x2F;特征值）。</li><li>手机系统蓝牙 UI 只会对「它认识的标准 Profile」显示「连接」</li></ul></li></ul><p>👉 也就是说：</p><ul><li><strong>经典蓝牙</strong> → 系统 UI 全面支持。</li><li><strong>BLE</strong> → 系统 UI 只支持部分标准 Profile，其他一律不显示。</li></ul><h2 id="2-什么叫“系统-UI-认识的标准-Profile”"><a href="#2-什么叫“系统-UI-认识的标准-Profile”" class="headerlink" title="2. 什么叫“系统 UI 认识的标准 Profile”"></a>2. 什么叫“系统 UI 认识的标准 Profile”</h2><p>蓝牙 SIG（标准组织）定义了一些 <strong>标准 GATT 服务（UUID）</strong>，比如：</p><ul><li>0x180D → Heart Rate（心率）</li><li>0x180F → Battery Service（电池电量）</li><li>0x1812 → HID Service（键盘&#x2F;鼠标&#x2F;遥控器）</li></ul><p>系统 UI 内置了这些 Profile 的处理逻辑：</p><ul><li>如果你的设备广播了 <strong>HID Service</strong>，手机就会当它是「键盘&#x2F;鼠标」，UI 里显示「连接」。</li><li>如果是 <strong>心率计</strong>，某些手机系统会直接显示「已连接心率传感器」。</li><li>但是如果你广播一个 <strong>自定义 Service（比如 0x00FF）</strong>，手机系统不知道这是干嘛的，就不会在 UI 里给你入口。</li></ul><hr><h2 id="3-为什么-nRF-Connect-可以"><a href="#3-为什么-nRF-Connect-可以" class="headerlink" title="3. 为什么 nRF Connect 可以"></a>3. 为什么 nRF Connect 可以</h2><ul><li>nRF Connect、LightBlue 这类工具 App，直接调用了系统的 <strong>BLE API（CoreBluetooth &#x2F; Android BLE API）</strong>。</li><li>这些 API 能列出 <strong>所有正在广播的设备</strong>，无论 UUID 是标准的还是自定义的。</li><li>所以在工具 App 里，你可以自由选择「连接」。</li></ul><p>👉 换句话说，<strong>系统 UI 是挑食的，只吃标准 Profile</strong>；工具 App 则是「开发者模式」，什么都能连。</p><hr><h2 id="4-举个例子：你的情况"><a href="#4-举个例子：你的情况" class="headerlink" title="4. 举个例子：你的情况"></a>4. 举个例子：你的情况</h2><p>你现在的 Demo 里是 <strong>Battery Service (0x180F)</strong>，再加了一个电量特征 (0x2A19)。</p><ul><li><strong>Android 手机</strong>：大多数不会在 UI 里显示「连接」，因为 Android 系统层面电池服务只用来读配件电量，不给用户操作按钮。</li><li><strong>iOS 手机</strong>：更严格，自定义 GATT 一律不在设置里显示「连接」，只能靠 App。</li></ul><p>所以结果就是：</p><ul><li>在系统蓝牙设置里，你可能只能扫到名字，但点不了「连接」。</li><li>在 nRF Connect 里，一切正常，可以连、读写。</li></ul><hr><h2 id="5-解决方法"><a href="#5-解决方法" class="headerlink" title="5. 解决方法"></a>5. 解决方法</h2><p>如果你想在 <strong>手机蓝牙设置 UI</strong> 里有「连接」按钮：</p><ol><li><strong>让 ESP32 提供 HID Service (0x1812)</strong><ul><li>手机会把它识别成「键盘&#x2F;鼠标」，UI 自动出现「连接」按钮。</li><li>这是最常见的做法。</li></ul></li><li><strong>实现其他标准 Profile（比如心率 0x180D）</strong><ul><li>手机 UI 会把它当成心率带，也能显示「连接」。</li><li>但逻辑可能不符合你的应用场景。</li></ul></li><li><strong>写手机 App</strong><ul><li>自己用 API 去扫描&#x2F;连接自定义服务。</li><li>但你说了「不想写 App」，所以这条可以忽略。</li></ul></li></ol><hr><h2 id="📌-总结一句话"><a href="#📌-总结一句话" class="headerlink" title="📌 总结一句话"></a>📌 总结一句话</h2><ul><li><strong>手机设置里的蓝牙 UI 并不是通用 BLE 调试器</strong>，它只对 **标准设备类型（HID、耳机、心率计等）**显示「连接」按钮。</li><li><strong>自定义 BLE 服务</strong> 在系统 UI 里不会有「连接」，只能在开发工具 App（nRF Connect）里操作，或者写专用 App。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>卡片式监测设备的开发日志</title>
      <link href="/2025/09/29/198-qia-pian-shi-jian-ce-she-bei-de-kai-fa-ri-zhi/"/>
      <url>/2025/09/29/198-qia-pian-shi-jian-ce-she-bei-de-kai-fa-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h2 id="本体"><a href="#本体" class="headerlink" title="本体"></a>本体</h2><h2 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h2><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><ul><li>多任务写作</li><li>全局变量抢占</li><li>竞态</li><li>队列影响</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h3 id="1-定时器与时间校准流程分析"><a href="#1-定时器与时间校准流程分析" class="headerlink" title="1. 定时器与时间校准流程分析"></a>1. 定时器与时间校准流程分析</h3><h4 id="定时器流程-Timer-Flow"><a href="#定时器流程-Timer-Flow" class="headerlink" title="定时器流程 (Timer Flow)"></a>定时器流程 (Timer Flow)</h4><p>系统的核心业务逻辑由一个位于 <code>alert_manager</code> 中的 30 秒周期性定时器驱动。</p><ol><li><strong>创建与启动</strong>:<ul><li>在 <code>alert_manager_init</code> 函数中，创建了一个名为 <code>alert_timer</code> 的 FreeRTOS 定时器，周期为 30 秒。</li><li>当 <code>alert_manager_start</code> 函数被（在 <code>eg800k.c</code> 收到配置后）调用时，这个定时器通过 <code>xTimerStart</code> 启动。</li></ul></li><li><strong>事件触发</strong>:<ul><li>定时器每 30 秒触发一次回调函数 <code>periodic_timer_callback</code>。</li><li>这个回调函数只做一件事：向全局的 <code>alert_queue</code> 发送一个类型为 <code>ALERT_EVENT_TIMER_CHECK</code> 的事件。</li></ul></li><li><strong>事件处理</strong>:<ul><li><code>alert_manager_task</code> 任务在其主循环中等待并接收 <code>alert_queue</code> 的事件。</li><li>当收到 <code>ALERT_EVENT_TIMER_CHECK</code> 事件时，它会调用 <code>handle_timer_check</code> 函数。</li></ul></li><li><strong>核心业务逻辑</strong>:<ul><li>在 <code>handle_timer_check</code> 函数内部，执行了一系列周期性检查：<ul><li><strong>请求 GPS 数据</strong>：每 30 秒主动调用 <code>eg800k_get_gnss_data</code> 函数，向 4G 模块请求一次位置更新。日志中反复出现的 <code>ALERT_MANAGER: 主动请求GPS数据更新</code> 证实了这一点。</li><li><strong>检查饮酒监控</strong>：根据配置规则，检查是否到达饮酒检测的时间点。日志中的 <code>ALERT_MANAGER: 执行定时饮酒检测</code> 证实了这一点。</li><li><strong>检查卡片脱离、场所停留超时</strong>等其他业务规则。</li><li><strong>检查 R0 标定</strong>：在特定条件下尝试对酒精传感器进行后台自动标定。</li></ul></li></ul></li></ol><h4 id="时间校准流程-Time-Calibration-Flow"><a href="#时间校准流程-Time-Calibration-Flow" class="headerlink" title="时间校准流程 (Time Calibration Flow)"></a>时间校准流程 (Time Calibration Flow)</h4><p>系统时间依赖 4G 模块从蜂窝网络获取，校准流程如下：</p><ol><li><strong>触发校准</strong>:<ul><li>时间校准由 <code>eg800k_get_current_time</code> 函数发起。</li><li>在两个地方会触发校准：<ul><li><code>main.c</code> 的主循环中，每小时检查一次时间同步状态。日志显示 <code>I (87296) MAIN: 请求时间同步</code>。</li><li><code>alert_manager.c</code> 的 <code>time_service_get_current_time</code> 函数中，如果发现时间未同步，也会触发请求。</li></ul></li></ul></li><li><strong>AT 指令交互</strong>:<ul><li><code>eg800k_get_current_time</code> 函数向 4G 模块发送 <code>AT+CCLK?</code> 指令。</li><li>模块返回网络时间，例如：<code>+CCLK: &quot;25/09/29,01:11:37+32&quot;</code>。</li></ul></li><li><strong>解析与转换</strong>:<ul><li><code>eg800k_parse_task</code> 任务接收到包含 <code>+CCLK:</code> 的响应后，会调用 <code>parse_cclk_response</code> 函数（位于 <code>alert_manager.c</code>）进行解析。</li><li><code>parse_cclk_response</code> 使用 <code>sscanf</code> 从字符串中提取年、月、日、时、分、秒。</li><li>它将获取到的 UTC 时间硬编码 <code>hour += 8;</code> 转换为北京时间 (UTC+8)。</li><li>转换成功后，更新全局状态 <code>g_alert_state.current_time</code>，并将 <code>g_alert_state.time_synced</code> 标志位置为 <code>true</code>。日志 <code>ALERT_MANAGER: ✓ 时间同步成功: 2025-09-29 09:11:37</code> 证实了解析和转换的成功。</li></ul></li><li><strong>本地时间维护</strong>:<ul><li>在两次网络校准之间，系统通过 <code>time_service_get_current_time</code> 函数，计算自上次同步以来经过的毫秒数，并将其加到已保存的时间上，从而提供一个估算的当前时间。</li></ul></li></ol><h1 id="主题与指令"><a href="#主题与指令" class="headerlink" title="主题与指令"></a>主题与指令</h1><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><blockquote><p>&#x2F;sensor&#x2F;imu（当前已在imu.c中关闭数据上传）</p><p>&#x2F;sensor&#x2F;gm502b</p><p>&#x2F;terminals&#x2F;T001&#x2F;alerts</p><p>&#x2F;terminals&#x2F;T001&#x2F;config&#x2F;set</p><p>&#x2F;topic&#x2F;qos0</p><p>&#x2F;alerts&#x2F;drinking</p><p>&#x2F;reports&#x2F;drinking</p><p>&#x2F;reports&#x2F;bleStatus</p><p>&#x2F;reports&#x2F;gpsLocation</p><p>&#x2F;alerts&#x2F;cardDetach </p><p>&#x2F;alerts&#x2F;venue</p></blockquote><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;terminalId&quot;: &quot;T001&quot;,  &quot;userName&quot;: &quot;张三&quot;,  &quot;userPhone&quot;: &quot;13812345678&quot;,  &quot;emergencyContact&quot;: &quot;13911111111&quot;,  &quot;departureDateTime&quot;: &quot;2025-09-27 9:30:00&quot;,  &quot;returnDateTime&quot;: &quot;2025-09-27 11:40:00&quot;,  &quot;remark&quot;: &quot;外出办事&quot;,  &quot;destinationManagement&quot;: &#123;    &quot;enabled&quot;: true,    &quot;city&quot;: &quot;大连市&quot;,    &quot;arrivalDateTime&quot;: &quot;2025-09-27 9:35:00&quot;,    &quot;departureDateTime&quot;: &quot;2025-09-27 11:50:00&quot;  &#125;,  &quot;cardDetachAlert&quot;: &#123;    &quot;enabled&quot;: true,    &quot;disconnectTimeout&quot;: 30,    &quot;silentTimeout&quot;: 60,    &quot;silentPeriod&quot;: &quot;22:00-06:00&quot;  &#125;,  &quot;lawEnforcementAlert&quot;: &#123;    &quot;enabled&quot;: true,    &quot;stayTimeout&quot;: 120  &#125;,  &quot;suspiciousVenueAlert&quot;: &#123;    &quot;enabled&quot;: true,    &quot;stayTimeout&quot;: 60  &#125;,  &quot;drunkDrivingPrevention&quot;: &#123;    &quot;enabled&quot;: true,    &quot;reminderInterval&quot;: 30  &#125;,  &quot;drinkingMonitorAlert&quot;: &#123;    &quot;enabled&quot;: true,    &quot;monitorRules&quot;: [      &#123;        &quot;timeRange&quot;: &quot;18:00-23:00&quot;,        &quot;frequency&quot;: 3      &#125;,      &#123;        &quot;timeRange&quot;: &quot;07:00-18:00&quot;,        &quot;frequency&quot;: 5      &#125;    ]  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="酒精传感器控制"><a href="#酒精传感器控制" class="headerlink" title="酒精传感器控制"></a>酒精传感器控制</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;device&quot;: &quot;502b&quot;, &quot;cmd&quot;: &quot;on&quot;&#125;     &#x2F;&#x2F; 开启酒精传感器&#123;&quot;device&quot;: &quot;502b&quot;, &quot;cmd&quot;: &quot;off&quot;&#125;    &#x2F;&#x2F; 关闭酒精传感器  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="摄像头控制"><a href="#摄像头控制" class="headerlink" title="摄像头控制"></a>摄像头控制</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;device&quot;: &quot;cam&quot;, &quot;cmd&quot;: &quot;on&quot;&#125;      &#x2F;&#x2F; 开启摄像头&#123;&quot;device&quot;: &quot;cam&quot;, &quot;cmd&quot;: &quot;off&quot;&#125;     &#x2F;&#x2F; 关闭摄像头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="IMU传感器控制"><a href="#IMU传感器控制" class="headerlink" title="IMU传感器控制"></a>IMU传感器控制</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;device&quot;: &quot;imu&quot;, &quot;cmd&quot;: &quot;sta&quot;&#125;     &#x2F;&#x2F; 开始IMU数据上传&#123;&quot;device&quot;: &quot;imu&quot;, &quot;cmd&quot;: &quot;sto&quot;&#125;     &#x2F;&#x2F; 停止IMU数据上传<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="LED控制"><a href="#LED控制" class="headerlink" title="LED控制"></a>LED控制</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;device&quot;: &quot;led&quot;, &quot;cmd&quot;: &quot;on&quot;&#125;      &#x2F;&#x2F; 开启LED&#123;&quot;device&quot;: &quot;led&quot;, &quot;cmd&quot;: &quot;off&quot;&#125;     &#x2F;&#x2F; 关闭LED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-系统指令"><a href="#3-系统指令" class="headerlink" title="3. 系统指令"></a>3. 系统指令</h2><h3 id="立即时间同步"><a href="#立即时间同步" class="headerlink" title="立即时间同步"></a>立即时间同步</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;device&quot;: &quot;system&quot;, &quot;cmd&quot;: &quot;sync_time&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="手动扫描"><a href="#手动扫描" class="headerlink" title="手动扫描"></a>手动扫描</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;device&quot;: &quot;system&quot;, &quot;cmd&quot;: &quot;scan_wifi&quot;&#125;   &#x2F;&#x2F; WiFi扫描&#123;&quot;device&quot;: &quot;system&quot;, &quot;cmd&quot;: &quot;scan_ble&quot;&#125;    &#x2F;&#x2F; BLE扫描<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="获取系统状态"><a href="#获取系统状态" class="headerlink" title="获取系统状态"></a>获取系统状态</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;device&quot;: &quot;system&quot;, &quot;cmd&quot;: &quot;status&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;device&quot;: &quot;system&quot;, &quot;cmd&quot;: &quot;restart&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-参数化指令"><a href="#4-参数化指令" class="headerlink" title="4. 参数化指令"></a>4. 参数化指令</h2><h3 id="带参数的传感器指令"><a href="#带参数的传感器指令" class="headerlink" title="带参数的传感器指令"></a>带参数的传感器指令</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;device&quot;: &quot;502b&quot;, &quot;cmd&quot;: &quot;read&quot;, &quot;param&quot;: 5&#125;    &#x2F;&#x2F; 连续读取5次&#123;&quot;device&quot;: &quot;imu&quot;, &quot;cmd&quot;: &quot;rate&quot;, &quot;param&quot;: 100&#125;   &#x2F;&#x2F; 设置采样率100Hz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="带参数的系统指令"><a href="#带参数的系统指令" class="headerlink" title="带参数的系统指令"></a>带参数的系统指令</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;device&quot;: &quot;system&quot;, &quot;cmd&quot;: &quot;scan_wifi&quot;, &quot;param&quot;: 30&#125;  &#x2F;&#x2F; 扫描30秒&#123;&quot;device&quot;: &quot;system&quot;, &quot;cmd&quot;: &quot;heartbeat&quot;, &quot;param&quot;: 60&#125;  &#x2F;&#x2F; 设置心跳60秒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="9-26"><a href="#9-26" class="headerlink" title="9.26"></a>9.26</h2><p>1.R0标定有问题（范围少写个0）</p><h2 id="9-27"><a href="#9-27" class="headerlink" title="9.27"></a>9.27</h2><p>1.手机无法显示卡片连接状态，因为手机ui不支持自定义ble服务</p><p>2.gm502b需要老化至少24小时，初始0点才会一直，当前状态是持续下降</p><p>3.R0检测逻辑有问题，有的时候某一处取消限制，其他地方要一起取消</p><h2 id="9-28"><a href="#9-28" class="headerlink" title="9.28"></a>9.28</h2><p>1.配置文件只能下发一次，后续下发会导致定时任务失效✅（是&#96;&#96;return&#96;导致的）<br>2.R0始终为0✅（上下限没有取消导致的）<br>3.标定会被打断<br>4.任务会影响检测频率<br>5.516没有上报异常的原因 （json解析没有下发任务）<br>6.未吹的会自动消失</p><p>7.配置文件不下发，定时器不开启</p><p>8.蓝牙初始化与蓝牙扫描没有分开</p><p>9.E (1957251) wifi:failed to post WiFi event&#x3D;1 ret&#x3D;259</p><p>W (1120146) wifi:m f probe req l&#x3D;0</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GM-502B浓度曲线拟合</title>
      <link href="/2025/09/18/197-gm-502b-nong-du-qu-xian-ni-he/"/>
      <url>/2025/09/18/197-gm-502b-nong-du-qu-xian-ni-he/</url>
      
        <content type="html"><![CDATA[<h1 id="GM-502B"><a href="#GM-502B" class="headerlink" title="GM-502B"></a><a href="https://item.szlcsc.com/datasheet/GM-502B/100969.html?spm=sc.it.xds.a&lcsc_vid=RQJWBQJQR1hdVABeEwUPVQZREgBfVABeFFBcXlRST1kxVlNTT1BYUV1RRlRcVDsOAxUeFF5JWBYZEEoBGA4JCwFIFA4DSA==">GM-502B</a></h1><h2 id="典型电路"><a href="#典型电路" class="headerlink" title="典型电路"></a>典型电路</h2><img src="/2025/09/18/197-gm-502b-nong-du-qu-xian-ni-he/1758166876693.png" class="" width="1758166876693"><img src="/2025/09/18/197-gm-502b-nong-du-qu-xian-ni-he/1758166924474.png" class="" width="1758166924474"><h2 id="测量方法"><a href="#测量方法" class="headerlink" title="测量方法"></a>测量方法</h2><ol><li><p>在已知条件下标定R0，例如，结晶空气或者200ppm的乙醇气体里，预热后读取电压计算Rs为R0</p><p>​                                                                Rs&#x3D;Rl*(Vc-Vout)&#x2F;Vout</p><p>本次是R0&#x3D;20*(3300-944)&#x2F;944&#x3D;49.92K</p></li><li><p>每次读取计算Rs，得到Rs&#x2F;R0，本次是0.4</p></li><li><p>代入曲线读取浓度</p></li></ol><h1 id="曲线拟合"><a href="#曲线拟合" class="headerlink" title="曲线拟合"></a>曲线拟合</h1><img src="/2025/09/18/197-gm-502b-nong-du-qu-xian-ni-he/1758167058174.png" class="" width="1758167058174"><table><thead><tr><th align="left">PPM(X)</th><th>RS&#x2F;R0(Y)</th><th>log10(C）</th></tr></thead><tbody><tr><td align="left">1.0</td><td>0.92</td><td>0.0</td></tr><tr><td align="left">3.0</td><td>0.72</td><td>0.477</td></tr><tr><td align="left">10.0</td><td>0.4</td><td>1.0</td></tr><tr><td align="left">30.0</td><td>0.22</td><td>1.477</td></tr><tr><td align="left">100.0</td><td>0.12</td><td>2.0</td></tr></tbody></table><h2 id="曲线是如何拟合的"><a href="#曲线是如何拟合的" class="headerlink" title="曲线是如何拟合的"></a>曲线是如何拟合的</h2><h3 id="1-数据来源"><a href="#1-数据来源" class="headerlink" title="1. 数据来源"></a>1. 数据来源</h3><p>从数据手册的“灵敏度曲线”读出若干数据点：</p><ul><li>横轴：气体浓度 CCC（ppm，log 坐标）</li><li>纵轴：比值 Rs&#x2F;R0Rs&#x2F;R0Rs&#x2F;R0（log 坐标）</li></ul><p>得到一组实验点 (C,Rs&#x2F;R0)(C, Rs&#x2F;R0)(C,Rs&#x2F;R0)。</p><hr><h2 id="2-坐标变换"><a href="#2-坐标变换" class="headerlink" title="2. 坐标变换"></a>2. 坐标变换</h2><p>将数据点转换到对数坐标系：</p><p><strong>x&#x3D;log⁡10(C)</strong>,<strong>y&#x3D;log⁡10(Rs&#x2F;R0)</strong></p><p>这样原本的曲线在 log-log 坐标下大致呈直线。</p><hr><h2 id="3-线性拟合"><a href="#3-线性拟合" class="headerlink" title="3. 线性拟合"></a>3. 线性拟合</h2><p>在 log-log 坐标下，曲线近似为一条直线</p><p>**y&#x3D;m⋅x+c **</p><p>使用最小二乘法（例如 <code>numpy.polyfit</code>）求解斜率 m 和截距 c。</p><hr><h2 id="4-转换回原公式"><a href="#4-转换回原公式" class="headerlink" title="4. 转换回原公式"></a>4. 转换回原公式</h2><img src="/2025/09/18/197-gm-502b-nong-du-qu-xian-ni-he/1758168796511.png" class="" width="1758168796511"><hr><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ul><li>通过 log-log 坐标变换，可以把非线性关系近似为直线；</li><li>用线性拟合得到的斜率和截距，再还原成幂律公式；</li><li>最终公式形式：</li></ul><img src="/2025/09/18/197-gm-502b-nong-du-qu-xian-ni-he/1758168882975.png" class="" width="1758168882975"><p>适用于一定浓度范围内的酒精浓度估算。</p><h2 id="PPM"><a href="#PPM" class="headerlink" title="PPM"></a>PPM</h2><ul><li><p><strong>ppm</strong> 是 <em>parts per million</em> 的缩写，意思是“百万分之一”。</p></li><li><p>它是一种<strong>浓度的相对单位</strong>，表示某种物质在混合物中的比例。</p></li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;math.h&gt;&#x2F;&#x2F; 硬件参数static const float Vc &#x3D; 3.3f;static const float RL &#x3D; 20000.0f;&#x2F;&#x2F; 用这次空气读数 909 mV 计算得到的 R0（建议存储在设备的非易失存储里）static const float R0 &#x3D; 52600.0f; &#x2F;&#x2F; ≈52.6 kΩ&#x2F;&#x2F; 拟合得到的系数（1–100 ppm 适用，基于手册曲线目读点）static const float a &#x3D; -2.1869f;static const float k &#x3D; 1.1174f;float ethanol_ppm_from_Vout(float Vout) &#123;    if (Vout &lt;&#x3D; 0.0f) return 0.0f;    float Rs &#x3D; RL * (Vc - Vout) &#x2F; Vout;    float ratio &#x3D; Rs &#x2F; R0;    if (ratio &lt;&#x3D; 0.0f) return 0.0f;    return k * powf(ratio, a);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实际使用需要提前测出当前洁净空气下的R0，然后再进行测试</p>]]></content>
      
      
      
        <tags>
            
            <tag> 曲线拟合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建EMQX</title>
      <link href="/2025/09/15/196-da-jian-emqx/"/>
      <url>/2025/09/15/196-da-jian-emqx/</url>
      
        <content type="html"><![CDATA[<h2 id="限制IP"><a href="#限制IP" class="headerlink" title="限制IP"></a>限制IP</h2><pre class="line-numbers language-none"><code class="language-none"># 1) 允许你的管理IP访问 18083iptables -I DOCKER-USER -p tcp --dport 18083 -s 203.0.113.10 -j ACCEPT# 2) 其余来源一律拒绝 18083iptables -A DOCKER-USER -p tcp --dport 18083 -j DROP# 如有 IPv6，再加一组（可选）# ip6tables -I DOCKER-USER -p tcp --dport 18083 -s 2001:db8::1234 -j ACCEPT# ip6tables -A DOCKER-USER -p tcp --dport 18083 -j DROPiptables -I DOCKER-USER -p tcp --dport 1883 -s 23.133.52.56 -j ACCEPTapt-get update &amp;&amp; apt-get install -y iptables-persistentnetfilter-persistent save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>iptables -F DOCKER-USER</p><p>浏览器页面只能走 8083（WebSocket）</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>网页端老是断开是什么原因</p>]]></content>
      
      
      
        <tags>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OV5640摄像头模块设计</title>
      <link href="/2025/09/10/195-ov5640-she-xiang-tou-mo-kuai-she-ji/"/>
      <url>/2025/09/10/195-ov5640-she-xiang-tou-mo-kuai-she-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h1><table><thead><tr><th align="center">NO.</th><th align="center">SYMBOL</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">STROBE</td><td align="center">闪光灯</td></tr><tr><td align="center">2</td><td align="center">DGND</td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">SIO_D</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">AVDD</td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">SIO_C</td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">RESET</td><td align="center"></td></tr><tr><td align="center">7</td><td align="center">VSYNC</td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">PWDN</td><td align="center"></td></tr><tr><td align="center">9</td><td align="center">HREF</td><td align="center"></td></tr><tr><td align="center">10</td><td align="center">DVDD</td><td align="center"></td></tr><tr><td align="center">11</td><td align="center">DOVDD</td><td align="center"></td></tr><tr><td align="center">12</td><td align="center">Y9</td><td align="center"></td></tr><tr><td align="center">13</td><td align="center">XCLK1</td><td align="center"></td></tr><tr><td align="center">14</td><td align="center">Y8</td><td align="center"></td></tr><tr><td align="center">15</td><td align="center">DGND</td><td align="center"></td></tr><tr><td align="center">16</td><td align="center">Y7</td><td align="center"></td></tr><tr><td align="center">17</td><td align="center">PCLK</td><td align="center"></td></tr><tr><td align="center">18</td><td align="center">Y6</td><td align="center"></td></tr><tr><td align="center">19</td><td align="center">Y2</td><td align="center"></td></tr><tr><td align="center">20</td><td align="center">Y5</td><td align="center"></td></tr><tr><td align="center">21</td><td align="center">Y3</td><td align="center"></td></tr><tr><td align="center">22</td><td align="center">Y4</td><td align="center"></td></tr><tr><td align="center">23</td><td align="center">NC</td><td align="center"></td></tr><tr><td align="center">24</td><td align="center">AF–VCC</td><td align="center">自动对焦电源</td></tr></tbody></table><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>FPC座容易虚焊与连锡，即便肉眼看上去完美至极</li><li>复刻的一个模块，不理解为什么用不了，合理怀疑省略了一部分电路</li><li>I2C忘记了上拉电阻</li><li>使用MOS管或者三极管记得上下拉电阻</li></ul><p>摄像头初始化失败的可能原因</p><p>1.虚焊、短路</p><p>2.引脚接错，重点排查，特别注意sda、scl、sclk等引脚</p><p>3.供电不足</p><p>4.iic通信缺少上拉电阻</p>]]></content>
      
      
      
        <tags>
            
            <tag> 摄像头 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天线前置电路设计</title>
      <link href="/2025/09/08/194-tian-xian-she-ji/"/>
      <url>/2025/09/08/194-tian-xian-she-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="设计规则"><a href="#设计规则" class="headerlink" title="设计规则"></a>设计规则</h1><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用了陶瓷天线，并进行了阻抗匹配，天线下方禁止铺铜，但是出现wifi扫描的例程只能扫到室内大于80db的信号</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>193-ESP32S3读取SD卡</title>
      <link href="/2025/09/04/193-esp32s3-du-qu-sd-qia/"/>
      <url>/2025/09/04/193-esp32s3-du-qu-sd-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li><p>1bit模式</p></li><li><p>#include &lt;errno.h&gt;</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ESP_LOGE(TAG, &quot;Write test failed, errno&#x3D;%d (%s)&quot;, errno, strerror(errno));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>⚠️Long filename support否则报错<code>errno=22 (Invalid argument)</code></p><blockquote><p>FATFS 里它几乎总是由 <strong>FR_INVALID_NAME（无效文件名）</strong> 映射过来的。你的路径是 <code>&quot;/sdcard/test_write.txt&quot;</code>，“test_write.txt”的主文件名 <code>test_write</code> 有 <strong>10 个字符</strong>，如果 <strong>长文件名（LFN）功能未开启</strong>，FAT 只允许 <strong>8.3</strong> 文件名（最多 8 个字符的主名 + “.” + 最多 3 个字符的扩展名），于是就被判定为无效文件名 ⇒ <code>EINVAL(22)</code>。同理你后面保存的 <code>photo_0001.jpg</code> 主名 <code>photo_0001</code> 也是 <strong>10 个字符</strong>，同样会触发这个错误。</p></blockquote></li></ul><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><ul><li>新项目搜不到sdmmc可能是因为没有<code>Kconfig.projbuild</code>,添加后清理重新编译即可</li><li>&#x2F;sdcard为根目录</li><li></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TVS and ESD</title>
      <link href="/2025/08/21/192-tvs-and-esd/"/>
      <url>/2025/08/21/192-tvs-and-esd/</url>
      
        <content type="html"><![CDATA[<h3 id="TVS与ESD的区别"><a href="#TVS与ESD的区别" class="headerlink" title="TVS与ESD的区别"></a>TVS与ESD的区别</h3><p>TVS (Transient Voltage Suppressor，瞬态电压抑制器) 和 ESD (Electrostatic Discharge，静电放电) 保护器件虽然都是用于保护电路免受过电压的损害，但它们的设计和应用场景有所不同。<strong>可以说，它们最主要的区别就是使用用途的区别。</strong></p><ol><li><strong>保护对象不同:</strong><ul><li><strong>TVS二极管</strong>：主要用于抑制电路上因雷击、电源波动、开关感性负载等产生的高能量、持续时间较长的<strong>浪涌(Surge)</strong>。它能承受较大的瞬时功率和电流。</li><li><strong>ESD二极管</strong>：主要用于防护因人体、设备等接触产生的持续时间极短（纳秒甚至皮秒级）但电压很高的<strong>静电放电(ESD)</strong>。它通常用在信号接口、按键等容易被人体接触的位置。</li></ul></li><li><strong>功率和电容差异:</strong><ul><li><strong>功率</strong>：TVS二极管的功率通常比ESD二极管大得多，可以从几百瓦到几千瓦，以吸收浪涌带来的巨大能量。ESD二极管的功率则小得多。</li><li><strong>结电容</strong>：TVS二极管的结电容通常较大，不适合用于高速信号线的保护，因为较大的电容会影响信号质量。ESD二极管为了不影响高速数据传输（如USB、HDMI），通常设计成极低的结电容（皮法甚至更低）。</li></ul></li></ol><p><strong>总结来说</strong>，可以把TVS看作是电路的“防洪大坝”，用来抵御大的浪涌；而把ESD看作是接口的“防静电门卫”，专门防止静电悄悄溜进去损坏娇气的芯片。</p><h3 id="电路图分析"><a href="#电路图分析" class="headerlink" title="电路图分析"></a>电路图分析</h3><p><strong>这个电路图中的D1毫无疑问是TVS二极管。</strong></p><p>依据有两点：</p><ol><li><strong>应用位置</strong>: 该二极管并联在电源（VBAT）和地（GND）之间，这是TVS管用于电源浪涌保护的典型接法。当VBAT上出现高于其工作电压的瞬时高压时，TVS会迅速导通，将浪涌电流泄放到地，从而将电压钳位在一个安全的水平，保护后端的“Module”（模块）。</li></ol><h3 id="为什么电路图符号画的是二极管？"><a href="#为什么电路图符号画的是二极管？" class="headerlink" title="为什么电路图符号画的是二极管？"></a>为什么电路图符号画的是二极管？</h3><p>这是一个很常见的情况。TVS二极管本质上是一种特殊的<strong>雪崩二极管</strong>（Avalanche Diode），其工作原理和伏安特性曲线与稳压二极管（Zener Diode）非常相似。因此，在电路图绘制中：</p><ul><li><strong>符号通用性</strong>：很多电路设计软件（CAD）的元件库里，会用稳压二极管的符号来表示单向TVS二极管。您图中的符号就是一个标准的二极管符号，有时为了更精确，也会用类似稳压二极管的符号（在阴极线上加一个小折角）。</li><li><strong>功能表达</strong>：从功能的角度看，这个符号准确地表达了其单向导通和反向击穿钳位的特性。工程师看到这个符号用在电源防护的位置，结合上下文，就能理解它是一个TVS保护器件。</li><li><strong>简洁性</strong>：虽然有专门的TVS符号，但在实际工程应用中，为了图纸的简洁和通用性，使用通用的二极管或稳压管符号来代替是很普遍的做法。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TVS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCA9555扩展芯片</title>
      <link href="/2025/08/20/191-pca9555-kuo-zhan-xin-pian/"/>
      <url>/2025/08/20/191-pca9555-kuo-zhan-xin-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="PCA9555-IO-扩展芯片"><a href="#PCA9555-IO-扩展芯片" class="headerlink" title="PCA9555 IO 扩展芯片"></a>PCA9555 IO 扩展芯片</h2><p>这颗芯片带中断</p><ul><li><strong>设备地址</strong><ul><li>I²C 7-bit 地址：<code>0x20</code>（二进制 0100_000）</li><li>因为 datasheet 中写的 “0100000xb” 实际是 <strong>7 位地址 0x20</strong>，最低位 b 是读写位，不属于地址。</li></ul></li><li><strong>控制演示代码</strong><ul><li>提供了 Arduino 下读写寄存器的函数：<ul><li><code>REG_CFG0 (0x06)</code> 控制输入&#x2F;输出模式；</li><li><code>REG_OUT0 (0x02)</code> 控制输出电平；</li><li><code>REG_IN0 (0x00)</code> 读取输入电平。</li></ul></li><li>测试 Demo 能将 IO 配置为高&#x2F;低电平，打印状态。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32S3核心板设计</title>
      <link href="/2025/08/20/190-esp32s3-he-xin-ban-she-ji/"/>
      <url>/2025/08/20/190-esp32s3-he-xin-ban-she-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="ESP32-S3-硬件调试与外设驱动问题总结"><a href="#ESP32-S3-硬件调试与外设驱动问题总结" class="headerlink" title="ESP32-S3 硬件调试与外设驱动问题总结"></a>ESP32-S3 硬件调试与外设驱动问题总结</h1><hr><h2 id="1-晶振未起振问题"><a href="#1-晶振未起振问题" class="headerlink" title="1. 晶振未起振问题"></a>1. 晶振未起振问题</h2><ul><li><strong>现象</strong><ul><li>上电后 ESP32-S3 无法识别 USB 端口；</li><li>使用示波器测试 XTAL_P&#x2F;XTAL_N 无电压，只有 mV 级噪声；</li><li>整机电流仅 7 mA；</li><li>反复重焊后有时能识别端口，但不稳定。</li></ul></li><li><strong>分析</strong><ul><li>ESP32-S3 内部有起振电路，通过 XTAL_P&#x2F;XTAL_N 接入外部晶振；</li><li>芯片会在启动时给晶振两端加“起振电流”，需要合适的负载电容和 PCB 布局；</li><li>如果测不到电压，说明起振电路未工作，可能是：<ol><li>晶振本身焊接不良 &#x2F; 损坏；</li><li>负载电容不合适（过大或过小都可能不起振）；</li><li>GND 或电源焊接不良；</li><li>芯片内部损坏。</li></ol></li></ul></li><li><strong>结论</strong><ul><li>单凭 0 V 无法完全确认是芯片损坏；</li><li>常用排查手段：换晶振 &#x2F; 电容，检查 GND 焊接完整性；</li><li>使用信号源注入法可辅助判断晶振电路是否能正常放大。</li><li>重焊芯片与晶振</li></ul></li></ul><hr><h2 id="2-Flash-烧录与启动问题"><a href="#2-Flash-烧录与启动问题" class="headerlink" title="2. Flash 烧录与启动问题"></a>2. Flash 烧录与启动问题</h2><ul><li><strong>现象</strong><ul><li>烧录失败，提示 <em>Failed to connect to ESP32-S3: No serial data received</em>；</li><li>烧录后出现 <code>invalid header: 0xffffffff</code>；</li><li>日志中提示 <em>No bootable app partitions in the partition table</em>；</li><li>测试发现 VDD_SPI 与 SPIHD 短路。</li></ul></li><li><strong>分析</strong><ul><li><code>0xffffffff</code> 常见于 flash 读不到数据（供电&#x2F;走线问题&#x2F;短路）；</li><li>确认短路点去除后，可以正常烧录；</li><li>若分区表错误，需重新烧录正确的分区表和固件。</li></ul></li><li><strong>注意点</strong><ul><li>Flash 电源 VDD_SPI 要稳定；</li><li>SPI Flash 走线要短且阻抗匹配；</li><li>助焊剂残留可能引起短路。</li></ul></li></ul><hr><h2 id="3-USB-UART-烧录"><a href="#3-USB-UART-烧录" class="headerlink" title="3. USB &amp; UART 烧录"></a>3. USB &amp; UART 烧录</h2><ul><li><strong>现象</strong><ul><li>原生 USB 无法识别；</li><li>Arduino框架下UART无数据输出；</li><li>后来通过打开Arduino的USB CDC 可识别并烧录成功。</li></ul></li><li><strong>分析</strong><ul><li>原因大多为焊接不良；</li><li>USB 需要 DP&#x2F;DM 正确走线、差分阻抗控制、上拉电阻正常。</li></ul></li></ul><hr><h2 id="4-WiFi-信号与天线问题"><a href="#4-WiFi-信号与天线问题" class="headerlink" title="4. WiFi 信号与天线问题"></a>4. WiFi 信号与天线问题</h2><ul><li><strong>现象</strong><ul><li>扫描 WiFi 网络时，只能搜到极少数热点。</li></ul></li><li><strong>分析</strong><ul><li>可能原因：<ol><li>天线设计问题：四层板时若在天线下方铺铜，会严重削弱信号；</li><li>天线匹配电路不合理；</li><li>WiFi 模块屏蔽层接地不良。</li></ol></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SPI通信</title>
      <link href="/2025/08/15/189-spi-tong-xin/"/>
      <url>/2025/08/15/189-spi-tong-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="SPI通信"><a href="#SPI通信" class="headerlink" title="SPI通信"></a>SPI通信</h1><p>**SPI，是一种高速的，全双工，同步的通信总线，**并且在芯片的管脚上只占用四根线</p><p><strong>SPI 四线</strong>：<code>SCLK</code>（时钟）、<code>MOSI</code>（主→从数据）、<code>MISO</code>（从→主，LCD通常不用）、<code>CS</code>（片选，多设备时使用）</p><p><strong>SPI通信的基础</strong>是交换一个字节，可以实现发送一个字节、接收一个字节、发送同时接收一个字节，共<strong>三种功能</strong>。</p><p><strong>缺点</strong><br>没有指定的流控制，没有应答机制确认是否接收到数据，所以跟<a href="https://zhida.zhihu.com/search?content_id=121492668&content_type=Article&match_order=1&q=IIC%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE&zhida_source=entity">IIC总线协议</a>比较在数据可靠性上有一定的缺陷。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移远EG800K-CN</title>
      <link href="/2025/08/15/188-yi-yuan-eg800kcn/"/>
      <url>/2025/08/15/188-yi-yuan-eg800kcn/</url>
      
        <content type="html"><![CDATA[<h1 id="GNSS"><a href="#GNSS" class="headerlink" title="GNSS"></a>GNSS</h1><p>AT+QGPSCFG&#x3D;”gnssconfig” 配置支持的GNSS卫星导航系统</p><blockquote><p>0 GPS<br>1 GPS + BeiDou<br>3 GPS + GLONASS + Galileo</p><p>4 GPS + GLONASS<br>5 GPS + BeiDou + Galileo<br>6 GPS + Galileo<br>7 BeiDou </p></blockquote><p>AT+QGPSCFG&#x3D;”autogps”  启用&#x2F;禁用GNSS自启动</p><p>AT+CIMI </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">AT+QGPS&#x3D;1   打开GNSSAT+QGPSLOC&#x3D;0 获取定位信息AT+QGPSEND  关闭GNSS AT+QGPSGNMEA&#x3D;GSV<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2025/08/15/188-yi-yuan-eg800kcn/1755223838276.png" class="" width="1755223838276"><img src="/2025/08/15/188-yi-yuan-eg800kcn/1755223807869.png" class="" width="1755223807869"><p>配置USB或者调式uart输出NMEA</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$GNGGA,,,,,,0,00,127.00,,,,,,*62$GNGSA,A,1,,,,,,,,,,,,,127.00,127.00,127.00,1*07$GNGSA,A,1,,,,,,,,,,,,,127.00,127.00,127.00,4*02$GPGSV,1,1,01,24,,,25,0*65$GNRMC,,V,,,,,,,,,E,N,V*72$GNVTG,,,,,,,,,N*2E$GNGGA,,,,,,0,00,127.00,,,,,,*62$GNGSA,A,1,,,,,,,,,,,,,127.00,127.00,127.00,1*07$GNGSA,A,1,,,,,,,,,,,,,127.00,127.00,127.00,4*02$GPGSV,1,1,01,24,,,25,0*65$GNRMC,,V,,,,,,,,,E,N,V*72$GNVTG,,,,,,,,,N*2E$GNGGA,,,,,,0,00,127.00,,,,,,*62$GNGSA,A,1,,,,,,,,,,,,,127.00,127.00,127.00,1*07$GNGSA,A,1,,,,,,,,,,,,,127.00,127.00,127.00,4*02$GPGSV,1,1,01,24,,,25,0*65<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.2. 支持的NMEA语句类型<br>模块默认支持的NMEA语句与NMEA-0183协议兼容。另外，可以通过三种前缀区分不同卫星系统的<br>NMEA语句，如下所示：<br>GPS NMEA语句的前缀为“GP”，如下所示：<br>⚫ GPGGA – 全球定位系统定位数据，如时间、定位等<br>⚫ GPRMC – 推荐的最小具体GNSS数据<br>⚫ GPGSV – 可见的GPS卫星，例如可见的卫星数、卫星ID号等<br>⚫ GPGSA – 参与定位的GPS卫星ID号、精度因子等<br>⚫ GPVTG – 矢量跟踪与对地速度                                                 </p><h1 id="4G"><a href="#4G" class="headerlink" title="4G"></a>4G</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="MQTT通信"><a href="#MQTT通信" class="headerlink" title="MQTT通信"></a>MQTT通信</h2><p>AT+QMTOPEN&#x3D;0,”c979197b.ala.dedicated.aws.emqxcloud.com”,1883</p><pre class="line-numbers language-none"><code class="language-none">AT+CPIN?AT+CSQAT+CREG?AT+CGDCONT?AT+CGDCONT&#x3D;1,&quot;IP&quot;,&quot;ctnet&quot;AT+CGACT&#x3D;1,1AT+CGPADDR&#x3D;1AT+QMTOPEN&#x3D;0,&quot;23.133.52.56&quot;,1883   AT+QMTCONN&#x3D;0,&quot;card&quot;,&quot;eg800&quot;,&quot;7678&quot;   五秒内快速发送<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="阶段一：前提检查"><a href="#阶段一：前提检查" class="headerlink" title="阶段一：前提检查"></a>阶段一：前提检查</h3><p>在开始之前，请务必与服务提供商确认以下事项：</p><ul><li><strong>物联网SIM卡</strong>: 确认SIM卡已激活，并且您的服务器地址已被添加到该卡的<strong>访问白名单</strong>中。</li><li><strong>MQTT服务器</strong>: 确认已创建用于设备登录的<strong>用户名和密码</strong>。</li><li><strong>服务器防火墙</strong>: 确认已放行MQTT所需端口 (如TCP <code>1883</code>)。</li></ul><h3 id="阶段二：模块网络注册"><a href="#阶段二：模块网络注册" class="headerlink" title="阶段二：模块网络注册"></a>阶段二：模块网络注册</h3><p><strong>目标</strong>: 让模块连接到移动蜂窝网络并获取IP地址。</p><ol><li><p><strong>检查SIM卡状态</strong></p><pre class="line-numbers language-none"><code class="language-none">AT+CPIN?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>预期</strong>: <code>+CPIN: READY</code></li></ul></li><li><p><strong>检查信号质量</strong></p><pre class="line-numbers language-none"><code class="language-none">AT+CSQ<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>预期</strong>: <code>+CSQ: &lt;rssi&gt;,&lt;ber&gt;</code> (rssi应 &gt; 10, 且不为99)</li></ul></li><li><p><strong>检查网络注册</strong></p><pre class="line-numbers language-none"><code class="language-none">AT+CGREG?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>预期</strong>: <code>+CGREG: 0,1</code> 或 <code>+CGREG: 0,5</code></li></ul></li><li><p><strong>配置APN</strong> (以<code>ctnet</code>为例)</p><pre class="line-numbers language-none"><code class="language-none">AT+CGDCONT&#x3D;1,&quot;IP&quot;,&quot;ctnet&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>预期</strong>: <code>OK</code></li></ul></li><li><p><strong>激活数据通道</strong></p><pre class="line-numbers language-none"><code class="language-none">AT+QIACT&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>预期</strong>: <code>OK</code></li></ul></li><li><p><strong>确认获取IP</strong></p><pre class="line-numbers language-none"><code class="language-none">AT+CGPADDR&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>预期</strong>: <code>+CGPADDR: 1,&lt;ip_address&gt;</code></li></ul></li></ol><h3 id="阶段三：连接MQTT服务器"><a href="#阶段三：连接MQTT服务器" class="headerlink" title="阶段三：连接MQTT服务器"></a>阶段三：连接MQTT服务器</h3><p><strong>目标</strong>: 建立TCP连接并完成MQTT登录。</p><ol><li><p><strong>(推荐) 配置MQTT版本</strong></p><pre class="line-numbers language-none"><code class="language-none">AT+QMTCFG&#x3D;&quot;version&quot;,0,4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>说明</strong>: 设置协议为MQTT v3.1.1，兼容性好。</li><li><strong>预期</strong>: <code>OK</code></li></ul></li><li><p><strong>建立TCP连接</strong></p><pre class="line-numbers language-none"><code class="language-none">AT+QMTOPEN&#x3D;0,&quot;&lt;服务器域名或IP&gt;&quot;,1883<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>预期</strong>: <code>OK</code> 及 <code>+QMTOPEN: 0,0</code></li></ul></li><li><p><strong>MQTT登录</strong></p><pre class="line-numbers language-none"><code class="language-none">AT+QMTCONN&#x3D;0,&quot;&lt;客户端ID&gt;&quot;,&quot;&lt;用户名&gt;&quot;,&quot;&lt;密码&gt;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>说明</strong>: 必须在<code>AT+QMTOPEN</code>成功后立即执行。</li><li><strong>预期</strong>: <code>OK</code> 及 <code>+QMTCONN: 0,0,0</code></li></ul><p>加用户名的话需要mqtt平台增加客户端认证，添加用户名</p></li></ol><h3 id="阶段四：MQTT数据操作"><a href="#阶段四：MQTT数据操作" class="headerlink" title="阶段四：MQTT数据操作"></a>阶段四：MQTT数据操作</h3><p><strong>目标</strong>: 订阅主题、发布消息、接收消息。</p><ol><li><p><strong>订阅主题</strong></p><pre class="line-numbers language-none"><code class="language-none">AT+QMTSUB&#x3D;0,1,&quot;topic&#x2F;sub&quot;,1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>说明</strong>: 订阅主题 “topic&#x2F;sub”，QoS为1。</li><li><strong>预期</strong>: <code>OK</code> 及 <code>+QMTSUB: 0,1,0,1</code></li></ul></li><li><p><strong>发布消息</strong></p><pre class="line-numbers language-none"><code class="language-none">AT+QMTPUBEX&#x3D;0,0,0,0,&quot;topic&#x2F;sub&quot;,5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>说明</strong>: 向 “topic&#x2F;pub” 主题发布5字节长的消息。</li><li><strong>操作</strong>: 模块返回 <code>&gt;</code>后，输入消息内容 (例如 <code>hello</code>)。</li><li><strong>预期</strong>: <code>OK</code> 及 <code>+QMTPUBEX: 0,0,0</code></li></ul></li><li><p><strong>接收消息 (被动)</strong></p><ul><li><strong>说明</strong>: 当订阅的主题有消息时，模块会自动上报。</li><li><strong>格式</strong>: <code>+QMTRECV: 0, &lt;msgid&gt;, &quot;&lt;主题&gt;&quot;, &lt;长度&gt;, &quot;&lt;消息内容&gt;&quot;</code></li></ul></li></ol><h3 id="阶段五：断开连接"><a href="#阶段五：断开连接" class="headerlink" title="阶段五：断开连接"></a>阶段五：断开连接</h3><p><strong>目标</strong>: 干净、优雅地断开连接。</p><ol><li><p><strong>断开MQTT会话</strong></p><pre class="line-numbers language-none"><code class="language-none">AT+QMTDISC&#x3D;0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>预期</strong>: <code>OK</code> 及 <code>+QMTDISC: 0,0</code></li></ul></li><li><p><strong>关闭TCP通道</strong></p><pre class="line-numbers language-none"><code class="language-none">AT+QMTCLOSE&#x3D;0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>预期</strong>: <code>OK</code> 及 <code>+QMTCLOSE: 0,0</code></li></ul></li></ol><h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><pre class="line-numbers language-none"><code class="language-none">AT+CCLK?        &#x2F;&#x2F;查询本地时间。 +CCLK: &quot;08&#x2F;01&#x2F;04,00:19:43+00&quot; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote><p>&#x2F;terminals&#x2F;T001&#x2F;config&#x2F;set</p><p>&#x2F;sensor&#x2F;gm502b</p><p>&#x2F;sensor&#x2F;imu</p><p>&#x2F;topic&#x2F;qos0</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 4G </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32S3驱动1.14寸TFT屏幕</title>
      <link href="/2025/08/14/187-esp32s3-qu-dong-1-14-cun-tft/"/>
      <url>/2025/08/14/187-esp32s3-qu-dong-1-14-cun-tft/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>ST7789</li><li>ESP-IDF</li><li>ESP32-S3</li></ul><h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><p>放在项目目录下，在menuconfig中开启</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ESP-IDF Partition Table# Name,   Type, SubType, Offset,  Size, Flagsnvs,      data, nvs,     ,        24K,phy_init, data, phy,     ,        4K,factory,  app,  factory, ,        1M,storage,  data, spiffs,  ,        1M,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h3 id="Arduino"><a href="#Arduino" class="headerlink" title="Arduino"></a>Arduino</h3><p>微雪电子的程序可以用来测试<a href="https://www.waveshare.net/wiki/ESP32-S3-GEEK#ESP-IDF.E5.BC.80.E5.8F.91">ESP32-S3-GEEK - Waveshare Wiki</a></p><h3 id="ESP-IDF"><a href="#ESP-IDF" class="headerlink" title="ESP-IDF"></a>ESP-IDF</h3><p>ESP-IDF只有基础的点亮，显色，翻转，镜像等<a href="https://github.com/espressif/esp-idf/blob/master/components/esp_lcd/src/esp_lcd_panel_st7789.c">ST7789底层驱动</a>，<code>PRIV_REQUIRES</code>就可以了</p><p>至于画点画线需要上层封装</p><pre class="line-numbers language-none"><code class="language-none">1. 屏幕初始化与控制 (Initialization &amp; Control)创建驱动实例 (esp_lcd_new_panel_st7789): 根据您提供的配置（如RST引脚、像素格式、颜色顺序等）创建一个屏幕设备句柄。硬件&#x2F;软件复位 (esp_lcd_panel_reset): 通过控制 RST 引脚或发送 SWRESET 命令，让屏幕恢复到出厂默认状态。执行初始化序列 (esp_lcd_panel_init): 发送一系列预设的命令来唤醒屏幕、设置颜色模式、内存访问方式等，使其准备好接收图像数据。销毁驱动实例 (esp_lcd_panel_del): 释放驱动所占用的资源。2. 图像数据绘制 (Image Data Drawing)这是驱动的核心“工作”功能，负责将您在内存中准备好的像素数据发送到屏幕上显示。绘制位图 (esp_lcd_panel_draw_bitmap): 这是唯一的绘图函数。它接收一个矩形区域的坐标（x_start, y_start, x_end, y_end）和一个指向颜色数据缓冲区的指针，然后将这块数据通过 SPI 高效地“刷”到屏幕的指定位置。所有上层图形的显示，最终都依赖于对这个函数的反复调用。3. 显示方向与镜像 (Orientation &amp; Mirroring)驱动封装了 ST7789 芯片的硬件能力，可以高效地改变显示方向，而无需 CPU 进行像素运算。交换XY轴 (esp_lcd_panel_swap_xy): 切换横屏和竖屏显示。镜像翻转 (esp_lcd_panel_mirror): 可以独立地进行水平（X轴）或垂直（Y轴）翻转。4. 显示效果调整 (Display Effect Adjustment)驱动提供接口来调整一些屏幕的视觉特性。颜色反转 (esp_lcd_panel_invert_color): 在“正常”和“反色”模式之间切换。这对于适配不同物理特性的屏幕面板非常重要（我们刚刚的调试就用到了它）。设置物理偏移 (esp_lcd_panel_set_gap): 用于校准屏幕物理显示区域与驱动IC显存之间的坐标偏差，解决显示内容有黑边或错位的问题。5. 电源管理 (Power Management)提供基础的功耗控制功能，对电池供电设备尤其重要。开&#x2F;关显示 (esp_lcd_panel_disp_on_off): 控制屏幕内容是显示还是熄灭，但芯片本身并未休眠。进入&#x2F;退出睡眠 (esp_lcd_panel_disp_sleep): 发送命令让 ST7789 芯片进入低功耗的睡眠模式，或从睡眠中唤醒。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个项目的基础上修改<a href="https://github.com/espressif/esp-idf/tree/v5.5/examples/peripherals/lcd/tjpgd">esp-idf&#x2F;examples&#x2F;peripherals&#x2F;lcd&#x2F;tjpgd at v5.5 · espressif&#x2F;esp-idf</a></p><p>下一步是跑通lvgl,<a href="https://github.com/espressif/esp-idf/tree/master/examples/peripherals/lcd/spi_lcd_touch">这个历程</a>是带触摸的LCD的LVGL历程，可增加其他屏幕的驱动，也算是直接移植好lvgl的库，另外可以参考中景园电子的驱动</p><p>采用</p><p>lvgl移植参考</p><h1 id="参考项目"><a href="#参考项目" class="headerlink" title="参考项目"></a>参考项目</h1><p><a href="https://github.com/nopnop2002/esp-idf-st7789?tab=readme-ov-file">nopnop2002&#x2F;esp-idf-st7789：用于 esp-idf 的 ST7789 驱动程序</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> LCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32S3驱动OV5640</title>
      <link href="/2025/08/14/186-esp32s3-qu-dong-ov5640/"/>
      <url>/2025/08/14/186-esp32s3-qu-dong-ov5640/</url>
      
        <content type="html"><![CDATA[<h1 id="Arduino"><a href="#Arduino" class="headerlink" title="Arduino"></a>Arduino</h1><p>测试Demo，安装esp_camera库，实现网站实时显示摄像头内容。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;esp_camera.h&quot;#include &lt;WiFi.h&gt;#include &quot;esp_http_server.h&quot; &#x2F;&#x2F; 需要包含这个库来创建网页服务器&#x2F;&#x2F; 替换为您的 Wi-Fi 名称和密码const char* ssid &#x3D; &quot;&quot;;const char* password &#x3D; &quot;&quot;;&#x2F;&#x2F; #define PWDN_GPIO_NUM      5  &#x2F;&#x2F; OV_PWDN &#x2F;&#x2F; #define RESET_GPIO_NUM     4  &#x2F;&#x2F; OV_RESET &#x2F;&#x2F; #define XCLK_GPIO_NUM      -1  &#x2F;&#x2F; 这个引脚需要手动连接到模块的 XCLK 输入点&#x2F;&#x2F; #define SIOD_GPIO_NUM      2  &#x2F;&#x2F; OV_SDA &#x2F;&#x2F; #define SIOC_GPIO_NUM      1  &#x2F;&#x2F; OV_SCL &#x2F;&#x2F; #define Y9_GPIO_NUM        9  &#x2F;&#x2F; OV_D7 &#x2F;&#x2F; #define Y8_GPIO_NUM        10 &#x2F;&#x2F; OV_D6 &#x2F;&#x2F; #define Y7_GPIO_NUM        11 &#x2F;&#x2F; OV_D5 &#x2F;&#x2F; #define Y6_GPIO_NUM        12 &#x2F;&#x2F; OV_D4 &#x2F;&#x2F; #define Y5_GPIO_NUM        14 &#x2F;&#x2F; OV_D3 &#x2F;&#x2F; #define Y4_GPIO_NUM        13 &#x2F;&#x2F; OV_D2 &#x2F;&#x2F; #define Y3_GPIO_NUM        16 &#x2F;&#x2F; OV_D1 &#x2F;&#x2F; #define Y2_GPIO_NUM        15 &#x2F;&#x2F; OV_D0 &#x2F;&#x2F; #define VSYNC_GPIO_NUM     6  &#x2F;&#x2F; OV_VSYNC &#x2F;&#x2F; #define HREF_GPIO_NUM      7  &#x2F;&#x2F; OV_HREF &#x2F;&#x2F; #define PCLK_GPIO_NUM      8  &#x2F;&#x2F; OV_PCLK #define PWDN_GPIO_NUM      5#define RESET_GPIO_NUM     4#define XCLK_GPIO_NUM      -1  &#x2F;&#x2F; -1 表示模块自带时钟，ESP32不提供#define SIOD_GPIO_NUM      2#define SIOC_GPIO_NUM      1#define Y9_GPIO_NUM        9#define Y8_GPIO_NUM        10#define Y7_GPIO_NUM        11#define Y6_GPIO_NUM        12#define Y5_GPIO_NUM        14#define Y4_GPIO_NUM        13#define Y3_GPIO_NUM        16#define Y2_GPIO_NUM        15#define VSYNC_GPIO_NUM     6#define HREF_GPIO_NUM      7#define PCLK_GPIO_NUM      8static esp_err_t stream_handler(httpd_req_t *req)&#123;  camera_fb_t * fb &#x3D; NULL;  esp_err_t res &#x3D; ESP_OK;  size_t _jpg_buf_len &#x3D; 0;  uint8_t * _jpg_buf &#x3D; NULL;  char * part_buf[64];  res &#x3D; httpd_resp_set_type(req, &quot;multipart&#x2F;x-mixed-replace;boundary&#x3D;--frame&quot;);  if(res !&#x3D; ESP_OK)&#123;    return res;  &#125;  while(true)&#123;    fb &#x3D; esp_camera_fb_get();    if (!fb) &#123;      Serial.println(&quot;Camera capture failed&quot;);      res &#x3D; ESP_FAIL;    &#125; else &#123;      if(fb-&gt;format !&#x3D; PIXFORMAT_JPEG)&#123;        bool jpeg_converted &#x3D; frame2jpg(fb, 80, &amp;_jpg_buf, &amp;_jpg_buf_len);        esp_camera_fb_return(fb);        fb &#x3D; NULL;        if(!jpeg_converted)&#123;          Serial.println(&quot;JPEG compression failed&quot;);          res &#x3D; ESP_FAIL;        &#125;      &#125; else &#123;        _jpg_buf_len &#x3D; fb-&gt;len;        _jpg_buf &#x3D; fb-&gt;buf;      &#125;    &#125;    if(res &#x3D;&#x3D; ESP_OK)&#123;      size_t hlen &#x3D; snprintf((char *)part_buf, 64, &quot;Content-Type: image&#x2F;jpeg\r\nContent-Length: %u\r\n\r\n&quot;, _jpg_buf_len);      res &#x3D; httpd_resp_send_chunk(req, (const char *)part_buf, hlen);    &#125;    if(res &#x3D;&#x3D; ESP_OK)&#123;      res &#x3D; httpd_resp_send_chunk(req, (const char *)_jpg_buf, _jpg_buf_len);    &#125;    if(res &#x3D;&#x3D; ESP_OK)&#123;      res &#x3D; httpd_resp_send_chunk(req, &quot;\r\n--frame\r\n&quot;, strlen(&quot;\r\n--frame\r\n&quot;));    &#125;    if(fb)&#123;      esp_camera_fb_return(fb);      fb &#x3D; NULL;      _jpg_buf &#x3D; NULL;    &#125; else if(_jpg_buf)&#123;      free(_jpg_buf);      _jpg_buf &#x3D; NULL;    &#125;    if(res !&#x3D; ESP_OK)&#123;      break;    &#125;  &#125;  return res;&#125;void startCameraServer()&#123;  httpd_handle_t stream_httpd &#x3D; NULL;  httpd_config_t config &#x3D; HTTPD_DEFAULT_CONFIG();  httpd_uri_t stream_uri &#x3D; &#123;    .uri       &#x3D; &quot;&#x2F;&quot;,    .method    &#x3D; HTTP_GET,    .handler   &#x3D; stream_handler,    .user_ctx  &#x3D; NULL  &#125;;  if (httpd_start(&amp;stream_httpd, &amp;config) &#x3D;&#x3D; ESP_OK) &#123;    httpd_register_uri_handler(stream_httpd, &amp;stream_uri);  &#125;&#125;&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x2F;&#x2F; 主程序&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;void setup() &#123;  Serial.begin(115200);  Serial.setDebugOutput(true);  Serial.println();  camera_config_t config;  config.ledc_channel &#x3D; LEDC_CHANNEL_0;  config.ledc_timer &#x3D; LEDC_TIMER_0;  config.pin_d0 &#x3D; Y2_GPIO_NUM;  config.pin_d1 &#x3D; Y3_GPIO_NUM;  config.pin_d2 &#x3D; Y4_GPIO_NUM;  config.pin_d3 &#x3D; Y5_GPIO_NUM;  config.pin_d4 &#x3D; Y6_GPIO_NUM;  config.pin_d5 &#x3D; Y7_GPIO_NUM;  config.pin_d6 &#x3D; Y8_GPIO_NUM;  config.pin_d7 &#x3D; Y9_GPIO_NUM;  config.pin_xclk &#x3D; XCLK_GPIO_NUM;  config.pin_pclk &#x3D; PCLK_GPIO_NUM;  config.pin_vsync &#x3D; VSYNC_GPIO_NUM;  config.pin_href &#x3D; HREF_GPIO_NUM;  config.pin_sccb_sda &#x3D; SIOD_GPIO_NUM;  config.pin_sccb_scl &#x3D; SIOC_GPIO_NUM;  config.pin_pwdn &#x3D; PWDN_GPIO_NUM;  config.pin_reset &#x3D; RESET_GPIO_NUM;  &#x2F;&#x2F; config.xclk_freq_hz &#x3D; 0; &#x2F;&#x2F; 当pin_xclk为-1时，此项无效  config.xclk_freq_hz &#x3D; 20000000; &#x2F;&#x2F; 提供一个非零的虚拟值，例如20MHz  config.pixel_format &#x3D; PIXFORMAT_JPEG;  &#x2F;&#x2F; 对于高分辨率 (OV5640 支持 UXGA, QXGA 等)  &#x2F;&#x2F; 您可能需要使用 PSRAM。请确保您的 ESP32-S3 开发板有 PSRAM。  config.frame_size &#x3D; FRAMESIZE_UXGA; &#x2F;&#x2F; 1600x1200  config.jpeg_quality &#x3D; 12; &#x2F;&#x2F; 质量可以适当调整 (0-63, 数值越小质量越高)  config.fb_count &#x3D; 2;  config.fb_location &#x3D; CAMERA_FB_IN_PSRAM; &#x2F;&#x2F; 强制使用PSRAM  &#x2F;&#x2F; 初始化摄像头  esp_err_t err &#x3D; esp_camera_init(&amp;config);  if (err !&#x3D; ESP_OK) &#123;    Serial.printf(&quot;摄像头初始化失败，错误码: 0x%x&quot;, err);    return;  &#125;  Serial.println(&quot;摄像头初始化成功！&quot;);  &#x2F;&#x2F; 连接 WiFi  WiFi.begin(ssid, password);  while (WiFi.status() !&#x3D; WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;\nWiFi 已连接&quot;);  Serial.print(&quot;摄像头视频流地址: http:&#x2F;&#x2F;&quot;);  Serial.println(WiFi.localIP());  &#x2F;&#x2F; 启动网页服务器  startCameraServer();&#125;void loop() &#123;  &#x2F;&#x2F; 主循环保持空闲，因为服务器在后台运行  delay(10000);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1><ul><li><p><a href="https://docs.espressif.com/projects/esp-faq/zh_CN/latest/application-solution/camera-application.html">摄像头应用方案 - - — ESP-FAQ latest 文档</a></p></li><li><p><a href="https://github.com/espressif/esp32-camera/blob/master/README.md">支持的摄像头型号</a></p></li></ul><h1 id="esp32-camera"><a href="#esp32-camera" class="headerlink" title="esp32-camera"></a><a href="https://github.com/espressif/esp32-camera">esp32-camera</a></h1><p>一条命令把示例拉进你工程：<br> <code>idf.py create-project-from-example &quot;espressif/esp32-camera:camera_example&quot;</code>（会生成已配好 menuconfig 的示例）。<a href="https://github.com/espressif/esp32-camera">GitHub</a></p><p>也可直接给工程加依赖：<code>idf.py add-dependency &quot;espressif/esp32-camera&quot;</code>；然后 <code>#include &quot;esp_camera.h&quot;</code>。<a href="https://github.com/espressif/esp32-camera">GitHub</a></p><p>⚠️:一定要不厌其烦的检查硬件,否则容易在小地方卡很长时间</p><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><p>获取像素数据显示在屏幕上</p><p>基础操作</p><p>帧率</p><p>缩放</p>]]></content>
      
      
      
        <tags>
            
            <tag> 摄像头 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用LDO方案</title>
      <link href="/2025/08/05/185-ldo-fang-an/"/>
      <url>/2025/08/05/185-ldo-fang-an/</url>
      
        <content type="html"><![CDATA[<h2 id="LDO"><a href="#LDO" class="headerlink" title="LDO"></a>LDO</h2><table><thead><tr><th align="center">芯片</th><th>工作电流</th><th>工作电压</th><th>输出电压</th><th>单价&#x2F;个</th></tr></thead><tbody><tr><td align="center"><a href="https://item.szlcsc.com/84106.html?fromZone=s_s__%22ME6211C33M5G-N%22&spm=sc.gb.xh1.zy.n___sc.gb.hd.ss&lcsc_vid=TlYKXgJfFQdeBQAEQFIPVFJUQ1ILVFwEFAUMV1NeT1IxVlNSQ1ZYUlZUQFlYXztW">ME6211C33M5G-N</a></td><td>500MA</td><td>2V-6.5V</td><td>3.3</td><td>0.31</td></tr><tr><td align="center"><a href="https://item.szlcsc.com/6652.html?fromZone=s_s__%22ams1117%22&spm=sc.gb.xh1.zy.n___sc.gb.hd.ss&lcsc_vid=TlYKXgJfFQdeBQAEQFIPVFJUQ1ILVFwEFAUMV1NeT1IxVlNSQ1ZYUlZUQFlYXztW">AMS1117-3.3</a></td><td>1A</td><td>4.8V</td><td>3.3</td><td>1.30</td></tr><tr><td align="center"><a href="https://item.szlcsc.com/236120.html?fromZone=s_s__%22me6210%22&spm=sc.gb.xh2.zy.n___sc.gb.hd.ss&lcsc_vid=TlYKXgJfFQdeBQAEQFIPVFJUQ1ILVFwEFAUMV1NeT1IxVlNSQ1ZYUlZUQFlYXztW">ME6210A33M3G</a></td><td>500mA</td><td>18V</td><td>3.3</td><td>0.37</td></tr><tr><td align="center"></td><td></td><td></td><td></td><td></td></tr><tr><td align="center"></td><td></td><td></td><td></td><td></td></tr><tr><td align="center"></td><td></td><td></td><td></td><td></td></tr><tr><td align="center"></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> LDO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电池管理芯片方案</title>
      <link href="/2025/08/05/184-dian-chi-guan-li-xin-pian-fang-an/"/>
      <url>/2025/08/05/184-dian-chi-guan-li-xin-pian-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="IC"><a href="#IC" class="headerlink" title="IC"></a>IC</h1><table><thead><tr><th align="center">IC</th><th>数据手册</th><th></th><th></th></tr></thead><tbody><tr><td align="center"><a href="https://www.ti.com/cn/lit/ds/symlink/bq25606.pdf?ts=1754307877887&ref_url=https://list.szlcsc.com/">BQ25606RGER</a></td><td></td><td></td><td></td></tr><tr><td align="center"></td><td></td><td></td><td></td></tr><tr><td align="center"></td><td></td><td></td><td></td></tr></tbody></table><h2 id="BQ25606RGER"><a href="#BQ25606RGER" class="headerlink" title="BQ25606RGER"></a>BQ25606RGER</h2><h3 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h3><img src="/2025/08/05/184-dian-chi-guan-li-xin-pian-fang-an/1754386379507.png" class="" width="1754386379507"><img src="/2025/08/05/184-dian-chi-guan-li-xin-pian-fang-an/1754386398556.png" class="" width="1754386398556">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32_Flash读取与加密</title>
      <link href="/2025/08/01/183-esp32-flash-du-qu-yu-jia-mi/"/>
      <url>/2025/08/01/183-esp32-flash-du-qu-yu-jia-mi/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>偶然发现ESP官方的<a href="https://docs.espressif.com/projects/esptool/en/latest/esp32/installation.html">esptools</a>竟然可以直接读取固件</p><h1 id="安装esptool"><a href="#安装esptool" class="headerlink" title="安装esptool"></a>安装esptool</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install esptool<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="read-flash"><a href="#read-flash" class="headerlink" title="read flash"></a><a href="https://docs.espressif.com/projects/esptool/en/release-v4/esp32s3/esptool/basic-commands.html#read-flash-contents-read-flash">read flash</a></h2><p>ead-flash 命令允许读回闪存的内容。该命令的参数是地址、大小和要输出到的文件路径。例如，要读取完整的 2MB 连接闪存：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">esptool -p COM18 -b 460800 read_flash 0 0x200000 flash_contents.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>all</code>自动检测flash尺寸</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">esptool -p PORT -b 460800 read-flash 0 ALL flash_contents.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>windows环境下安装<code>esptool</code>后，会在Script生成esptool.exe文件,所以使用<code>esptool</code>或者<code>python -m esptool</code>执行命令,linux或者macos使用<code>esptool.py</code></p><h2 id="write-flash"><a href="#write-flash" class="headerlink" title="write-flash"></a><a href="https://docs.espressif.com/projects/esptool/en/release-v4/esp32s3/esptool/basic-commands.html#write-binary-data-to-flash-write-flash">write-flash</a></h2><p>二进制数据可以通过串行命令写入 ESP 的闪存芯片：<code>write-flash</code></p><p>烧录完整固件</p><pre class="line-numbers language-none"><code class="language-none">esptool --port COM18 --baud 460800 write_flash 0x00000 flash_contents.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以在同一命令行上给出多个闪存地址和文件名：</p><pre class="line-numbers language-none"><code class="language-none">esptool --port COM18 write-flash 0x00000 my_app.elf-0x00000.bin 0x40000 my_app.elf-0x40000.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>esptool可以实现读取指定地址指定长度的数据,同样也可以写入</p></blockquote><p><code>esptool</code> 的 <code>read-flash</code>（CLI 中写作 <code>read_flash</code>）命令就是按你指定的偏移和长度去读取 Flash 的任意区域——也就意味着只要你知道某个分区在 Flash 上的起始地址和大小，就能<strong>只读出</strong>那一段数据，而不会影响其它分区。</p><ul><li><p><strong>命令形式</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">esptool --port PORT --baud BAUD read_flash &lt;address&gt; &lt;size&gt; &lt;outfile&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 <code>&lt;address&gt;</code> 是起始偏移，<code>&lt;size&gt;</code> 是要读出的字节数（可以用十六进制、后缀 k&#x2F;M，或用 <code>ALL</code> 来自动探测整片 Flash）[</p></li><li><p><strong>示例：只读 Bootloader（位于 0x1000）</strong><br> 假设你编译的 bootloader.bin 是 0x8000 字节（32 KB），那么：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">esptool --port COM18 --baud 460800 read_flash 0x1000 0x8000 bootloader.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样仅会把从偏移 <code>0x1000</code> 开始、长度为 <code>0x8000</code> 的那部分数据导出到 <code>bootloader.bin</code>。</p></li><li><p><strong>示例：只读分区表（位于 0x8000，默认长度 0xC00）</strong><br> ESP-IDF 默认把分区表编译为 0xC00（3072 B），放在 Flash 偏移 <code>0x8000</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">esptool --port COM18 --baud 460800 read_flash 0x8000 0xC00 partition-table.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就只会导出分区表，不会碰到应用固件或文件系统区域。</p></li></ul><p>只要知道目标分区的 <strong>起始地址</strong> 和 <strong>长度</strong>，<code>read_flash</code> 就能按需读取对应分区的数据，而不是整片 Flash。</p><h2 id="flash-加密"><a href="#flash-加密" class="headerlink" title="flash 加密"></a><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.4.2/esp32s3/security/flash-encryption.html">flash 加密</a></h2><ul><li><p>打开menuconfig，勾选使能flash加密</p></li><li><p>选择加密模式，默认是开发模式</p></li><li><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.4.2/esp32s3/api-reference/kconfig.html#config-secure-uart-rom-dl-mode">选择 UART ROM 下载模式</a> （默认是 <strong>启用</strong>）。</p></li><li><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.4.2/esp32s3/api-reference/kconfig.html#config-bootloader-log-level">选择适当详细程度的引导加载程序日志</a>。</p></li><li><p>保存配置并退出。</p></li></ul><p>运行以下命令来构建和烧录完整的镜像。</p><blockquote><pre class="line-numbers language-none"><code class="language-none">idf.py flash monitor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><pre class="line-numbers language-none"><code class="language-none">idf.py secure-generate-flash-encryption-key my_flash_encryption_key.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>在第一次加密启动前</strong>，使用以下命令将该密钥烧录到设备上，这个操作只能执行 <strong>一次</strong>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">idf.py --port PORT efuse-burn-key BLOCK_KEY0  my_flash_encryption_key.bin XTS_AES_128_KEY<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后烧录程序后（第一次是明文烧录），二级引导加载程序将配置并启用 flash 加密块</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PS C:\Users\VIBTEK\Desktop\flash&gt; idf.py --port COM18 efuse-burn-key BLOCK_KEY0 my_flash_encryption_key.bin XTS_AES_128_KEYExecuting action: efuse-burn-keyRunning espefuse.py in directory C:\Users\VIBTEK\Desktop\flashExecuting &quot;c:\Users\VIBTEK\.espressif\python_env\idf5.4_py3.11_env\Scripts\python.exe -mespefuse burn_key -p COM18 --chip esp32s3 BLOCK_KEY0 my_flash_encryption_key.bin XTS_AES_128_KEY&quot;...espefuse.py v4.9.0Connecting....&#x3D;&#x3D;&#x3D; Run &quot;burn_key&quot; command &#x3D;&#x3D;&#x3D;Sensitive data will be hidden (see --show-sensitive-info)Burn keys to blocks: - BLOCK_KEY0 -&gt; [?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??]        Reversing byte order for AES-XTS hardware peripheral        &#39;KEY_PURPOSE_0&#39;: &#39;USER&#39; -&gt; &#39;XTS_AES_128_KEY&#39;.        Disabling write to &#39;KEY_PURPOSE_0&#39;.        Disabling read to key block        Disabling write to key block<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>加密不可逆,芯片设定为加密后无法取消,除了换芯片</p><p>另外加密后的固件也可以读出来</p></blockquote><p><strong>读取源二进制文件</strong></p><p>在 PowerShell 里用 <code>Format-Hex</code></p><ol><li><p>关闭当前的 cmd 窗口。</p></li><li><p>用 Win+X 或开始菜单打开 <strong>Windows PowerShell</strong>（或 PowerShell 7）。</p></li><li><p>切到你的目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PS C:\&gt; cd D:\Tools\Esptools<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PS D:\Tools\Esptools&gt; Format-Hex .\flash_contents.bin | more<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>more</code> 会分页显示，每次按空格翻页。</li></ul></li></ol><p>未加密数据</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PS D:\Tools\Esptools&gt; Format-Hex .\flash_contents.bin | more           路径: D:\Tools\Esptools\flash_contents.bin           00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F00000000   E9 04 02 1F 28 89 3C 40 EE 00 00 00 09 00 00 00  é...(?&lt;@?.......00000010   00 63 00 00 00 00 00 01 10 28 CE 3F 64 15 00 00  .c.......(??d...00000020   50 00 00 00 01 00 00 00 48 45 41 44 2D 48 41 53  P.......HEAD-HAS00000030   48 2D 4E 4F 54 46 4F 55 4E 44 00 00 00 00 00 00  H-NOTFOUND......00000040   00 00 00 00 00 00 00 00 4A 75 6C 20 32 39 20 32  ........Jul 29 200000050   30 32 35 20 31 35 3A 30 37 3A 31 30 00 00 00 00  025 15:07:10....00000060   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................00000070   FF FF FF FF 1B 00 00 00 1B 00 00 00 1C 00 00 00  ................00000080   1C 00 00 00 B4 06 00 40 28 50 04 00 F8 27 03 00  ....′..@(P..?&#39;..00000090   01 00 00 00 00 F0 01 60 00 00 00 00 04 00 00 00  .....e.........000000A0   05 00 00 00 06 00 00 00 07 00 00 00 41 73 73 65  ............Asse000000B0   72 74 20 66 61 69 6C 65 64 20 69 6E 20 25 73 2C  rt failed in %s,000000C0   20 25 73 3A 25 64 20 28 25 73 29 0D 0A 00 61 62   %s:%d (%s)...ab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-USB-OTG-HOST</title>
      <link href="/2025/07/28/182-esp32-usb-otg-host/"/>
      <url>/2025/07/28/182-esp32-usb-otg-host/</url>
      
        <content type="html"><![CDATA[<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><ul><li>一块支持USB-OTG的开发板</li><li>一块USB-CDC的device</li><li>一根双头type-c数据线</li></ul><h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><p>将device接收到的数据进行uart转发</p><p>出现的错误</p><ul><li><p><strong>Dangling Pointer (悬空指针) &#x2F; Race Condition (竞态条件)</strong>: <code>handle_rx</code> 回调函数中的 <code>data</code> 指针指向的是 USB 驱动内部的接收缓冲区。这个缓冲区是<strong>可重用</strong>的。当 <code>handle_rx</code> 返回后，该缓冲区可能会立即被新的 USB 数据覆盖，或者被驱动内部的其他操作使用。如果 <code>tx_task</code> 在此之后才尝试读取 <code>cdc_data</code> 指向的数据，它将读取到<strong>过期、无效或已被覆盖的数据</strong>，导致程序崩溃或发送错误数据。</p></li><li><p><strong>数据长度丢失</strong>: <code>handle_rx</code> 接收到 <code>data_len</code> 参数，但 <code>cdc_data</code> 只是一个指针，没有携带数据长度信息。<code>tx_task</code> 中的 <code>sendData</code> 函数使用 <code>strlen(data)</code> 来确定长度，这对于非以 <code>\0</code> 结尾的二进制数据是错误的，会导致读取越界。</p></li><li><p><strong>任务创建时机错误</strong>: <code>tx_task</code> 在 <code>app_main</code> 的 <code>while(true)</code> 循环内部，并且在 <code>xSemaphoreTake(device_disconnected_sem, portMAX_DELAY)</code> 之后才创建。这意味着 <code>tx_task</code> 只有在 USB 设备第一次断开连接后才会创建并开始运行，这显然不是你想要的实时转发行为。</p></li></ul><h2 id="完善思路"><a href="#完善思路" class="headerlink" title="完善思路"></a>完善思路</h2><ul><li><p><strong>数据拷贝 (malloc + memcpy)</strong>：当 <code>handle_rx</code> 收到数据时，我们立即把它<strong>复制一份</strong>到一块全新的、只属于我们自己的内存空间里。这就像你把纸条上的内容抄写到一张新纸上，然后把新纸给朋友。这样，即使原纸条被修改，你的朋友手里的副本也不会受影响。</p></li><li><p><code>malloc</code> 就是问系统要一块新的内存空间。</p></li><li><p><code>memcpy</code> 就是把数据从 USB 驱动的缓冲区复制到这块新内存里。</p></li><li><p><strong>队列 (Queue)</strong>：既然数据复制好了，怎么安全地把这个新数据交给 <code>uart_tx_task</code> 呢？直接给一个全局变量还是有问题，因为两个任务同时操作一个变量会有竞争。最好的办法是使用一个 <strong>“中间站”</strong>，也就是 <strong>队列 (Queue)</strong>。</p></li><li><p><code>handle_rx</code> 把包含新数据地址和长度的<strong>小包裹</strong>（<code>usb_data_packet_t</code>）<strong>放到队列里</strong>。</p></li><li><p><code>uart_tx_task</code> <strong>从队列里取包裹</strong>。如果队列里没包裹，它就等着，不浪费 CPU。</p></li><li><p>队列机制确保了数据的<strong>有序性</strong>和<strong>安全性</strong>，避免了同时读写带来的混乱。</p></li><li><p><strong>内存释放 (free)</strong>：你问系统要了内存，用完了就得还回去。不然，内存会越用越少，最终导致程序崩溃（<strong>内存泄漏</strong>）。</p></li><li><p><code>uart_tx_task</code> 收到数据并用完后，它就负责把之前 <code>malloc</code> 出来的内存用 <code>free</code> 还给系统。这就像朋友看完了纸条，就把它扔进回收站。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> USB-OTG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux to windows 无线串口</title>
      <link href="/2025/07/24/181-linux-to-windows-wu-xian-chuan-kou/"/>
      <url>/2025/07/24/181-linux-to-windows-wu-xian-chuan-kou/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>使用蓝牙透传时，发现高速数据会卡顿，于是想试一下别的无线传输方式</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Orangepi</li><li>socat</li><li>有人的tcp转虚拟串口</li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><strong>将串口数据通过TCP&#x2F;IP隧道传输</strong>，让Windows端通过虚拟串口软件接收数据。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="1-Linux端配置-串口-TCP"><a href="#1-Linux端配置-串口-TCP" class="headerlink" title="1. Linux端配置 (串口 -&gt; TCP)"></a><strong>1. Linux端配置 (串口 -&gt; TCP)</strong></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装socatsudo apt install socat# 将串口&#x2F;dev&#x2F;ttyS0的数据转发到TCP 8888端口socat -d -d TCP-LISTEN:8888,reuseaddr,fork FILE:&#x2F;dev&#x2F;ttyS0,raw,echo&#x3D;0,b115200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>参数说明</strong>：<ul><li><code>b115200</code>：波特率（按实际设备修改）</li><li><code>reuseaddr</code>：允许端口重用</li><li><code>fork</code>：保持服务持续运行</li><li>如果串口需要权限，可添加<code>sudo</code>或配置udev规则</li></ul></li></ul><h2 id="Windows端配置"><a href="#Windows端配置" class="headerlink" title="Windows端配置"></a>Windows端配置</h2><p><a href="https://www.usr.cn/Download/31.html">USR-VCOM</a></p><ul><li>tcp client</li><li>配置监听ip与端口（也就是linux端ip与端口）</li></ul><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>经过测试发现同样出现卡顿现象，且待测试模块的上位机无法识别虚拟串口</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>局域网文件传输</title>
      <link href="/2025/07/19/180-ju-yu-wang-wen-jian-chuan-shu/"/>
      <url>/2025/07/19/180-ju-yu-wang-wen-jian-chuan-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>二零二五年七月四号组了人生的第一台主机，肥肠开心，但是现在需要将笔记本的数据迁移，情况比较复杂，笔记本是一块m2（c、e、f）+一块sata（d）组成的，软件游戏都在在m2中，数据和系统都在sata，所以需要捯饬一下。<br>打算格式化软件盘，然后克隆c到d，最后取出sata盘装到主机上。</p><h1 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h1><p>1.控制面板\网络和 Internet\网络和共享中心\高级共享设置</p><blockquote><p>启动网络发现与文件共享</p></blockquote><p>2.找到共享的磁盘,一般建议新建一个文件夹用来共享<br>属性-&gt;共享-&gt;高级共享-&gt;共享文件夹-&gt;应用<br><code>然后在安全中添加Everyone的用户名</code><br>3.旧电脑使用<code>ipconfig</code>查看本机ip,新电脑<code>win+r</code>或者<code>文件管理器地址栏</code>输入<code>\\192.168.31.78</code>即可看到共享文件.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>电阻-电容-电感</title>
      <link href="/2025/07/16/179-dian-zu-dian-rong-dian-gan/"/>
      <url>/2025/07/16/179-dian-zu-dian-rong-dian-gan/</url>
      
        <content type="html"><![CDATA[<h1 id="电阻"><a href="#电阻" class="headerlink" title="电阻"></a>电阻</h1><h1 id="电容"><a href="#电容" class="headerlink" title="电容"></a>电容</h1><h1 id="电感"><a href="#电感" class="headerlink" title="电感"></a>电感</h1><h2 id="电感的大小决定着什么"><a href="#电感的大小决定着什么" class="headerlink" title="电感的大小决定着什么"></a>电感的大小决定着什么</h2><ul><li><strong>L 越大</strong> → ΔI 越小（峰–峰纹波电流）</li><li>更低的输出电压纹波</li><li>瞬态响应速度⬇️<ul><li><strong>L 越大</strong> → LC 回路谐振频率 f₀&#x3D;1&#x2F;(2π√LC) 降低 → 带宽变窄</li><li>负载突变（如 0→3 A）时，输出电压的过冲&#x2F;下冲更大、恢复更慢</li><li>如果应用对瞬态要求苛刻（快速大电流跳变），宜选 1–2 μH；若负载平缓，可以用 3.3 μH 来换取更低纹波。</li></ul></li><li>L⬆️，体积⬆️</li></ul><h1 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h1><table><thead><tr><th>指标</th><th>L&#x3D;1.5 μH</th><th>L&#x3D;3.3 μH</th><th>变化</th></tr></thead><tbody><tr><td>峰–峰纹波电流</td><td>≈2.45 App</td><td>≈1.11 App</td><td>↓~55%</td></tr><tr><td>输出纹波 (≈44 μF)</td><td>≈35 mVpp</td><td>≈16 mVpp</td><td>↓~55%</td></tr><tr><td>瞬态带宽</td><td>较高</td><td>较低</td><td>响应更快 vs 响应更慢</td></tr><tr><td>铜损 (DCR)</td><td>较低</td><td>较高</td><td>轻微↑</td></tr><tr><td>EMI</td><td>较差</td><td>较好</td><td>更低的纹波→更低的干扰</td></tr><tr><td>PCB 尺寸</td><td>较小</td><td>较大</td><td>空间需求↑</td></tr></tbody></table><p>选择时就看你更在意“低纹波&#x2F;低 EMI”还是“快速瞬态&#x2F;小体积”了：</p><ul><li><strong>若负载平稳、对纹波非常敏感</strong>，用 3.3 μH；</li><li><strong>若负载跳变剧烈、且空间受限</strong>，用 1.5 μH。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TPS54627稳压芯片</title>
      <link href="/2025/07/16/178-tps54627-wen-ya-xin-pian/"/>
      <url>/2025/07/16/178-tps54627-wen-ya-xin-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul><li><a href="https://www.ti.com/cn/lit/gpn/tps54627">https://www.ti.com/cn/lit/gpn/tps54627</a></li></ul><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><ul><li>工作电压：4.5V~18V</li><li>输出电压：765mV~5.5V</li><li>输出电流：6A</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><img src="/2025/07/16/178-tps54627-wen-ya-xin-pian/1753238692001.png" class="" width="1753238692001"><p>*<em>输出电压：</em><code>Vout=0.765*(1+R1/R2)</code></p><h1 id="开源项目示例（未验证）"><a href="#开源项目示例（未验证）" class="headerlink" title="开源项目示例（未验证）"></a>开源项目示例（未验证）</h1><img src="/2025/07/16/178-tps54627-wen-ya-xin-pian/1753238864782.png" class="" width="1753238864782"><p>Vout&#x3D;0.765*（1+56&#x2F;10）&#x3D;5.049</p>]]></content>
      
      
      
        <tags>
            
            <tag> DC-DC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-USB-OTG</title>
      <link href="/2025/07/10/177-esp32-usb-otg/"/>
      <url>/2025/07/10/177-esp32-usb-otg/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我需要使用ESP32作为主机接受USB CDC设备的数据并转发打印出来</p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32s3/api-reference/peripherals/usb_host.html">USB Host - ESP32-S3 - — ESP-IDF 编程指南 latest 文档</a></li><li><a href="https://github.com/espressif/esp-idf/tree/5b11d5b2/examples/peripherals/usb/host/cdc/cdc_acm_host">esp-idf&#x2F;examples&#x2F;peripherals&#x2F;usb&#x2F;host&#x2F;cdc&#x2F;cdc_acm_host at 5b11d5b26a8bf151fc6bac400158859eedd413bc · espressif&#x2F;esp-idf</a></li><li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32s3/api-reference/peripherals/usb_host.html#id15">USB 主机 - ESP32-S3 - — ESP-IDF 编程指南 latest 文档</a></li><li><a href="https://github.com/espressif/esp-idf/tree/5b11d5b26a8bf151fc6bac400158859eedd413bc/examples/peripherals/usb/host/cdc/cdc_acm_vcp/main">esp-idf&#x2F;examples&#x2F;peripherals&#x2F;usb&#x2F;host&#x2F;cdc&#x2F;cdc_acm_vcp&#x2F;main at 5b11d5b26a8bf151fc6bac400158859eedd413bc · espressif&#x2F;esp-idf</a></li><li><a href="https://esphome.io/components/usb_uart.html">USB UART Interface — ESPHome</a></li><li><a href="https://docs.espressif.com/projects/esp-iot-solution/zh_CN/latest/usb/usb_overview/usb_otg.html">USB-OTG 外设介绍 - - — ESP-IoT-Solution latest 文档</a></li></ul><h1 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h1><p>老板儿下发需要使用ESP32做主机接收一款无线电频谱探测设备<code>usb模拟串口</code>的数据，我默认usb模拟串口就是USB_CDC规范的,然后又因为ESP32S3这个芯片是支持USB_OTG的，所以我又默认手里这块板子支持了。</p><p>我看了板子的文档，但是我误以为这句话是有OTG功能的意思</p><img src="/2025/07/10/177-esp32-usb-otg/1752481676321.png" class="" width="1752481676321"><p>因为手头的ESP32S3只有一个Type-c的头（又看了原理图，不能反向供电），所以我进行了单独供电，发现还是不行。然后新板子到了（还好买了新板子），连接测试device设备成功，打印了一些数据，但是无线电频谱那块板子还是不行,因为是CH340E芯片。</p><p>AI老师说:’’这个芯片不是标准的CDC规范’’</p><p><code>CH340E 不遵循标准 CDC ACM 类定义（它是厂商自定义类 Class 0xFF）</code></p><p>改了几版都有毛病,又去看文档了,发现有一个例程支持CH34X的(ESP还是太全面了)烧录后成功了。</p><h1 id="虚拟串口"><a href="#虚拟串口" class="headerlink" title="虚拟串口"></a>虚拟串口</h1><p>USB 虚拟串口（Virtual COM Port）指的是：在 USB 总线上模拟出一个传统的串口（UART&#x2F;RS-232）接口，让主机系统把它当成一个“串口设备”来驱动和使用，用户在操作系统里会看到一个 COM 端口（Windows 下如 COM3，Linux 下如 &#x2F;dev&#x2F;ttyUSB0）。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol><li><strong>USB CDC-ACM 类</strong><br> USB 定义了一种 “CDC-ACM”（Communications Device Class &amp; Abstract Control Model）协议，它专门用来在 USB 上传输“串口”数据，并提供设置波特率、数据位、校验位、流控等控制命令。只要设备声明自己支持 CDC-ACM 类，主机就会加载标准的 USB 串口驱动，把它当成串口来用。</li><li><strong>硬件转换器芯片</strong><br> 像 FT232R、CP2102、CH340E 这些 USB 转串口芯片，内部同时实现了：<ul><li>一端是 <strong>USB PHY + USB 协议栈</strong>，与主机交换 USB 包；</li><li>另一端是 <strong>TTL 级别的 UART</strong>（即逻辑电平 3.3V&#x2F;5V 的 RX&#x2F;TX 口）；<br> 它把 USB 收到的数据解包成 UART RX 流，也把从 UART TX 收到的数据打包成 USB 包，再发给主机。</li></ul></li></ol><h1 id="USB-OTG"><a href="#USB-OTG" class="headerlink" title="USB OTG"></a>USB OTG</h1><p><strong>USB OTG (On-The-Go)</strong> 本质上是一种 <strong>USB 功能的规范</strong>，它赋予了 USB 端口<strong>角色动态切换的能力</strong>。</p><ul><li><strong>不是一个通信协议本身：</strong> USB OTG 自身不定义如何传输数据（比如数据包的格式、时序等），那些是 USB 2.0&#x2F;3.0 等基础 USB 协议层的工作。</li><li><strong>不是一个硬件模块：</strong> 虽然实现 USB OTG 功能需要特定的硬件支持（比如 ESP32-S3 内部的 USB OTG 控制器），但 OTG 本身不是那个硬件模块。它描述的是硬件模块应该如何表现，以及设备之间如何协商谁是主机、谁是设备。</li><li><strong>它的核心在于“角色”：</strong> 传统的 USB 只有固定的主机和设备。OTG 打破了这个限制，让一个设备可以根据需要，既能做老大（Host），也能做小弟（Device）。这就像一个人，在家里可以是家长，在公司可以是员工。OTG 定义的就是他如何在这两个角色之间切换的规则。</li></ul><blockquote><p>切换主从设备的一种规范</p></blockquote><h1 id="USB-CDC"><a href="#USB-CDC" class="headerlink" title="USB CDC"></a>USB CDC</h1><p><strong>USB CDC (Communication Device Class)</strong> 本质上是一种 <strong>USB 设备类型或“类”的规范</strong>。</p><ul><li><strong>不是一个通信协议本身：</strong> CDC 不定义底层的 USB 数据传输方式，它是在 USB 传输协议之上，定义了如何将“通信设备”（比如调制解调器、网卡，以及我们常见的虚拟串口）的数据和控制命令封装成 USB 协议可以识别的格式。</li><li><strong>不是一个硬件模块：</strong> 就像 OTG 一样，CDC 也需要硬件来实现（比如你说的 CH340 芯片，或者 ESP32-S3 内部通过固件模拟 CDC 设备）。但 CDC 本身不是芯片，它是一种“蓝图”或“标准”，指导芯片如何实现“通信设备”的功能。</li><li><strong>它的核心在于“功能”和“标准化”：</strong> 想象 USB 有很多种“语言”，每种语言对应一类设备。CDC 就是其中一种“语言”，专门用来让 USB 设备扮演成串口设备（或其他通信设备）。因为有了这个标准，无论哪个厂商生产的 USB 虚拟串口芯片，只要遵循 CDC 规范，主机（如电脑或 ESP32-S3）就能使用通用的 CDC 驱动来识别和通信，而不需要为每种芯片开发专属驱动。</li></ul><hr><h3 id="USB-CDC-的实现位置"><a href="#USB-CDC-的实现位置" class="headerlink" title="USB CDC 的实现位置"></a>USB CDC 的实现位置</h3><p><strong>USB CDC（Communication Device Class）协议的实现是在 USB 设备（从机）端。</strong></p><p>简单来说，当一个设备宣称自己是 USB CDC 设备时，它内部需要有一个固件（或硬件芯片）能够：</p><ol><li><strong>理解 USB 协议的底层通信机制。</strong></li><li><strong>按照 CDC 规范来封装和解封装数据。</strong> 也就是说，它要把自己内部的数据（比如传感器读数、微控制器产生的调试信息）伪装成串口数据，然后通过 USB 协议发送出去。</li></ol><p>比如你说的 CH340、CP2102、FT232R 这些芯片，它们之所以能“模拟串口”，就是因为它们内部集成了 USB 控制器和预烧录的固件，这些固件完全实现了 <code>USB CDC 协议</code>。它们连接到电脑后，电脑一看：“哦，这是一个 CDC 设备，我可以用我系统自带的虚拟串口驱动来和它通信。”</p><h3 id="电脑端的作用：提供驱动"><a href="#电脑端的作用：提供驱动" class="headerlink" title="电脑端的作用：提供驱动"></a>电脑端的作用：提供驱动</h3><p>电脑端（或者像 ESP32-S3 这样的 USB 主机）不需要“开启 CDC”。它的作用是：</p><ol><li><strong>作为 USB 主机：</strong> 提供 USB 端口并负责枚举和管理连接的 USB 设备。</li><li><strong>提供 CDC 主机驱动：</strong> 当电脑识别到一个 USB CDC 设备时，它会加载相应的 <strong>USB CDC 主机驱动</strong>（通常操作系统自带）。这个驱动就像一个“翻译官”，它负责：<ul><li><strong>将来自 CDC 设备的数据包解包，并将其呈现为虚拟串口的数据流。</strong> 这样，你的串口调试助手或应用程序就能像操作真实串口一样来读写数据。</li><li><strong>将你的应用程序发送的串口数据封装成 USB 数据包，并发送给 CDC 设备。</strong></li></ul></li></ol><p>所以，<strong>CDC 的核心逻辑和实现是在设备端</strong>，电脑端只是提供了一个通用的驱动来理解和利用这个 CDC 设备。</p><h3 id="开发板如何实现-CDC"><a href="#开发板如何实现-CDC" class="headerlink" title="开发板如何实现 CDC"></a>开发板如何实现 CDC</h3><p>如果别的开发板（比如基于 STM32、GD32 等其他微控制器的开发板）想要通过 USB 接口<strong>模拟串口</strong>（成为一个 USB CDC 设备），它们通常会这么做：</p><ol><li><strong>使用内置的 USB 外设：</strong> 很多微控制器都内置了 USB 控制器（Full-speed 或 High-speed）。</li><li><strong>在固件中实现 USB CDC 协议栈：</strong> 开发者需要在微控制器的固件中编写代码，实现 USB CDC 协议栈。这包括：<ul><li>USB 描述符（告诉主机我是谁，我是 CDC 设备）。</li><li>数据端点的配置（IN&#x2F;OUT 端点用于数据传输）。</li><li>CDC 类的具体实现（如何处理串行数据流和控制命令）。</li><li>中断服务程序（处理 USB 事件）。 这些工作通常会使用微控制器厂商提供的 USB 库或第三方的 USB 协议栈（如 TinyUSB）。</li></ul></li></ol><h3 id="为什么-ESP32-S3-作为主机时不需要-CDC"><a href="#为什么-ESP32-S3-作为主机时不需要-CDC" class="headerlink" title="为什么 ESP32-S3 作为主机时不需要 CDC"></a>为什么 ESP32-S3 作为主机时不需要 CDC</h3><ul><li><strong>CDC 是设备端的能力</strong>，让设备能伪装成串口。</li><li><strong>USB 主机需要 CDC 驱动</strong>，才能和这些 CDC 设备通信。</li></ul><h2 id="总结本质："><a href="#总结本质：" class="headerlink" title="总结本质："></a>总结本质：</h2><ul><li><strong>USB OTG 的本质是：</strong> USB 端口<strong>角色动态切换的规范</strong>。它解决了“谁是老大”的问题，让设备可以根据连接对象动态切换为“主机”或“设备”。</li><li><strong>USB CDC 的本质是：</strong> 一种 <strong>USB 设备类别规范</strong>，用于定义如何通过 USB 接口来<strong>模拟传统串行通信</strong>功能。它解决了“怎么通信”（以串口形式）的问题。</li></ul><p>两者缺一不可。你的 ESP32-S3 必须具备 <strong>OTG 能力</strong>并扮演<strong>主机角色</strong>，才能去连接和管理那个 <strong>USB CDC 设备</strong>，进而解析它发送的模拟串口数据。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="从机端"><a href="#从机端" class="headerlink" title="从机端"></a>从机端</h2><p>…</p><h2 id="主机端"><a href="#主机端" class="headerlink" title="主机端"></a>主机端</h2><p><a href="https://github.com/espressif/esp-idf/tree/5b11d5b26a8bf151fc6bac400158859eedd413bc/examples/peripherals/usb/host/cdc/cdc_acm_vcp/main">例程</a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>device接电脑端可以正常识别到，接host端识别不到</p><p>已经排除：</p><ul><li><p><input checked="" disabled="" type="checkbox"> 供电问题，host与device分别供电</p></li><li><p><input checked="" disabled="" type="checkbox"> 数据线也多次更换过</p></li><li><p><input checked="" disabled="" type="checkbox"> 开发板，目前device使用的是自制的板子</p></li><li><p><input checked="" disabled="" type="checkbox"> ⚠️Gemini说可以单独供电，经过测试发现必须由主机供电才可以</p></li><li><p><input checked="" disabled="" type="checkbox"> 检查板子是否支持USB-OT</p></li><li><p><input disabled="" type="checkbox"> ESP32 USB OTG作为host时，必须要给从机供电才可以通信（<code>且必须是5V</code>, 根据 USB 2.0 规范，VBUS 的电压范围通常在 <strong>4.75V 到 5.25V</strong> 之间（即 5V±5%）。）</p><h6 id="ChatGPT-说："><a href="#ChatGPT-说：" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>是的。按照 USB 规范，任何主机（DFP）在与从设备（UFP）通信前，都必须在 VBUS（Type-C 上的 5 V 引脚）上提供电压信号，否则从设备既不会完成枚举，也不会响应任何数据传输请求。</p><ul><li><strong>VBUS 存在是枚举的前提</strong>：USB 设备在上电后会检测到 VBUS 的 5 V，然后才会上拉 D+（或 D–）以示“就绪”，主机检测到这一拉电阻后才会开始枚举流程。</li><li><strong>即便设备自供电，也需要 VBUS</strong>：自带电源的设备也必须让 VBUS 保持 5 V（即使不从中大电流获取能量），否则主机 USB 控制器会认为没有设备连接。</li><li><strong>Type-C 场景下</strong>，ESP32-S3 作为主机时，CC 引脚上的 Rp 上拉会告诉对端“我是主机”，然后 ESP32-S3 板上的电源开关芯片／电路必须给 VBUS 打开 5 V。</li></ul><p>如果你发现通过 Type-C 口接上从板却无法通信，请先用万用表量一下从机那端的 VBUS（Type-C 的 VBUS 脚）是否真的被拉到 5 V；若没有，则需在你的硬件设计中加一个 VBUS 电源开关或直接跳线给它供电，才能让 USB OTG Host 正常枚举并通信。</p></li></ul><h1 id="CH340"><a href="#CH340" class="headerlink" title="CH340"></a>CH340</h1><p>下面的是示例 <a href="https://github.com/espressif/esp-idf/tree/5b11d5b2/examples/peripherals/usb/host/cdc/cdc_acm_host">peripherals&#x2F;usb&#x2F;host&#x2F;cdc&#x2F;cdc_acm_host</a> 接CH340E的打印数据,接入后Host一直在重启</p><p>你遇到的问题是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">D (388) boot: Mapping segment 2 as IROMD (391) boot: calling set_cache_and_start_appD (395) boot: configure drom and irom and startD (400) boot: start: 0x403753d8--- 0x403753d8: call_start_cpu0 at C:&#x2F;Users&#x2F;VIBTEK&#x2F;esp&#x2F;V5.4.2&#x2F;components&#x2F;esp_system&#x2F;port&#x2F;cpu_start.c:387I (414) cpu_start: Multicore appI (423) cpu_start: Pro cpu start user codeI (423) cpu_start: cpu freq: 160000000 HzI (423) app_init: Application information:I (423) app_init: Project name:     cdc_acm_hostI (428) app_init: App version:      1I (431) app_init: Compile time:     Jul 11 2025 14:44:49I (436) app_init: ELF file SHA256:  6f037aee3...I (440) app_init: ESP-IDF:          v5.4.2I (444) efuse_init: Min chip rev:     v0.0I (448) efuse_init: Max chip rev:     v0.99 I (452) efuse_init: Chip rev:         v0.2I (456) heap_init: Initializing. RAM available for dynamic allocation:I (462) heap_init: At 3FC96180 len 00053590 (333 KiB): RAMI (467) heap_init: At 3FCE9710 len 00005724 (21 KiB): RAMI (472) heap_init: At 3FCF0000 len 00008000 (32 KiB): DRAMI (478) heap_init: At 600FE01C len 00001FCC (7 KiB): RTCRAMI (484) spi_flash: detected chip: mxicI (486) spi_flash: flash io: dioW (489) spi_flash: Detected size(16384k) larger than the size in the binary image header(2048k). Using the size in the binary image header.I (502) sleep_gpio: Configure to isolate all GPIO pins in sleep stateI (508) sleep_gpio: Enable automatic switching of GPIO sleep configurationI (515) main_task: Started on CPU0I (535) main_task: Calling app_main()I (535) USB-CDC: Installing USB HostI (565) USB-CDC: Installing CDC-ACM driverI (565) USB-CDC: Opening CDC ACM device 0x1A86:0x7523...*** Device descriptor ***bLength 18bDescriptorType 1bcdUSB 1.10bDeviceClass 0xffbDeviceSubClass 0x0bDeviceProtocol 0x0bMaxPacketSize0 8idVendor 0x1a86idProduct 0x7523bcdDevice 2.60iManufacturer 0iProduct 2iSerialNumber 0bNumConfigurations 1*** Configuration descriptor ***bLength 9bDescriptorType 2wTotalLength 39bNumInterfaces 1bConfigurationValue 1iConfiguration 0bmAttributes 0x80bMaxPower 98mA        *** Interface descriptor ***        bLength 9        bDescriptorType 4        bInterfaceNumber 0        bAlternateSetting 0        bNumEndpoints 3        bInterfaceClass 0xff        bInterfaceSubClass 0x1        bInterfaceProtocol 0x2        iInterface 0                *** Endpoint descriptor ***                bLength 7                bDescriptorType 5                bEndpointAddress 0x82   EP 2 IN                bmAttributes 0x2        BULK                wMaxPacketSize 32                bInterval 0                *** Endpoint descriptor ***                bLength 7                bDescriptorType 5                bEndpointAddress 0x2    EP 2 OUT                bmAttributes 0x2        BULK                wMaxPacketSize 32                bInterval 0                *** Endpoint descriptor ***                bLength 7                bDescriptorType 5                bEndpointAddress 0x81   EP 1 IN                bmAttributes 0x3        INT                wMaxPacketSize 8                bInterval 1I (1245) USB-CDC: Setting up line codingE (1245) cdc_acm_ops: cdc_acm_host_line_coding_get(25): line_coding_get function not supported<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="🧠-问题分析"><a href="#🧠-问题分析" class="headerlink" title="🧠 问题分析"></a>🧠 问题分析</h2><p>结合日志和代码行为，说明 <strong>ESP32-S3 成功检测到 USB 设备连接（即CH340E），但无法打开该设备进行 CDC 通信</strong>。这通常意味着：</p><ol><li><strong>设备成功枚举，但不符合 cdc_acm_host_open() 期望的 USB 接口特征（class&#x2F;subclass&#x2F;protocol）</strong></li><li><strong>CH340E 不遵循标准 CDC ACM 类定义（它是厂商自定义类 Class 0xFF）</strong></li><li><strong>ESP-IDF 的 cdc_acm_host 驱动默认只能处理标准 CDC ACM 设备</strong></li><li><strong>不是驱动无法识别 VID&#x2F;PID，而是设备枚举后其接口描述符不符合驱动期望</strong></li></ol><hr><h2 id="🔬-CH340-与-CDC-ACM-的区别"><a href="#🔬-CH340-与-CDC-ACM-的区别" class="headerlink" title="🔬  CH340 与 CDC ACM 的区别"></a>🔬  CH340 与 CDC ACM 的区别</h2><table><thead><tr><th>特性</th><th>CH340E</th><th>标准 CDC ACM 设备</th></tr></thead><tbody><tr><td>USB Class</td><td>0xFF (Vendor Specific Class)</td><td>0x02 (Communications Device Class)</td></tr><tr><td>Subclass</td><td>Varies</td><td>0x02 (Abstract Control Model)</td></tr><tr><td>驱动兼容性</td><td>Windows&#x2F;Linux 有专用驱动</td><td>使用标准 CDC 驱动</td></tr><tr><td>ESP-IDF 支持</td><td>❌（默认不支持 CH340 特有协议）</td><td>✅（ESP-IDF <code>cdc_acm_host</code> 支持）</td></tr></tbody></table><p>所以虽然你指定了正确的 VID&#x2F;PID（0x1A86:0x7523），但 <code>cdc_acm_host_open()</code> 会查验 USB 接口的 Class&#x2F;SubClass&#x2F;Protocol 并拒绝非标准 CDC 设备 —— <strong>CH340 就是这种情况</strong>。</p><p>这些芯片都严格遵循 CDC-ACM 规范，可以直接被 ESP32-S3 的 <code>cdc_acm_host</code> 驱动识别。</p><hr><h2 id="🚨-总结"><a href="#🚨-总结" class="headerlink" title="🚨 总结"></a>🚨 总结</h2><p>你当前例程无法通信的原因非常明确：</p><blockquote><p>❌ CH340E 并不符合标准 CDC ACM 类，ESP32-S3 的 CDC Host 驱动无法识别它，即使 VID&#x2F;PID 正确。</p></blockquote><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>讨论<strong>电流负载</strong>时，我们指的是 <strong>在该特定电压下，所有连接到该电压轨道的设备总共会消耗多少电流</strong>。s</p>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10修改右键菜单</title>
      <link href="/2025/07/09/176-win10-xiu-gai-you-jian-cai-dan/"/>
      <url>/2025/07/09/176-win10-xiu-gai-you-jian-cai-dan/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>每次使用vscode打开esp-idf时都得拖动文件夹到vscode图标，于是想直接将用vscode打开项目加入到鼠标右键菜单中。需要修改注册表</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h1 id="右键打开文件"><a href="#右键打开文件" class="headerlink" title="右键打开文件"></a>右键打开文件</h1><p>首先<code>win+r</code>输入<code>regedit</code>,然后找到<code>HKEY_CLASSES_ROOT\*\shell</code></p><p> 在shell下新建“<code>VisualCode</code>”项，在右侧窗口的“<strong>默认</strong>”双击，在数据里输入“<code>用VSCode打开</code>”。这是右键上显示的文字，可以随便写，只是为了方便查看</p><p>然后新建<code>可扩充字符串值</code>，命名为<code>Icon</code>，双击，把<code>&quot;D:\anzhuang\Microsoft VS Code\Code.exe&quot;</code>放进数据就可以了。</p><p>然后新建项<code>Command</code>,输入值为<code>&quot;D:\anzhuang\Microsoft VS Code\Code.exe&quot; &quot;%1&quot;</code>。<strong>其中的%1表示要打开的文件参数</strong>。⚠️注意文件路径到.exe</p><h2 id="右键打开文件夹"><a href="#右键打开文件夹" class="headerlink" title="右键打开文件夹"></a>右键打开文件夹</h2><p>找到<code>HKEY_CLASSES_ROOT\Directory\shell</code>分支，其他步骤相同</p><h2 id="右键空白处"><a href="#右键空白处" class="headerlink" title="右键空白处"></a>右键空白处</h2><p>右键文件夹空白处，打开文件夹</p><p>找到<code>HKEY_CLASSES_ROOT\Directory\Background\shell\</code>分支</p><p>只需要将把 <code>%1</code> 改为<code>%V</code>，例如：<code>&quot;D:\anzhuang\Microsoft VS Code\Code.exe&quot; &quot;%V&quot;</code></p><p>其他不变</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://zhuanlan.zhihu.com/p/428704111">(3 封私信 &#x2F; 14 条消息) 右键菜单加入用VSCode打开文件和文件夹 - 知乎</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TP4056充放电芯片</title>
      <link href="/2025/07/08/175-tp4056-chong-fang-dian-xin-pian/"/>
      <url>/2025/07/08/175-tp4056-chong-fang-dian-xin-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p><a href="https://item.szlcsc.com/datasheet/TP4056/354934.html?spm=sc.it.pdf.fd___sc.gbn.xh1.zy.n&lcsc_vid=RlBeUQcHT1ELVlZSE1FXU1AEFlBeUgdSTgUMUVZfRFExVlNTRlhbUVZUT1lZVDtW">TP4056 -PDF数据手册-参考资料-立创商城</a></p><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>STDBY：充满</p><p>CHRG：充电</p><h1 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h1><img src="/2025/07/08/175-tp4056-chong-fang-dian-xin-pian/1752644791267.png" class="" width="1752644791267">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-S3驱动WS2812_RGB灯</title>
      <link href="/2025/07/08/174-esp32-s3-qu-dong-ws2812-rgb-deng/"/>
      <url>/2025/07/08/174-esp32-s3-qu-dong-ws2812-rgb-deng/</url>
      
        <content type="html"><![CDATA[<h1 id="RGB-驱动原理"><a href="#RGB-驱动原理" class="headerlink" title="RGB 驱动原理"></a>RGB 驱动原理</h1><p>XL-5050RGBC-WS2812B是一种集成了WS2812B控制芯片的RGB LED，这意味着它是一个<strong>可寻址的LED</strong>。与普通RGB LED需要外部电流控制芯片（如移位寄存器或PWM驱动器）不同，WS2812B内部已经包含了这些控制逻辑。</p><h1 id="WS2812B"><a href="#WS2812B" class="headerlink" title="WS2812B"></a>WS2812B</h1><p>WS2812B的工作原理是单行线通信，通过Din接收数据，解码后控制该LED亮灭，然后通过Dout传递给下一个LED的DIN实现级联。</p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p><a href="https://item.szlcsc.com/datasheet/WS2812B-2020/1051115.html?spm=sc.gbn.xds.a___sc.hm.hd.ss&lcsc_vid=R1BfVFQCFVALVlJURFQLAwUFQFVfUwFRQAcIV1wDFQUxVlNTRVlfXlBXRVNbVDtW">WS2812B-2020 -PDF数据手册-参考资料-立创商城</a></p><h1 id="RMT驱动"><a href="#RMT驱动" class="headerlink" title="RMT驱动"></a>RMT驱动</h1><p>RMT是<strong>一个为了处理复杂时序协议而设计的高度集成、高效率的“脉冲序列收发器”</strong>，它<strong>内置了类似于 DMA 的数据传输机制</strong>来驱动其<strong>精密的脉冲生成单元</strong>。这使得它在处理像 WS2812B 这种需要微秒级精确时序的设备时，比传统的 DMA+定时器组合更加方便和高效。</p><h1 id="驱动demo"><a href="#驱动demo" class="headerlink" title="驱动demo"></a>驱动demo</h1><h1 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h1><p><a href="https://components.espressif.com/components?q=usb_host+">Search • ESP Component Registry</a></p><p><a href="https://blog.csdn.net/u012121390/article/details/139135372">ESP-IDF使用LED组件实现各种LED效果控制_esp-idf led-CSDN博客</a></p><p><a href="https://embeddedexplorer.com/controlling-rgb-leds-using-esp32-component-esp-idf/">Controlling RGB LEDs using ESP32 Component (ESP-IDF)</a></p>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP_IDF_OTA</title>
      <link href="/2025/07/03/173-esp-idf-ota/"/>
      <url>/2025/07/03/173-esp-idf-ota/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>ESP-IDF</li><li><a href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/system/ota">esp-idf&#x2F;examples&#x2F;system&#x2F;ota at v5.4.2 · espressif&#x2F;esp-idf</a></li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>使用<code>simple_ota_example</code>例程，<strong>带证书</strong></p><p>然后需要设置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">idf.py menuconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><p>在<code>sdkconfig</code>中修改<code>wifi</code>与<code>otaurl</code></p><pre class="line-numbers language-none"><code class="language-none">CONFIG_EXAMPLE_PROVIDE_WIFI_CONSOLE_CMD&#x3D;yCONFIG_EXAMPLE_WIFI_SSID&#x3D;&quot;VIBTEK-2.4G&quot;CONFIG_EXAMPLE_WIFI_PASSWORD&#x3D;&quot;vibrantech@1305-1&quot;CONFIG_EXAMPLE_WIFI_CONN_MAX_RETRY&#x3D;6# CONFIG_EXAMPLE_WIFI_SCAN_METHOD_FAST is not setCONFIG_EXAMPLE_WIFI_SCAN_METHOD_ALL_CHANNEL&#x3D;y## Example Configuration#CONFIG_EXAMPLE_FIRMWARE_UPGRADE_URL&#x3D;&quot;http:&#x2F;&#x2F;192.168.71.92:8070&#x2F;Ble_WIFI_Sniff.bin&quot;CONFIG_EXAMPLE_USE_CERT_BUNDLE&#x3D;y# CONFIG_EXAMPLE_SKIP_COMMON_NAME_CHECK is not set# CONFIG_EXAMPLE_FIRMWARE_UPGRADE_BIND_IF is not set# end of Example Configuration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li></li></ol><pre class="line-numbers language-none"><code class="language-none">W (370) spi_flash: Detected size(16384k) larger than the size in the binary image header(4096k). Using the size in the binary image header.I (383) sleep_gpio: Configure to isolate all GPIO pins in sleep stateI (389) sleep_gpio: Enable automatic switching of GPIO sleep configurationI (396) main_task: Started on CPU0I (416) main_task: Calling app_main()I (416) simple_ota_example: OTA example app_main startI (426) simple_ota_example: SHA-256 for bootloader:  f1b11e5ba4d1158e2ac22cac2f4f6568ffaeb690986a2ffcfc2a90585f89ba83I (506) simple_ota_example: SHA-256 for current firmware:  e1dbfe46dbbb4c4ba8e809a818c0c7157246c6aa65e1e8287c2b57c05d7cea40I (506) example_connect: Start example_connect.I (506) pp: pp rom version: e7ae62fI (516) net80211: net80211 rom version: e7ae62fI (526) wifi:wifi driver task: 3fcac520, prio:23, stack:6656, core&#x3D;0I (526) wifi:wifi firmware version: 48ea317a7I (526) wifi:wifi certification version: v7.0I (526) wifi:config NVS flash: enabledI (536) wifi:config nano formatting: disabledI (536) wifi:Init data frame dynamic rx buffer num: 32I (546) wifi:Init static rx mgmt buffer num: 5I (546) wifi:Init management short buffer num: 32I (556) wifi:Init dynamic tx buffer num: 32I (556) wifi:Init static tx FG buffer num: 2I (556) wifi:Init static rx buffer size: 1600I (566) wifi:Init static rx buffer num: 10I (566) wifi:Init dynamic rx buffer num: 32I (576) wifi_init: rx ba win: 6I (576) wifi_init: accept mbox: 6I (576) wifi_init: tcpip mbox: 32I (576) wifi_init: udp mbox: 6I (586) wifi_init: tcp mbox: 6I (586) wifi_init: tcp tx win: 5760I (586) wifi_init: tcp rx win: 5760I (596) wifi_init: tcp mss: 1440I (596) wifi_init: WiFi IRAM OP enabledI (596) wifi_init: WiFi RX IRAM OP enabledI (606) phy_init: phy_version 680,a6008b2,Jun  4 2024,16:41:10I (646) wifi:mode : sta (d8:3b:da:70:62:00)I (646) wifi:enable tsfI (646) example_connect: Connecting to VIBTEK-2.4G...W (646) wifi:Password length matches WPA2 standards, authmode threshold changes from OPEN to WPA2I (656) example_connect: Waiting for IP(s)I (3506) wifi:new:&lt;1,0&gt;, old:&lt;1,0&gt;, ap:&lt;255,255&gt;, sta:&lt;1,0&gt;, prof:1, snd_ch_cfg:0x0I (3506) wifi:state: init -&gt; auth (0xb0)I (3506) wifi:state: auth -&gt; assoc (0x0)I (3516) wifi:state: assoc -&gt; run (0x10)I (3646) wifi:connected with VIBTEK-2.4G, aid &#x3D; 17, channel 1, BW20, bssid &#x3D; 58:ea:1f:9a:8b:92I (3646) wifi:security: WPA2-PSK, phy: bgn, rssi: -39I (3656) wifi:pm start, type: 1I (3656) wifi:dp: 1, bi: 102400, li: 3, scale listen interval from 307200 us to 307200 usI (3666) wifi:set rx beacon pti, rx_bcn_pti: 0, bcn_timeout: 25000, mt_pti: 0, mt_time: 10000        I (3696) wifi:&lt;ba-add&gt;idx:0 (ifx:0, 58:ea:1f:9a:8b:92), tid:6, ssn:2, winSize:64I (3696) wifi:&lt;ba-add&gt;idx:1 (ifx:0, 58:ea:1f:9a:8b:92), tid:0, ssn:0, winSize:64I (3746) wifi:AP&#39;s beacon interval &#x3D; 102400 us, DTIM period &#x3D; 1I (4696) esp_netif_handlers: example_netif_sta ip: 192.168.71.29, mask: 255.255.255.0, gw: 192.168.71.1I (4696) example_connect: Got IPv4 event: Interface &quot;example_netif_sta&quot; address: 192.168.71.29       I (5506) example_connect: Got IPv6 event: Interface &quot;example_netif_sta&quot; address: fe80:0000:0000:0000:da3b:daff:fe70:6200, type: ESP_IP6_ADDR_IS_LINK_LOCALI (5506) example_common: Connected to example_netif_staI (5506) example_common: - IPv4 address: 192.168.71.29,I (5516) example_common: - IPv6 address: fe80:0000:0000:0000:da3b:daff:fe70:6200, type: ESP_IP6_ADDR_IS_LINK_LOCALI (5526) wifi:Set ps type: 0, coexist: 0I (5526) simple_ota_example: Starting OTA example taskI (5536) simple_ota_example: Attempting to download update from http:&#x2F;&#x2F;192.168.71.92:8070&#x2F;hello_world.binI (5546) main_task: Returned from app_main()I (5616) esp_https_ota: Starting OTA...I (5616) esp_https_ota: Writing to &lt;ota_1&gt; partition at offset 0x1d0000I (10286) esp_image: segment 0: paddr&#x3D;001d0020 vaddr&#x3D;3c030020 size&#x3D;0d6bch ( 54972) mapI (10296) esp_image: segment 1: paddr&#x3D;001dd6e4 vaddr&#x3D;3fc91a40 size&#x3D;02934h ( 10548) I (10296) esp_image: segment 2: paddr&#x3D;001e0020 vaddr&#x3D;42000020 size&#x3D;28c4ch (166988) mapI (10316) esp_image: segment 3: paddr&#x3D;00208c74 vaddr&#x3D;3fc94374 size&#x3D;00cfch (  3324) I (10316) esp_image: segment 4: paddr&#x3D;00209978 vaddr&#x3D;40374000 size&#x3D;0da40h ( 55872) I (10336) esp_image: segment 0: paddr&#x3D;001d0020 vaddr&#x3D;3c030020 size&#x3D;0d6bch ( 54972) mapI (10346) esp_image: segment 1: paddr&#x3D;001dd6e4 vaddr&#x3D;3fc91a40 size&#x3D;02934h ( 10548) I (10346) esp_image: segment 2: paddr&#x3D;001e0020 vaddr&#x3D;42000020 size&#x3D;28c4ch (166988) mapI (10366) esp_image: segment 3: paddr&#x3D;00208c74 vaddr&#x3D;3fc94374 size&#x3D;00cfch (  3324) I (10366) esp_image: segment 4: paddr&#x3D;00209978 vaddr&#x3D;40374000 size&#x3D;0da40h ( 55872) I (10426) simple_ota_example: OTA Succeed, Rebooting...I (10426) wifi:state: run -&gt; init (0x0)I (10426) wifi:pm stop, total sleep time: 1349954 us &#x2F; 6768897 usI (10426) wifi:&lt;ba-del&gt;idx:1, tid:0I (10426) wifi:&lt;ba-del&gt;idx:0, tid:6I (10436) wifi:new:&lt;1,0&gt;, old:&lt;1,0&gt;, ap:&lt;255,255&gt;, sta:&lt;1,0&gt;, prof:1, snd_ch_cfg:0x0I (10486) wifi:flush txqI (10486) wifi:stop sw txqI (10486) wifi:lmac stop hw txqI (10486) wifi:Deinit lldesc rx mblock:10xESP-ROM:esp32s3-20210327Build:Mar 27 2021rst:0xc (RTC_SW_CPU_RST),boot:0x8 (SPI_FAST_FLASH_BOOT)Saved PC:0x40375b3c--- 0x40375b3c: esp_restart_noos at C:&#x2F;Users&#x2F;VIBTEK&#x2F;esp&#x2F;v5.4&#x2F;esp-idf&#x2F;components&#x2F;esp_system&#x2F;port&#x2F;soc&#x2F;esp32s3&#x2F;system_internal.c:160SPIWP:0xeemode:DIO, clock div:1load:0x3fce2810,len:0x15a0load:0x403c8700,len:0x4load:0x403c8704,len:0xd20load:0x403cb700,len:0x2ee4entry 0x403c8928I (31) boot: ESP-IDF v5.4 2nd stage bootloaderI (31) boot: compile time Jul  3 2025 15:12:48I (31) boot: Multicore bootloaderI (31) boot: chip revision: v0.2I (34) boot: efuse block revision: v1.3I (38) boot.esp32s3: Boot SPI Speed : 80MHzI (42) boot.esp32s3: SPI Mode       : DIOI (45) boot.esp32s3: SPI Flash Size : 4MBI (49) boot: Enabling RNG early entropy source...I (54) boot: Partition Table:I (56) boot: ## Label            Usage          Type ST Offset   LengthI (62) boot:  0 nvs              WiFi data        01 02 00009000 00006000I (69) boot:  1 otadata          OTA data         01 00 0000f000 00002000I (75) boot:  2 phy_init         RF data          01 01 00011000 00001000I (82) boot:  3 ota_0            OTA app          00 10 00020000 001a9000I (88) boot:  4 ota_1            OTA app          00 11 001d0000 001a9000I (95) boot: End of partition tableI (98) esp_image: segment 0: paddr&#x3D;001d0020 vaddr&#x3D;3c030020 size&#x3D;0d6bch ( 54972) mapI (115) esp_image: segment 1: paddr&#x3D;001dd6e4 vaddr&#x3D;3fc91a40 size&#x3D;02934h ( 10548) loadI (118) esp_image: segment 2: paddr&#x3D;001e0020 vaddr&#x3D;42000020 size&#x3D;28c4ch (166988) mapI (150) esp_image: segment 3: paddr&#x3D;00208c74 vaddr&#x3D;3fc94374 size&#x3D;00cfch (  3324) loadI (151) esp_image: segment 4: paddr&#x3D;00209978 vaddr&#x3D;40374000 size&#x3D;0da40h ( 55872) loadI (172) boot: Loaded app from partition at offset 0x1d0000I (172) boot: Disabling RNG early entropy source...E (1077) esp_core_dump_flash: No core dump partition found!E (1077) esp_core_dump_flash: No core dump partition found!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决：</p><blockquote><p>可能是由于固件是arduino编译的,并且需要古剑名字要与项目名字一致</p></blockquote><p>⚠️：出现烧录与ota更新现象不同的情况，先将固件升级到最新</p><p>2.一直更新</p><blockquote><p>代码被配置为在每次启动时都尝试执行 OTA 更新，并且由于您的 OTA 服务器始终提供“相同版本”的固件，导致设备陷入了一个无限更新循环。</p></blockquote><p>版本管理</p>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> ESP-IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USB TO TTL模块DIY</title>
      <link href="/2025/06/24/172-usb-to-ttl-mo-kuai-diy/"/>
      <url>/2025/06/24/172-usb-to-ttl-mo-kuai-diy/</url>
      
        <content type="html"><![CDATA[<h1 id="V1-0"><a href="#V1-0" class="headerlink" title="V1.0"></a>V1.0</h1><p>很久以前做了一块Type-c接口的，最近打算更新一下</p><h1 id="V2-0"><a href="#V2-0" class="headerlink" title="V2.0"></a>V2.0</h1><h2 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h2><ul><li><a href="https://item.szlcsc.com/100866.html?fromZone=s_s__%22ch340%22&spm=sc.gbn.xh3.zy.n&lcsc_vid=R1BfVFQCFVALVlJURFQLAwUFQFVfUwFRQAcIV1wDFQUxVlNTR1ZdV1FeQlNdXzsOAxUeFF5JWBYZEEoVDQ0NFAdIFA4DSA==">CH340E</a>（封装小）</li><li><a href="https://item.szlcsc.com/datasheet/CH340E/100866.html?spm=sc.it.pdf.fd___sc.gbn.xh3.zy.n&lcsc_vid=R1BfVFQCFVALVlJURFQLAwUFQFVfUwFRQAcIV1wDFQUxVlNTR1ZdV1FeQlNdXzsOAxUeFF5JWBYZEEoVDQ0NFAdIFA4DSA==">CH340E -PDF数据手册</a></li></ul><h2 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h2><p><strong>我不理解的地方是，通信双方引脚默认都是3.3v高电平</strong></p><p><strong>ChatGPT 说：</strong></p><p>您完全正确地指出了一个看似矛盾的地方：<strong>如果两边在空闲时都是3.3V，那低电平信号是如何产生的？谁听谁的？</strong></p><p>答案是：<strong>虽然它们都是高电平，但一个是“强”的，一个是“弱”的，“强”的可以轻松压倒“弱”的。</strong></p><p>我们来拆解一下通信双方引脚的真实身份：</p><hr><h3 id="1-发送端-TX-“强壮的司令官”-推挽输出-Push-Pull"><a href="#1-发送端-TX-“强壮的司令官”-推挽输出-Push-Pull" class="headerlink" title="1. 发送端 (TX): “强壮的司令官” - 推挽输出 (Push-Pull)"></a>1. 发送端 (TX): “强壮的司令官” - 推挽输出 (Push-Pull)</h3><ul><li><strong>它的高电平是“强驱动高电平” (Strong Drive High)。</strong></li><li>在芯片内部，TX引脚通过一个**低电阻的开关（晶体管）**直接连接到电源（VCC&#x2F;3.3V）。</li><li>当它要发送’1’（高电平）时，它会<strong>主动地、强力地</strong>将线路电压“推”到3.3V。它能提供不小的电流来维持这个电压。</li><li>当它要发送’0’（低电平）时，它会切换内部开关，<strong>主动地、强力地</strong>将线路电压“拉”到地（GND&#x2F;0V）。它能“吸收”电流来维持这个0V。</li></ul><h3 id="2-接收端-RX-“文静的观察员”-输入加内部上拉-Input-with-Pull-up"><a href="#2-接收端-RX-“文静的观察员”-输入加内部上拉-Input-with-Pull-up" class="headerlink" title="2. 接收端 (RX): “文静的观察员” - 输入加内部上拉 (Input with Pull-up)"></a>2. 接收端 (RX): “文静的观察员” - 输入加内部上拉 (Input with Pull-up)</h3><ul><li><strong>它的高电平是“弱上拉高电平” (Weak Pull-up High)。</strong></li><li>RX引脚的本职工作是**“只看不做”**，即检测外部电压是高还是低，它自己不应该主动输出电压。</li><li>但如果一个输入引脚什么都不接，它的电平会像风中的羽毛一样飘忽不定（称为“浮空”），这会引起电路误判。</li><li>为了解决这个问题，工程师在RX引脚内部连接了一个<strong>高阻值的电阻（通常是10kΩ~50kΩ）到电源（VCC&#x2F;3.3V）。这个电阻就是“上拉电阻”</strong>。</li><li>这个电阻会<strong>微弱地</strong>、<strong>懒洋洋地</strong>把引脚的电压“拉”到3.3V，确保在没有信号输入时，它能稳定地处于高电平状态。</li></ul><p><strong>把它想象成一根很细的橡皮筋，轻轻地把门拉着，让它保持在打开的状态（3.3V）。</strong></p><p>所以，您理解的“双方默认都是3.3V”是现象，而其背后的**“强驱动”与“弱上拉”**的本质区别，才是实现可靠通信的根本原因。发送端的“强”信号可以完全覆盖和决定线路的状态，而接收端的“弱”上拉只在发送端“撒手不管”（发送高电平或空闲）时才起作用。</p><h1 id="防反灌电路"><a href="#防反灌电路" class="headerlink" title="防反灌电路"></a>防反灌电路</h1><img src="/2025/06/24/172-usb-to-ttl-mo-kuai-diy/1750744039153.png" class="" width="1750744039153"><img src="/2025/06/24/172-usb-to-ttl-mo-kuai-diy/1750744035419.png" class="" width="1750744035419"><blockquote><p>这个二极管不可以反接,否则会失去保护与通信的功能</p></blockquote><p><strong>双向防反灌电路</strong>(未验证)</p><img src="/2025/06/24/172-usb-to-ttl-mo-kuai-diy/1750748437148.png" class="" width="1750748437148"><p>有点麻烦,所以我选择单向的</p><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><img src="/2025/06/24/172-usb-to-ttl-mo-kuai-diy/1750841161279.png" class="" width="1750841161279">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>驱动LED点阵屏</title>
      <link href="/2025/06/22/171-qu-dong-led-dian-zhen-ping/"/>
      <url>/2025/06/22/171-qu-dong-led-dian-zhen-ping/</url>
      
        <content type="html"><![CDATA[<h2 id="8-8点阵屏"><a href="#8-8点阵屏" class="headerlink" title="8*8点阵屏"></a>8*8点阵屏</h2><h1 id="驱动远离"><a href="#驱动远离" class="headerlink" title="驱动远离"></a>驱动远离</h1><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h1 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Proteus仿真入门</title>
      <link href="/2025/06/21/170-proteus-fang-zhen-ru-men/"/>
      <url>/2025/06/21/170-proteus-fang-zhen-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="放置元器件"><a href="#放置元器件" class="headerlink" title="放置元器件"></a>放置元器件</h1><blockquote><p>常用元器件对应缩写<br>1.电阻：RES<br>2.电容：CAP（极性电容： CAP-ELEC）<br>3.晶振：CRYSTAL<br>4.按键： BUTTON<br>5.开关：SWITCH<br>6.排阻：RESPACK<br>7.发光二极管(LED)：LED-BIBY<br>8.二极管： DIODE<br>9.三极管：PNP&#x2F;NPN<br>10.蜂鸣器：BUZZER（active为有源蜂鸣器）<br>11.超声波传感器：HCSR04<br>12.直流电机：MOTOR-DC<br>13.单片机：AT89C51&#x2F;AT89C52&#x2F;STM32XX<br>14.LCD1602：LM016L<br>15.OLED屏：OLED12864I2C<br>16.滑动变阻器：POT（-HG为1%精度，-LIN&#x2F;-LOG精度为10%）<br>17.继电器：RELAY</p><p>18.点阵屏:MATRIX-8X8-RED</p><p>19.双向8排阻：RX8</p><p>20.单向排阻：respack-8</p></blockquote><h2 id="点阵屏引脚分布"><a href="#点阵屏引脚分布" class="headerlink" title="点阵屏引脚分布"></a>点阵屏引脚分布</h2><p><a href="https://blog.csdn.net/weixin_43808473/article/details/106571339">Proteus仿真8×8点阵使用示例_proteus中8×8led点阵引脚分正负极?-CSDN博客</a></p><p>但是引脚与普中开发版引脚对不上,所以我选择仿真和实物使用两个字模</p><h1 id="旋转快捷键"><a href="#旋转快捷键" class="headerlink" title="旋转快捷键"></a>旋转快捷键</h1><p><code>system-&gt;set keyboard map-&gt;Schematic Window Miscellaneous Commands-&gt;rotate clockwise</code></p><img src="/2025/06/21/170-proteus-fang-zhen-ru-men/image-20250621104304688.png" class="" title="image-20250621104304688"><h1 id="水平等距"><a href="#水平等距" class="headerlink" title="水平等距"></a>水平等距</h1><p>目前好像没有这个功能,手动把    </p><h1 id="复制粘贴快捷键"><a href="#复制粘贴快捷键" class="headerlink" title="复制粘贴快捷键"></a>复制粘贴快捷键</h1><img src="/2025/06/21/170-proteus-fang-zhen-ru-men/image-20250622090118435.png" class="" title="image-20250622090118435"><h1 id="对齐快捷键"><a href="#对齐快捷键" class="headerlink" title="对齐快捷键"></a>对齐快捷键</h1><p>ctrl+A</p><h1 id="选线快捷键"><a href="#选线快捷键" class="headerlink" title="选线快捷键"></a>选线快捷键</h1><h1 id="网络标签"><a href="#网络标签" class="headerlink" title="网络标签"></a>网络标签</h1><p>按下a键可批量添加标签名称,然后依次点击标签引脚即可</p><p><code>NET=P#</code></p><p>结束需要再按一下<code>A</code>,点击取消</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/weixin_46510976/article/details/127950291">Proteus仿真实验—-8*8点阵(点扫描实验）_proteus点阵8×8-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于stm32的班级投票系统</title>
      <link href="/2025/06/21/169-ji-yu-stm32-de-duo-ren-tou-piao-xi-tong/"/>
      <url>/2025/06/21/169-ji-yu-stm32-de-duo-ren-tou-piao-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵键盘驱动"><a href="#矩阵键盘驱动" class="headerlink" title="矩阵键盘驱动"></a>矩阵键盘驱动</h1><h1 id="按键映射"><a href="#按键映射" class="headerlink" title="按键映射"></a>按键映射</h1><h1 id="按键重复限制"><a href="#按键重复限制" class="headerlink" title="按键重复限制"></a>按键重复限制</h1><h1 id="定时器配置"><a href="#定时器配置" class="headerlink" title="定时器配置"></a>定时器配置</h1><h1 id="机械周期"><a href="#机械周期" class="headerlink" title="机械周期"></a>机械周期</h1><h1 id="oled显示"><a href="#oled显示" class="headerlink" title="oled显示"></a>oled显示</h1><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="频闪"><a href="#频闪" class="headerlink" title="频闪"></a>频闪</h2><p>换成空格局部覆盖</p><h2 id="键盘最后一个按键失效"><a href="#键盘最后一个按键失效" class="headerlink" title="键盘最后一个按键失效"></a>键盘最后一个按键失效</h2><p>位操作编码问题</p><blockquote><p>具体来说：</p><ol><li>当第16键被按下时，<code>temp_key = 16</code></li><li>在返回值计算中：<code>(temp_key &amp; 0x0F)</code> &#x3D; <code>(16 &amp; 15)</code> &#x3D; <code>0</code></li><li>所以第16键的键值被错误编码为0</li><li>在处理时，<code>key_value = 0</code>，导致 <code>original_key = 0</code>，<code>key_index = -1</code>（变成255）</li></ol><p><strong>解决方法</strong>：将键值编码从1-16改为0-15，然后在处理时再加1还原。这样16个键都能在4位内正确表示。</p><p>你需要修改两个函数：</p><ol><li><code>Keypad1_GetPressType()</code> - 修改返回值编码</li><li><code>Process_Vote_Keypad1()</code> - 修改键值解码</li></ol><p>这是一个典型的”off-by-one”错误，因为4位最大只能表示0-15，而你的键值是1-16。</p></blockquote><p>越界</p><h2 id="多矩阵键盘，不同键盘同一位置按键只能一个有效"><a href="#多矩阵键盘，不同键盘同一位置按键只能一个有效" class="headerlink" title="多矩阵键盘，不同键盘同一位置按键只能一个有效"></a>多矩阵键盘，不同键盘同一位置按键只能一个有效</h2><h2 id="长按失效"><a href="#长按失效" class="headerlink" title="长按失效"></a>长按失效</h2><p>机器周期的问题</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux环境下编译</title>
      <link href="/2025/06/16/168-linux-huan-jing-xia-bian-yi/"/>
      <url>/2025/06/16/168-linux-huan-jing-xia-bian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>unbuntu 22.04</li><li>gcc</li><li>make</li></ul><h1 id="配置使用主机代理"><a href="#配置使用主机代理" class="headerlink" title="配置使用主机代理"></a>配置使用主机代理</h1><h2 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h2><p>主机<code>ipconfig</code>查看 <code>VMware Network Adapter VMnet8</code>对应ip</p><p>v2ray在设置-&gt;参数设置-&gt;允许局域网的连接</p><img src="/2025/06/16/168-linux-huan-jing-xia-bian-yi/1750128429093.png" class="" width="1750128429093"><h2 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h2><p>然后在虚拟机里配置主机的ip与局域网端口</p><img src="/2025/06/16/168-linux-huan-jing-xia-bian-yi/1750128388524.png" class="" width="1750128388524"><p><strong>测试</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ping 192.168.208.1curl -x http:&#x2F;&#x2F;192.168.208.1:10808 http:&#x2F;&#x2F;www.google.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一把这个时候<code>curl</code>可以成功,ping如果不通关闭防火墙试一下</p><h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><p>由于 Ubuntu 24.04 LTS 的新版「应用中心」不再支持 DEB 安装包，我们需要先安装 GDebi 工具来解决 DEB 的安装问题。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt install gdebi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载好.deb格式的安装包后,右键<code>GDebi 软件包安装程序</code>打开</p><h1 id="浏览器配置代理"><a href="#浏览器配置代理" class="headerlink" title="浏览器配置代理"></a>浏览器配置代理</h1><h2 id="Edge"><a href="#Edge" class="headerlink" title="Edge"></a>Edge</h2><p>edge 走得是系统代理，直接设系统代理就行。如果你想单独给 edge 设置代理要装插件实现</p><h2 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h2><p>浏览器设置界面最下面<code>Network Settings</code></p><img src="/2025/06/16/168-linux-huan-jing-xia-bian-yi/1750127450490.png" class="" width="1750127450490"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="无法上网"><a href="#无法上网" class="headerlink" title="无法上网"></a>无法上网</h2><p><strong>NetworkManager 的全局网络状态被禁用了</strong></p><p><code>/var/lib/NetworkManager/NetworkManager.state</code> </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[main]NetworkingEnabled&#x3D;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Error: Connection activation failed: No suitable device found for this connection (device lo not available because device is strictly unmanaged).manager: Networking is disabled by state file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>解决方法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nmcli networking onnmcli connection up ens33-connnmcli device status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="无法使用主机代理"><a href="#无法使用主机代理" class="headerlink" title="无法使用主机代理"></a>无法使用主机代理</h2><p>1.<strong>公共网络的防火墙需要关闭</strong></p><p>检查 v2ray 是否监听 0.0.0.0（支持局域网访问）</p><p>打开 v2rayN → 设置 → 代理端口 → 确保监听地址为：</p><pre class="line-numbers language-none"><code class="language-none">0.0.0.0:10808<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不要是 <code>127.0.0.1:10808</code>（仅限本机）</p><p>你也可以在主机上执行（CMD）：</p><pre class="line-numbers language-none"><code class="language-none">netstat -an | findstr 10808<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应该能看到：</p><pre class="line-numbers language-none"><code class="language-none">TCP    0.0.0.0:10808       LISTENING<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="添加规则放行-VMware-和-ping"><a href="#添加规则放行-VMware-和-ping" class="headerlink" title="添加规则放行 VMware 和 ping"></a>添加规则放行 VMware 和 ping</h3><p>如果你不希望关闭防火墙，可以用管理员 PowerShell 添加规则：</p><pre class="line-numbers language-none"><code class="language-none"># 放行 v2ray 端口New-NetFirewallRule -DisplayName &quot;Allow v2ray 10808&quot; -Direction Inbound -Protocol TCP -LocalPort 10808 -Action Allow -InterfaceAlias &quot;VMware Network Adapter VMnet8&quot;# 放行 ping（ICMPv4）New-NetFirewallRule -DisplayName &quot;Allow ICMPv4 ping from VM&quot; -Protocol ICMPv4 -IcmpType 8 -Direction Inbound -Action Allow -InterfaceAlias &quot;VMware Network Adapter VMnet8&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行完之后，<strong>重新测试 ping 和 curl</strong>。</p><p>2.<strong>在虚拟机中的本机ip段需要对应</strong></p><p><a href="https://blog.xzr.moe/archives/124/">参考文章</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>完整卸载nezha-agent</title>
      <link href="/2025/06/16/167-wan-zheng-xie-zai-nezha-agent/"/>
      <url>/2025/06/16/167-wan-zheng-xie-zai-nezha-agent/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于nezha面板的服务器后套删除后，一段时间内还会生成新的，甚至是出现两条。初步怀疑是因为同时安装多个面板造成的，比如当这一条数据还没有出现在面板上的时候，复制的安装命令可能还是同一个。</p><h1 id="杀进程卸载agent"><a href="#杀进程卸载agent" class="headerlink" title="杀进程卸载agent"></a>杀进程卸载agent</h1><h2 id="第一步：停止正在运行的-Agent-进程"><a href="#第一步：停止正在运行的-Agent-进程" class="headerlink" title="第一步：停止正在运行的 Agent 进程"></a><strong>第一步：停止正在运行的 Agent 进程</strong></h2><p>这是最关键的一步。Agent 可能以多种方式在后台运行，你需要根据当初的安装方式找到并停止它。请登录到<strong>正确的服务器</strong>（用面板上显示的IP地址登录），然后依次尝试以下方法：</p><p><strong>方法一：检查直接运行的进程 (最通用)</strong></p><p>这是查找任何残留进程的最终方法。</p><ol><li><p><strong>查找进程ID (PID):</strong></p><pre class="line-numbers language-none"><code class="language-none">ps aux | grep nezha-agent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>分析结果：</strong></p><ul><li><p>如果你看到<strong>两行</strong>结果，其中一行<strong>不包含 grep</strong>，那么你就找到了真正的 Agent 进程。记下它的 PID（通常是第二列的数字）。</p><pre class="line-numbers language-none"><code class="language-none"># 示例输出 (找到了!)root      1234  0.1  0.5 ... &#x2F;opt&#x2F;nezha&#x2F;agent&#x2F;nezha-agent -s ...root      5678  0.0  0.1 ... grep nezha-agent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>如果你只看到<strong>一行</strong>，且该行包含 <code>grep nezha-agent</code>，那么说明<strong>没有 Agent 进程在运行</strong>，你可以直接跳到第二步。</p></li></ul></li><li><p><strong>杀死进程 (如果找到了):</strong></p><pre class="line-numbers language-none"><code class="language-none"># 将 1234 替换为你找到的真实 PIDkill -9 1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p><strong>方法二：检查 systemd 服务 (如果用 systemctl 安装)</strong></p><p>这是在现代 Linux 系统上最标准的管理方式。</p><ol><li><p><strong>检查服务状态：</strong></p><pre class="line-numbers language-none"><code class="language-none">systemctl status nezha-agent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果显示 <code>active (running)</code>，说明服务正在运行。</p></li><li><p><strong>停止并禁用服务：</strong></p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl stop nezha-agent      # 停止当前运行的服务sudo systemctl disable nezha-agent   # 禁用服务，防止服务器重启后自动运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p><strong>方法三：检查 Docker 容器 (如果用 Docker 安装)</strong></p><ol><li><p><strong>查找 Agent 容器：</strong></p><pre class="line-numbers language-none"><code class="language-none">docker ps -a | grep nezha<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>停止并删除容器：</strong></p><pre class="line-numbers language-none"><code class="language-none"># 将 nezha-agent 替换为你找到的真实容器名或IDdocker stop nezha-agentdocker rm nezha-agent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你是用 <code>docker-compose</code>，请到 <code>docker-compose.yml</code> 文件所在目录执行 <code>docker-compose down</code>。</p></li></ol><hr><h2 id="第二步：删除-Agent-的相关文件"><a href="#第二步：删除-Agent-的相关文件" class="headerlink" title="第二步：删除 Agent 的相关文件"></a><strong>第二步：删除 Agent 的相关文件</strong></h2><p>卸载 Agent 包括停止服务、卸载服务，以及删除相关文件。以下是 Ubuntu 系统的卸载步骤：</p><ol><li><p>停止并卸载服务：</p><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;opt&#x2F;nezha&#x2F;agent&#x2F;.&#x2F;nezha-agent service uninstall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>删除 Agent 文件夹：</p><pre class="line-numbers language-none"><code class="language-none">rm -rf &#x2F;opt&#x2F;nezha&#x2F;agent&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>如果安装了多个服务并想要全部卸载，可以使用 Agent 安装脚本的卸载功能：</p><p>bash</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;agent.sh uninstall<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://nezha.wiki/guide/agent.html">安装 Agent | 哪吒服务器监控</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建独角数卡</title>
      <link href="/2025/06/14/166-da-jian-du-jiao-shu-qia/"/>
      <url>/2025/06/14/166-da-jian-du-jiao-shu-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>(PHP + PHPCLI) version &#x3D; 7.4<ul><li>*<strong>安装<code>fileinfo</code>扩展</strong></li><li>*<strong>安装<code>redis</code>扩展</strong></li><li>*<strong>终端需支持<code>php-cli</code>，测试<code>php -v</code>(版本必须一致)</strong></li><li>*<strong>需要开启的函数：<code>putenv</code>，<code>proc_open</code>，<code>pcntl_signal</code>，<code>pcntl_alarm</code></strong></li><li>安装<code>opcache</code>扩展</li></ul></li><li>Nginx version &gt;&#x3D; 1.16</li><li>MYSQL version &gt;&#x3D; 5.6</li><li>Redis (高性能缓存服务)</li><li>Supervisor (一个python编写的进程管理服务)</li><li>Composer (PHP包管理器)</li><li>Linux (Win下未测试，建议直接Linux)</li></ul><p><strong>下一步搭建支付接口</strong></p><p><a href="https://guozh.net/automatic-card-issuance-website-setup-tutorial/">自动发卡网站搭建教程（独角数卡），支付 + 图文 + 视频 | 老郭种树</a></p><p><a href="https://blog.laoda.de/archives/docker-compose-install-dujiaoka">利用Docker轻松搭建独角发卡！人人都可以开一个线上小店｜好玩儿的Docker项目-我不是咕咕鸽</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>官网也太干净了</p></blockquote><h2 id="1-系统更新与基础软件"><a href="#1-系统更新与基础软件" class="headerlink" title="1. 系统更新与基础软件"></a>1. 系统更新与基础软件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt update &amp;&amp; sudo apt upgrade -ysudo apt install -y git curl unzip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="2-安装和切换到-PHP-7-4"><a href="#2-安装和切换到-PHP-7-4" class="headerlink" title="2. 安装和切换到 PHP 7.4"></a>2. 安装和切换到 PHP 7.4</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装 PHP7.4 及常用扩展sudo apt install -y \  php7.4-cli php7.4-fpm php7.4-mbstring php7.4-xml \  php7.4-gd php7.4-mysql php7.4-zip php7.4-curl \  php7.4-bcmath php7.4-fileinfo php-redis# 将系统默认 php 命令指向 PHP7.4sudo update-alternatives --set php &#x2F;usr&#x2F;bin&#x2F;php7.4sudo update-alternatives --set phar &#x2F;usr&#x2F;bin&#x2F;phar7.4sudo update-alternatives --set phar.phar &#x2F;usr&#x2F;bin&#x2F;phar.phar7.4# 验证php -vsudo systemctl restart php7.4-fpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="3-安装-Nginx、MySQL、Redis、Supervisor"><a href="#3-安装-Nginx、MySQL、Redis、Supervisor" class="headerlink" title="3. 安装 Nginx、MySQL、Redis、Supervisor"></a>3. 安装 Nginx、MySQL、Redis、Supervisor</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt install -y nginx mysql-server redis-server supervisor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="4-配置-MySQL-数据库"><a href="#4-配置-MySQL-数据库" class="headerlink" title="4. 配置 MySQL 数据库"></a>4. 配置 MySQL 数据库</h2><ol><li><p>初始化安全设置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;udo mysql_secure_installation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>登录 MySQL 并建库建用户（替换 <code>your_password</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo mysql -u root -pCREATE DATABASE dujiaoka CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;CREATE USER &#39;dujiaoka&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;your_password&#39;;GRANT ALL PRIVILEGES ON dujiaoka.* TO &#39;dujiaoka&#39;@&#39;localhost&#39;;FLUSH PRIVILEGES;EXIT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="5-安装-Composer"><a href="#5-安装-Composer" class="headerlink" title="5. 安装 Composer"></a>5. 安装 Composer</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -sS https:&#x2F;&#x2F;getcomposer.org&#x2F;installer | phpsudo mv composer.phar &#x2F;usr&#x2F;local&#x2F;bin&#x2F;composer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="6-获取代码并配置环境"><a href="#6-获取代码并配置环境" class="headerlink" title="6. 获取代码并配置环境"></a>6. 获取代码并配置环境</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;var&#x2F;wwwgit clone https:&#x2F;&#x2F;github.com&#x2F;assimon&#x2F;dujiaoka.gitcd dujiaokacp .env.example .env<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>编辑 <code>.env</code>，设置与你的环境一致的值：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">DB_CONNECTION&#x3D;mysqlDB_HOST&#x3D;127.0.0.1DB_PORT&#x3D;3306DB_DATABASE&#x3D;dujiaokaDB_USERNAME&#x3D;dujiaokaDB_PASSWORD&#x3D;your_passwordREDIS_HOST&#x3D;127.0.0.1REDIS_PASSWORD&#x3D;nullREDIS_PORT&#x3D;6379APP_DEBUG&#x3D;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="7-安装-PHP-依赖、生成-key-和迁移"><a href="#7-安装-PHP-依赖、生成-key-和迁移" class="headerlink" title="7. 安装 PHP 依赖、生成 key 和迁移"></a>7. 安装 PHP 依赖、生成 key 和迁移</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">composer install --no-dev -ophp artisan key:generatephp artisan migrate --seed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置目录权限：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo chown -R www-data:www-data storage bootstrap&#x2F;cachesudo chmod -R 775 storage bootstrap&#x2F;cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>清理并缓存配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php artisan config:clearphp artisan config:cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="8-配置-Nginx"><a href="#8-配置-Nginx" class="headerlink" title="8. 配置 Nginx"></a>8. 配置 Nginx</h2><p>在 <code>/etc/nginx/sites-available/dujiaoka</code> 写入：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 80;    server_name your.domain.com;    root &#x2F;var&#x2F;www&#x2F;dujiaoka&#x2F;public;    index index.php;    location &#x2F; &#123;        try_files $uri $uri&#x2F; &#x2F;index.php$is_args$query_string;    &#125;    location ~ \.php$ &#123;        include snippets&#x2F;fastcgi-php.conf;        fastcgi_pass unix:&#x2F;run&#x2F;php&#x2F;php7.4-fpm.sock;    &#125;    location ~ &#x2F;\.ht &#123; deny all; &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启用并重载：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;dujiaoka &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;sudo nginx -tsudo systemctl reload nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="9-配置-Supervisor-守护队列"><a href="#9-配置-Supervisor-守护队列" class="headerlink" title="9. 配置 Supervisor 守护队列"></a>9. 配置 Supervisor 守护队列</h2><p>创建 <code>/etc/supervisor/conf.d/dujiaoka-worker.conf</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[program:dujiaoka-worker]command&#x3D;php &#x2F;var&#x2F;www&#x2F;dujiaoka&#x2F;artisan queue:work --sleep&#x3D;3 --tries&#x3D;3 --daemonautostart&#x3D;trueautorestart&#x3D;trueuser&#x3D;www-datanumprocs&#x3D;1redirect_stderr&#x3D;truestdout_logfile&#x3D;&#x2F;var&#x2F;www&#x2F;dujiaoka&#x2F;storage&#x2F;logs&#x2F;worker.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo supervisorctl rereadsudo supervisorctl updatesudo supervisorctl start dujiaoka-worker:*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p>或者：</p><h3 id="1-为-artisan-添加可执行权限"><a href="#1-为-artisan-添加可执行权限" class="headerlink" title="1. 为 artisan 添加可执行权限"></a>1. 为 artisan 添加可执行权限</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo chmod +x &#x2F;var&#x2F;www&#x2F;dujiaoka&#x2F;artisan<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样才能让 Supervisor 或 www-data 用户去调用它。</p><hr><h3 id="2-把-Supervisor-配置写入文件"><a href="#2-把-Supervisor-配置写入文件" class="headerlink" title="2. 把 Supervisor 配置写入文件"></a>2. 把 Supervisor 配置写入文件</h3><p>用你的编辑器（或 <code>tee</code> + heredoc）在 <code>/etc/supervisor/conf.d/dujiaoka-worker.conf</code> 创建以下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo tee &#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;dujiaoka-worker.conf &lt;&lt; &#39;EOF&#39;[program:dujiaoka-worker]command&#x3D;php &#x2F;var&#x2F;www&#x2F;dujiaoka&#x2F;artisan queue:work --sleep&#x3D;3 --tries&#x3D;3 --daemonautostart&#x3D;trueautorestart&#x3D;trueuser&#x3D;www-datanumprocs&#x3D;1redirect_stderr&#x3D;truestdout_logfile&#x3D;&#x2F;var&#x2F;www&#x2F;dujiaoka&#x2F;storage&#x2F;logs&#x2F;worker.logEOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（如果你更习惯用 <code>nano</code>&#x2F;<code>vi</code>，也可以 <code>sudo nano /etc/supervisor/conf.d/dujiaoka-worker.conf</code> 然后粘上去、保存。）</p><hr><h3 id="3-重新加载并启动"><a href="#3-重新加载并启动" class="headerlink" title="3. 重新加载并启动"></a>3. 重新加载并启动</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo supervisorctl rereadsudo supervisorctl updatesudo supervisorctl start dujiaoka-worker:*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时 <code>supervisorctl status</code> 应该能看到 <code>dujiaoka-worker</code> 正在运行。</p><hr><p>这样就能避免“命令未找到”和“artisan 权限被拒绝”的问题了。</p><h2 id="10-访问后台"><a href="#10-访问后台" class="headerlink" title="10. 访问后台"></a>10. 访问后台</h2><p>在浏览器中打开：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http:&#x2F;&#x2F;your.domain.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会自动跳转<code>http://your.domain.com/install</code>,填入设置的数据库名称密码</p><blockquote><p><strong>MySQL 数据库地址</strong>：填写 <code>127.0.0.1</code></p><p><strong>MySQL 端口</strong>：默认 <code>3306</code></p><p><strong>MySQL 数据库名</strong>：你之前建的 <code>名称</code></p><p><strong>MySQL 用户名</strong>：<code>用户名</code></p><p><strong>MySQL 密码</strong>：你为该用户设置的密码</p><p><strong>Redis 连接地址</strong>：<code>127.0.0.1</code></p><p><strong>Redis 密码</strong>：如果未设置则留空或输入 <code>null</code></p><p><strong>Redis 端口</strong>：默认 <code>6379</code></p><p><strong>网站名称</strong>：随意填写，比如发卡平台&#96;</p><p><strong>网站 URL</strong>：<code>https://your.domain.com</code></p><p><strong>后台登录路径</strong>：你在 <code>.env</code> 中配置的 <code>ADMIN_PATH</code>，例如 <code>admin</code></p></blockquote><p>安装后,进入<code>http://your.domain.com/admin</code></p><blockquote><p>用户名：admin<br>密码：admin</p></blockquote><p>将.env配置里面的APP_DEBUG设置为false</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="php7-4无法安装"><a href="#php7-4无法安装" class="headerlink" title="php7.4无法安装"></a>php7.4无法安装</h2><p>Ubuntu 22.04 及以后版本官方仓库只提供 PHP 8.1+，要装 PHP 7.4 需要加第三方源。</p><h2 id="方案-A：添加-Ondrej-Sury-的-PPA，安装-PHP-7-4"><a href="#方案-A：添加-Ondrej-Sury-的-PPA，安装-PHP-7-4" class="headerlink" title="方案 A：添加 Ondřej Surý 的 PPA，安装 PHP 7.4"></a>方案 A：添加 Ondřej Surý 的 PPA，安装 PHP 7.4</h2><ol><li><p><strong>安装添加 PPA 的工具</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt updatesudo apt install -y software-properties-common<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>添加 Ondřej Surý 的 PHP 源</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo add-apt-repository ppa:ondrej&#x2F;phpsudo apt update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>安装 PHP 7.4 及扩展</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt install -y \  php7.4-cli php7.4-fpm php7.4-mbstring php7.4-xml \  php7.4-gd php7.4-mysql php7.4-zip php7.4-curl \  php7.4-bcmath php7.4-fileinfo php-redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>切换系统默认 php（可选，但强烈推荐）</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo update-alternatives --set php &#x2F;usr&#x2F;bin&#x2F;php7.4sudo update-alternatives --set phar &#x2F;usr&#x2F;bin&#x2F;phar7.4sudo update-alternatives --set phar.phar &#x2F;usr&#x2F;bin&#x2F;phar.phar7.4php -v    # 确认输出为 7.4.xsudo systemctl restart php7.4-fpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>回到项目目录，重装依赖并缓存配置</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;var&#x2F;www&#x2F;dujiaokacomposer install --no-dev -ophp artisan config:clearphp artisan config:cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>这样就能正常生成 <code>vendor/autoload.php</code> 并运行 <code>php artisan</code> 系列命令。</p><h2 id="mysql的密码强度"><a href="#mysql的密码强度" class="headerlink" title="mysql的密码强度"></a>mysql的密码强度</h2><p>设置为强，则弱密码无法成功创建用户。</p><ol><li><p><strong>查看当前策略设置</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SHOW VARIABLES LIKE &#39;validate_password%&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>把策略调到最低</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SET GLOBAL validate_password.policy &#x3D; LOW;SET GLOBAL validate_password.length &#x3D; 4;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>再创建用户</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">CREATE USER &#39;dujiaoka&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;dujiaoka&#39;;GRANT ALL PRIVILEGES ON dujiaoka.* TO &#39;dujiaoka&#39;@&#39;localhost&#39;;FLUSH PRIVILEGES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>如果你想彻底卸载这个插件，也可以：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">UNINSTALL PLUGIN validate_password;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>记得每条 SQL 语句都要以分号 </code>;<code> 结尾</code></p><h2 id="（禁用默认站点"><a href="#（禁用默认站点" class="headerlink" title="（禁用默认站点"></a>（禁用默认站点</h2><p>如果你希望所有访问都落到 dujiaoka 上，也可以直接关掉默认配置：</p><pre class="line-numbers language-none"><code class="language-none">bash复制编辑sudo rm &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;defaultsudo nginx -tsudo systemctl reload nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样不管访问 IP 还是任何其它 “Host”，都会匹配到你 <code>/etc/nginx/sites-available/dujiaoka</code> 这个块。</p><h2 id="HTTP-请求已经被-Laravel-强制重定向到-HTTPS"><a href="#HTTP-请求已经被-Laravel-强制重定向到-HTTPS" class="headerlink" title="HTTP 请求已经被 Laravel 强制重定向到 HTTPS"></a>HTTP 请求已经被 Laravel 强制重定向到 HTTPS</h2><h2 id="方案一：给站点启用-HTTPS（推荐）"><a href="#方案一：给站点启用-HTTPS（推荐）" class="headerlink" title="方案一：给站点启用 HTTPS（推荐）"></a>方案一：给站点启用 HTTPS（推荐）</h2><ol><li><p><strong>安装 Certbot</strong></p><pre class="line-numbers language-none"><code class="language-none">sudo apt updatesudo apt install -y certbot python3-certbot-nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>为你的域名申请并自动配置 SSL</strong></p><pre class="line-numbers language-none"><code class="language-none">sudo certbot --nginx -d onecards.tech -d www.onecards.tech<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>按提示输入邮箱，勾选同意协议。</li><li>选 “重定向所有 HTTP 到 HTTPS”</li></ul></li><li><p><strong>验证</strong><br> 申请完成后，Certbot 会自动在 <code>/etc/nginx/sites-enabled/dujiaoka</code> 加入 443 监听配置并重载 Nginx。<br> 再访问：</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;onecards.tech&#x2F;admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应该能正确看到 <code>/admin/auth/login</code> 登录页。</p></li><li><p><strong>自动续期</strong><br> Certbot 会添加定时任务自动续期，你可以执行一次模拟续期验证：</p><pre class="line-numbers language-none"><code class="language-none">sudo certbot renew --dry-run<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><hr><h2 id="方案二：取消-HTTPS-强制，先用-HTTP-访问"><a href="#方案二：取消-HTTPS-强制，先用-HTTP-访问" class="headerlink" title="方案二：取消 HTTPS 强制，先用 HTTP 访问"></a>方案二：取消 HTTPS 强制，先用 HTTP 访问</h2><p>如果短期内不想折腾 SSL，可以临时让 Laravel 不跳转到 HTTPS，回到纯 HTTP：</p><ol><li><p>编辑 <code>.env</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">APP_URL&#x3D;http:&#x2F;&#x2F;onecards.tech<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>如果有设置“强制 HTTPS”中间件，注释掉或删除 <code>App\Http\Middleware\TrustProxies</code> 中对 <code>\Illuminate\Http\Middleware\EnsureHttps</code> 的调用；或者在 <code>AppServiceProvider</code> 里取消 <code>URL::forceScheme(&#39;https&#39;)</code>。</p></li><li><p>清理缓存并重建：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php artisan config:clearphp artisan route:clearphp artisan view:clearphp artisan config:cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>重新加载 Nginx（只要 80 端口在跑，就可以直接访问）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl reload nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>然后访问：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http:&#x2F;&#x2F;onecards.tech&#x2F;admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就不会再 302 跳到 HTTPS 了。</p></li></ol><p><a href="https://github.com/assimon/dujiaoka">官网</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>短路保护电路</title>
      <link href="/2025/06/13/165-duan-lu-bao-hu-dian-lu/"/>
      <url>/2025/06/13/165-duan-lu-bao-hu-dian-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="保险丝"><a href="#保险丝" class="headerlink" title="保险丝"></a>保险丝</h1><p>串入<strong>保险丝</strong>，当电流增大到保险丝的熔断电流时，保险丝会因为自身过热而发生熔断从而断开电路，<strong>这是最常见的保护电路之一。</strong></p><p>但是这种保险丝有一个缺点：当保险丝熔断之后，必须由工程人员排除故障之后手动替换新的保险丝，这在一些狭小空间等场合十分不便，因此后来便诞生了“<a href="https://zhida.zhihu.com/search?content_id=223338836&content_type=Article&match_order=1&q=%E8%87%AA%E6%81%A2%E5%A4%8D%E4%BF%9D%E9%99%A9%E4%B8%9D&zhida_source=entity">自恢复保险丝</a>”。这种保险丝在发生熔断之后随着温度的降低又会重新接通，这样便可以在发生故障时断开供电开关，等排查故障之后再打开供电开关即可。</p><h1 id="自恢复保险丝"><a href="#自恢复保险丝" class="headerlink" title="自恢复保险丝"></a>自恢复保险丝</h1><p>是由经过特殊处理的<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E8%81%9A%E5%90%88%E6%A0%91%E8%84%82/2459416?fromModule=lemma_inlink">聚合树脂</a>及分布在里面的导电粒子组成。</p><p><strong>属性</strong></p><p><strong>保持电流（I<sub>hold</sub>）</strong> 是“正常状态”能长期承载的电流上限；</p><p><strong>跳闸电流（I<sub>trip</sub>）</strong> 则是“故障触发”时电路保护动作的起始点；</p><p><strong>最大电流（I<sub>max</sub>）</strong> 描述的是在出现短路等极端过流时，PPTC 本体还能安全“扛”住多大的峰值电流而不被击穿。</p><p><strong>自恢复的原理</strong></p><p>在正常状况下，聚合树脂紧密地将导电粒子束缚在结晶状的结构外，构成链状导电电通路，此时的自恢复保险丝为低阻状态，线路上流经自恢复保险丝的电流所产生的热能小，不会改变<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84/10401467?fromModule=lemma_inlink">晶体结构</a>。当线路发生短路或过载时，流经自恢复保险丝的<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%A4%A7%E7%94%B5%E6%B5%81/5467824?fromModule=lemma_inlink">大电流</a>，产生的热量使聚合树脂融化，体积迅速增长，形成<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E9%AB%98%E9%98%BB%E7%8A%B6%E6%80%81/2663770?fromModule=lemma_inlink">高阻状态</a>，工作电流迅速减小，从而对电路进行限制和保护。因此由自恢复保险丝构成的保护电路还可以承担过热过流保护。</p><p><a href="https://zhuanlan.zhihu.com/p/608429956">常见保护电路（短路保护、过压保护、防反接保护、浪涌保护、静电防护），附电路图！ - 知乎</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>防反接电路</title>
      <link href="/2025/06/13/164-fang-fan-jie-dian-lu/"/>
      <url>/2025/06/13/164-fang-fan-jie-dian-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="防反接电路"><a href="#防反接电路" class="headerlink" title="防反接电路"></a>防反接电路</h1><p>1.串联肖特基二极管（简单，但有压降）</p><p><strong>2.P-MOSFET 防反接</strong>:</p><img src="/2025/06/13/164-fang-fan-jie-dian-lu/1749801991441.png" class="" width="1749801991441"><p>由于体二极管的存在(也叫寄生二极管),使<code>PMOS</code>在未导通的情况下,也会有电流通过,约0.7v压降。</p><p>电源5v正接时，S 极的电压迅速上升至5V-0.7V&#x3D;4.7V，Vg接地&#x3D;0V&lt;Vs,MOS管导通。</p><p>电源5V反接时，体二极管不导通，且Vg&#x3D;5V&gt;Vs&#x3D;0V,MOS管截止,故起到保护作用</p><p><a href="https://blog.csdn.net/dong6016/article/details/146826081?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-5-146826081-blog-130384315.235%5Ev43%5Epc_blog_bottom_relevance_base6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-5-146826081-blog-130384315.235%5Ev43%5Epc_blog_bottom_relevance_base6&utm_relevant_index=9">电源防反接电路</a></p><h2 id="我的一些问题"><a href="#我的一些问题" class="headerlink" title="我的一些问题"></a>我的一些问题</h2><img src="/2025/06/13/164-fang-fan-jie-dian-lu/1749804318481.png" class="" width="1749804318481"><h3 id="1-那这种情况下呢-vg和vs不都是5v码-反接的话-还是说-负载有一定的阻抗-vg还是大于vs"><a href="#1-那这种情况下呢-vg和vs不都是5v码-反接的话-还是说-负载有一定的阻抗-vg还是大于vs" class="headerlink" title="1.那这种情况下呢,vg和vs不都是5v码,反接的话,还是说,负载有一定的阻抗,vg还是大于vs"></a>1.那这种情况下呢,vg和vs不都是5v码,反接的话,还是说,负载有一定的阻抗,vg还是大于vs</h3><h4 id="Gemini-说："><a href="#Gemini-说：" class="headerlink" title="Gemini 说："></a>Gemini 说：</h4><blockquote><ol><li><strong>您的第二个问题“负载有一定的阻抗”</strong> 在这里不起作用。因为负载的另一端连接的是 <code>GND</code> 端子（现在是+5V），但电流要形成回路，必须先通过 MOSFET。既然 MOSFET 这里是断路，负载再小也没有用。</li><li><strong>计算关键的 Vgs 并判断 MOSFET 状态：</strong><ul><li>我们已经得出：<strong>Vg &#x3D; +5V</strong></li><li>我们已经得出：<strong>Vs ≈ 0V</strong></li><li>计算 Vgs： <code>Vgs = Vg - Vs = (+5V) - (0V) = +5V</code></li><li><strong>结论：</strong> 对于一个 P-MOSFET，当 Vgs 是一个<strong>正电压</strong>时，它会<strong>牢牢地截止（关断）</strong>。</li></ul></li></ol><p><strong>所以，您最初的思考“Vg和Vs不都是5V吗”是错误的。</strong></p><p>在反接时，<strong>Vg 确实是 +5V</strong>，因为它的参考点（电路板上的GND）被接到了电源正极。但 <strong>Vs 却因为 MOSFET 的阻断而无法获得电压，保持在 0V</strong>。正是这种 <strong>Vg &gt; Vs</strong> 的情况（Vgs为正），保证了 P-MOSFET 处于截止状态，从而保护了后面的电路。</p></blockquote><h3 id="2-我还是不太理解"><a href="#2-我还是不太理解" class="headerlink" title="2.我还是不太理解"></a>2.我还是不太理解</h3><ul><li><p>vs不可以通过反接的5v然后再通过负载之后获得低一点的电压吗</p></li><li><p>还是说只有形成回路之后才有电压,那么为什么vg就有电压，电路同样没有导通</p></li><li><p>还是说，电压是一个点，一个电动势差，而电压传递需要电流，也就是电路导通，否则只有那个点，或者负载的一头是5v</p></li></ul><h4 id="Gemini-说：-1"><a href="#Gemini-说：-1" class="headerlink" title="Gemini 说："></a>Gemini 说：</h4><p>我们来彻底理清这个思路。您的困惑点可以总结为：</p><ol><li>为什么 Vg 能“凭空”获得 +5V 电压，而 Vs 却不能？</li><li>电压的传递是否一定需要电流？</li></ol><p>让我们先回答第二个问题，因为它是一切的基础。</p><p><strong>电压 vs. 电流：水压 vs. 水流</strong></p><p>把电路想象成一个水管系统，这个比喻在这里非常贴切：</p><ul><li><strong>电压 (Voltage)</strong>：就像是<strong>水压 (Pressure)</strong>。一个封闭的水龙头，它的一端连接着高压水塔，即使水龙头关着（没有水流），水龙头入口处的水压依然很高。<strong>电压是两点之间的电位差，它可以在没有电流的情况下独立存在。</strong></li><li><strong>电流 (Current)</strong>：就像是<strong>水流 (Flow)</strong>。只有当你打开水龙头，水才会从高压处流向低压处（比如大气中），形成水流。<strong>电流是电荷的定向移动，它必须在一个完整的闭合回路 (Circuit) 中才能形成。</strong></li></ul><p><strong>关键结论</strong>：一个点可以有电压（相对于另一点），但<strong>不一定</strong>有电流流过它。但是，要让电流持续流动，<strong>必须</strong>有一个完整的回路。</p><p><strong>为什么 Vg 能获得 +5V 电压？</strong></p><ul><li><strong>看 G 点</strong>：栅极 G 通过电阻 R1 直接连接到了电路板的 <code>GND</code> 端子。</li><li><strong>看 GND 端子</strong>：这个端子现在被物理地连接到了电源的 <code>+5V</code> 输出上。</li><li><strong>思考“水压”</strong>：就像你把一个压力表的探头直接碰到了高压水管上一样。<code>GND</code> 端子上的“电势”（电的水位）就是 +5V。因为 G 点和 <code>GND</code> 端子之间只有一根导线和一个电阻，没有开关断开它们，所以 G 点的电势也被“拉高”到了 +5V（相对于电源的 0V 端）。</li><li><strong>这里有电流吗？</strong> 在稳定状态下，几乎没有。因为 G 极和 S&#x2F;D 极之间是绝缘的（像一个极大的电容），电流无法流过。R1 中也几乎没有电流，因为它的一端是 G 点 (+5V)，另一端是 <code>GND</code> 端子（也是+5V），没有压差就没有电流。</li><li><strong>结论</strong>：<strong>Vg &#x3D; +5V</strong>，这是因为 G 点被直接连接到了高电位点，<strong>这个电压的存在，不需要一个完整的回路。</strong></li></ul><p><strong>最后一个问题</strong></p><blockquote><p>“还是说，电压是一个电，一个电动势差，而电压传递需要电流，也就是电路导通，否则只有那个点，或者负载的一头是5v”</p></blockquote><p>您的这句话前半部分稍微有点混淆，但后半部分完全正确！让我为您精确地梳理一下：</p><ul><li><strong>电压是电位差</strong>，它不需要电流就能存在。一个电池两端就有电压。</li><li><strong>一个点的电压</strong>，是指这个点相对于**参考点（通常是GND）**的电位差。</li><li><strong>但是，要让一个“悬空”的点获得电压，就必须有电荷的流动（即微小的电流）来给它“充电”到那个电压。</strong> 如果所有通路都被切断，它就无法建立起电压。</li></ul><p>在我们的反接案例中：</p><ul><li><code>GND</code> 端子和 G 极，因为直接连接到了电源正极，所以它们被“充电”到了 +5V。</li><li>S 极，因为它与所有电压源的连接都被 MOSFET 这个“开关”切断了，没有电流能流向它，所以它无法被“充电”，其电压维持在 0V（相对于电源负极）。</li><li><strong>您说的完全正确</strong>：“负载的一头是5v”。是的，负载连接 <code>GND</code> 端子的那一头是 +5V，但连接 S 极的另一头是 0V，因为中间的 MOSFET 断开了。</li></ul><h3 id="3“GND通过电阻，可以给Vg-5V，为什么，不能通过负载给Vout-5V？”"><a href="#3“GND通过电阻，可以给Vg-5V，为什么，不能通过负载给Vout-5V？”" class="headerlink" title="3“GND通过电阻，可以给Vg 5V，为什么，不能通过负载给Vout 5V？”"></a>3“GND通过电阻，可以给Vg 5V，为什么，不能通过负载给Vout 5V？”</h3><h4 id="Gemini-说：-2"><a href="#Gemini-说：-2" class="headerlink" title="Gemini 说："></a>Gemini 说：</h4><hr><p>答案在于 <strong>G极</strong> 和 <strong>S&#x2F;D极</strong> 在MOSFET内部的物理结构和电气特性是 <strong>完全不同</strong> 的。</p><p><strong>您问题的答案是：</strong></p><ul><li><strong>Vg 能获得 5V</strong>，因为它是一个<strong>高阻抗的信号输入端</strong>，它只需要“感知”到电压即可，不需要电流形成回路。它通过电阻 R1 直接连接到了 5V 电压源上。</li><li><strong>Vout&#x2F;Vs 不能获得 5V</strong>，因为它是一个<strong>功率通道的一部分</strong>。要让它有电压，必须有<strong>电流</strong>流过它。但在反接情况下，控制这个通道的 G 极恰好收到了“关断”信号，导致整个通道被切断，电流无法形成回路，因此 Vout&#x2F;Vs 无法从负载的另一端获得电压。</li></ul><p>这个电路的全部精髓就在于：<strong>利用 G 极的“只感知电压”的特性，去控制 S&#x2F;D 极的“负责通过电流”的通道。</strong> 反接时，G 极感知到了错误的电压，从而做出了正确的“关断”动作，保护了下游。</p><h3 id="4-也就是说，电流通过负载也是需要mos管导通的，但是通过电阻也是需要电流的，只不过vg需要的电流极小，vs需要的大，假如将负载去掉呢，变成导线，是否可以"><a href="#4-也就是说，电流通过负载也是需要mos管导通的，但是通过电阻也是需要电流的，只不过vg需要的电流极小，vs需要的大，假如将负载去掉呢，变成导线，是否可以" class="headerlink" title="4.也就是说，电流通过负载也是需要mos管导通的，但是通过电阻也是需要电流的，只不过vg需要的电流极小，vs需要的大，假如将负载去掉呢，变成导线，是否可以"></a>4.也就是说，电流通过负载也是需要mos管导通的，但是通过电阻也是需要电流的，只不过vg需要的电流极小，vs需要的大，假如将负载去掉呢，变成导线，是否可以</h3><h4 id="Gemini-说：-3"><a href="#Gemini-说：-3" class="headerlink" title="Gemini 说："></a>Gemini 说：</h4><blockquote><p>“也就是说，电流通过负载也是需要mos管导通的”</p></blockquote><p><strong>完全正确！</strong> 这是核心。负载要工作，电流必须形成一个完整的回路，而MOSFET就是这个回路上的一个关键开关。开关不开，一切免谈。</p><blockquote><p>“但是通过电阻也是需要电流的，只不过vg需要的电流极小，vs需要的大”</p></blockquote><p><strong>这里就是最关键的区别所在！</strong> 这句话前半部分正确，后半部分需要更精确的描述。</p><ul><li><strong>Vg 通过电阻建立电压</strong>：是的，理论上需要电流。在MOSFET的G极（栅极）和S&#x2F;D极之间，有一层极薄的二氧化硅绝缘层，这构成了一个微型电容（栅极电容）。当电压变化时，需要一个<strong>瞬时</strong>的、<strong>极小</strong>的充电或放电电流来改变这个电容两端的电压。一旦电压建立稳定，理论上就不再有电流流动（只有nA级别的漏电流，可以忽略不计）。所以说“Vg需要的电流极小”是完全正确的。这个电流小到足以让一个100KΩ甚至1MΩ的电阻轻松提供。</li><li><strong>Vs 需要的电流大</strong>：这个描述不完全准确。应该说：<strong>Vs 端所连接的负载（Load）正常工作时，需要较大的电流流过。</strong> Vs本身只是一个点，它不“需要”电流。但是，要让连接在Vs和GND之间的负载（比如ESP32芯片、LED灯等）工作起来，就必须有一个<strong>持续的、较大的工作电流</strong>从<code>Vin -&gt; D -&gt; S -&gt; 负载 -&gt; GND</code>这个路径流过。</li></ul><p><strong>区别的核心</strong>：Vg需要的是<strong>建立电压信号</strong>的瞬时微小电流，而负载需要的是<strong>维持工作</strong>的持续较大电流。</p><hr><p><strong>“假如将负载去掉呢，变成导线，是否可以？”</strong></p><p>现在我们来分析各个点的电压：</p><ol><li><strong>Vg 的电压</strong>：G极通过R1连接到<code>GND</code>端子，<code>GND</code>端子是+5V。所以 <strong>Vg &#x3D; +5V</strong>。 (这一点不变)</li><li><strong>Vs 的电压</strong>：S极现在被一根<strong>导线</strong>直接连接到了<code>GND</code>端子，<code>GND</code>端子是+5V。所以 <strong>Vs &#x3D; +5V</strong>。 (这是变化点！)</li><li><strong>计算关键的 Vgs</strong>：<br> <code>Vgs = Vg - Vs = (+5V) - (+5V) = 0V</code></li><li><strong>判断MOSFET状态</strong>：<br> 对于P-MOSFET，当 Vgs &#x3D; 0V 时，它处于<strong>截止（OFF）状态</strong>！</li></ol><p><strong>实验结果</strong>：<br> 即使我们用导线把S极直接短接到+5V，P-MOSFET依然会<strong>保持截止</strong>！</p><p><strong>为什么？</strong><br> 因为它判断导通的唯一标准是 <code>Vgs</code> 是否为足够大的负值。现在 <code>Vgs</code> 是0V，不满足导通条件，所以它依然是关断的。</p><p><strong>这个实验告诉我们什么？</strong><br> 这个防反接电路的鲁棒性（Robustness）非常强。无论下游的负载是什么情况（开路、正常负载、甚至直接短路到反接的电源正极），只要电源是反接的，<code>Vg</code> 和 <code>Vs</code> 的电压关系就会让 <code>Vgs</code> 无法成为负值，从而保证了MOSFET的关断状态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP-IDF开发遇到的一些小问题</title>
      <link href="/2025/06/10/162-esp-idf-kai-fa-yu-dao-de-yi-xie-xiao-wen-ti/"/>
      <url>/2025/06/10/162-esp-idf-kai-fa-yu-dao-de-yi-xie-xiao-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="IDF"><a href="#IDF" class="headerlink" title="IDF"></a>IDF</h1><p>1.使用命令不一定非要安装环境,可以直接在这里执行</p><img src="/2025/06/10/162-esp-idf-kai-fa-yu-dao-de-yi-xie-xiao-wen-ti/1749547432056.png" class="" width="1749547432056"><pre class="line-numbers language-none"><code class="language-none">idf.py fullcleanidf.py build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.库找不到,但是可以正常烧录</p><img src="/2025/06/10/162-esp-idf-kai-fa-yu-dao-de-yi-xie-xiao-wen-ti/1749547477330.png" class="" width="1749547477330"><h3 id="1-确认-compile-commands-json-存在"><a href="#1-确认-compile-commands-json-存在" class="headerlink" title="1. 确认 compile_commands.json 存在"></a>1. 确认 <code>compile_commands.json</code> 存在</h3><p>在项目根目录下敲：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dir build\compile_commands.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果这个文件真的在，就可以继续；如果不在，就先运行一次</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">idf.py reconfigure<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">idf.py build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保证它生成了 <code>build/compile_commands.json</code>。</p><hr><h3 id="2-修改或创建-vscode-c-cpp-properties-json"><a href="#2-修改或创建-vscode-c-cpp-properties-json" class="headerlink" title="2. 修改或创建 .vscode/c_cpp_properties.json"></a>2. 修改或创建 <code>.vscode/c_cpp_properties.json</code></h3><p>在你工程根目录下，新建（或修改）<code>.vscode/c_cpp_properties.json</code>，内容改成这样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#123;  &quot;version&quot;: 4,  &quot;configurations&quot;: [    &#123;      &quot;name&quot;: &quot;ESP-IDF&quot;,      &#x2F;&#x2F; 点这里指给 C&#x2F;C++ 扩展，看它用哪个 compile_commands.json      &quot;compileCommands&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;build&#x2F;compile_commands.json&quot;,      &#x2F;&#x2F; 如果也想手动列 include 路径，可加在下面：      &quot;includePath&quot;: [        &quot;$&#123;workspaceFolder&#125;&#x2F;main&quot;,        &quot;$&#123;workspaceFolder&#125;&#x2F;components&#x2F;**&quot;      ],      &quot;defines&quot;: [],      &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;,      &quot;cStandard&quot;: &quot;c11&quot;,      &quot;cppStandard&quot;: &quot;c++17&quot;    &#125;  ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：</p><ul><li><code>&quot;compileCommands&quot;</code> 一定要指向你工程下的 <code>build/compile_commands.json</code>，这样 IntelliSense 才能自动捞到所有 IDF 组件的 include 路径和编译选项。</li><li><code>includePath</code> 只用来补充你自己组件里的头文件，跟 IDF 自带的组件没关系。</li></ul></blockquote><hr><h3 id="3-重载-VS-Code"><a href="#3-重载-VS-Code" class="headerlink" title="3. 重载 VS Code"></a>3. 重载 VS Code</h3><ol><li>保存 <code>c_cpp_properties.json</code></li><li>按 <strong>Ctrl+Shift+P</strong> → 输入 <strong>“Reload Window”</strong> → 回车</li></ol><p>重载完成之后，IntelliSense 就会根据你 <code>compile_commands.json</code> 里的信息，把所有 <code>freertos/task.h</code>、<code>driver/uart.h</code>、<code>esp_event.h</code>……都识别出来，红色波浪线就没了。</p><p>3.如果是直接复制项目进行改动(包括项目名字),容易出现,改动后的固件少录不进去,一直烧录之前的固件</p><h3 id="问题核心：应用程序不匹配，Wi-Fi-代码根本没运行"><a href="#问题核心：应用程序不匹配，Wi-Fi-代码根本没运行" class="headerlink" title="问题核心：应用程序不匹配，Wi-Fi 代码根本没运行"></a>问题核心：应用程序不匹配，Wi-Fi 代码根本没运行</h3><p>您提供的日志中最关键的一条信息是：</p><pre class="line-numbers language-none"><code class="language-none">--- Warning: Checksum mismatch between flashed and built applications. Checksum of built application is e6a935ffbf3d6e1cf8c0abfa80a2d54465a8cf48bdc4a6d8c404aa944e4e5b38<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以及：</p><pre class="line-numbers language-none"><code class="language-none">I (180) app_init: Project name: UART_BLE&#96; &#96;I (184) app_init: App version: 1&#96; &#96;I (189) app_init: Compile time: Jun 9 2025 11:00:38<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而我们期望的日志是 <code>UART_FILTER_FORWARD</code> 和 <code>uav_sniffer</code> 整合后的应用，其 <code>app_main</code> 应该会输出类似：</p><p><code>I (TAG) Starting ESP32 Drone Detection Combo Application...</code> 以及 Wi-Fi 初始化和任务创建的日志。</p><p><strong>但您的日志中完全没有 Wi-Fi 相关的初始化信息，也没有 uav_sniffer 或 DRONE_DETECTOR_COMBO 的日志标签。</strong> 而是显示项目名称为 <code>UART_BLE</code>，编译时间是 <code>Jun 9 2025 11:00:38</code>。这说明您现在运行在 ESP32-S3 上的固件是 <strong>一个名为 UART_BLE 的旧版本程序，而不是您最近编译的、包含 Wi-Fi Sniffer 功能的整合代码！</strong></p><hr><h3 id="具体原因分析"><a href="#具体原因分析" class="headerlink" title="具体原因分析"></a>具体原因分析</h3><ol><li><strong>固件版本不正确：</strong> 您的 ESP32-S3 板上实际运行的固件与您当前在电脑上编译的（并期望运行的）代码不一致。<code>Checksum mismatch</code> 警告就是最直接的证据。这意味着您上次编译并尝试烧录的整合代码可能没有成功烧录到板上，或者只烧录了部分。</li><li><strong>UART_BLE 项目：</strong> 日志显示 <code>Project name: UART_BLE</code>。这表明您可能之前烧录过一个名为 <code>UART_BLE</code> 的项目，并且该固件仍然保留在芯片上。</li><li><strong>缺少 Wi-Fi 初始化和任务创建日志：</strong> 由于运行的是旧固件，其中没有 Wi-Fi Sniffer 的初始化代码（<code>esp_wifi_init()</code>, <code>esp_wifi_set_promiscuous()</code> 等）和相关任务创建（<code>xTaskCreate</code> sniffer 任务和 channel hop 任务），所以自然就看不到 Wi-Fi 信标的数据打印。</li><li><strong>UART2 event type: 1 警告的复现：</strong> 这个警告在 <code>UART_BLE</code> 项目中也可能出现，因为它表明 UART2 接收存在 FIFO 溢出。这与 Wi-Fi sniffer 功能无关，是 UART 接收部分的独立问题。</li></ol><hr><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>您需要确保将正确的整合代码成功烧录到您的 ESP32-S3 上。</strong></p><p>请严格按照以下步骤操作：</p><ol><li><p><strong>确保您的 app_main.c 文件是最新的整合代码。</strong> (就是之前给您的包含 Wi-Fi Sniffer 和 UART 转发的那个 <code>app_main.c</code>)。</p></li><li><p><strong>进入您的 ESP-IDF 项目目录。</strong></p></li><li><p>执行完全清理和重新编译、烧录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">idf.py fullcleanidf.py buildidf.py flashidf.py monitor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>idf.py fullclean</code>：会彻底清除所有编译生成的文件，确保没有任何旧的或缓存的文件干扰。这是解决 <code>checksum mismatch</code> 的最有效方法。</li><li><code>idf.py build</code>：重新编译您的整个项目，确保包含所有最新的代码更改。</li><li><code>idf.py flash</code>：将新编译的固件完整地烧录到 ESP32-S3 板上。</li><li><code>idf.py monitor</code>：连接到串口并显示日志输出。</li></ul></li></ol><hr><h3 id="验证步骤"><a href="#验证步骤" class="headerlink" title="验证步骤"></a>验证步骤</h3><p>成功执行上述步骤后，您应该在 <code>idf.py monitor</code> 的输出中看到以下变化：</p><ul><li><p><strong>不再有 Checksum mismatch 警告。</strong></p></li><li><p><strong>项目名称应该不再是 UART_BLE</strong>，而是您的项目名称（例如 <code>DRONE_DETECTOR_COMBO</code> 或您在 <code>CMakeLists.txt</code> 中定义的项目名）。</p></li><li><p>会出现 Wi-Fi Sniffer 的初始化日志</p><p>，例如： </p><ul><li><code>I (XXX) DRONE_DETECTOR_COMBO: Starting ESP32 Drone Detection Combo Application...</code> (或您定义的 <code>TAG</code>)</li><li><code>I (XXX) DRONE_DETECTOR_COMBO: Sniffer started, looking for OUI FA:0B:BC, Type 0x0D</code></li><li>以及其他 Wi-Fi 相关的初始化信息和任务创建日志。</li></ul></li></ul><p>一旦您看到这些 Wi-Fi 相关的日志，并且没有新的致命错误，那么 Wi-Fi Sniffer 功能才真正开始运行，您才能期望它能打印并转发信标数据。如果那时仍然没有信标数据，我们再来检查 Wi-Fi Sniffer 内部的过滤逻辑和环境因素。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IEEE802.11协议</title>
      <link href="/2025/06/10/160-ieee802-11-xie-yi/"/>
      <url>/2025/06/10/160-ieee802-11-xie-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><ul><li><a href="https://ieeexplore.ieee.org/document/9363693">802.11-2020 </a></li><li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9363693">IEEE Xplore 全文 PDF</a>——<strong>9. Frame formats</strong>——P755</li><li><a href="https://howiwifi.com/2020/07/13/802-11-frame-types-and-formats/">802.11 帧类型和格式 – 如何使用 WI-FI</a></li><li><a href="https://www.cnblogs.com/rougungun/p/14340489.html">802.11 帧格式和分类详解 </a></li><li><a href="https://ieee802.org/11/">IEEE 802.11，制定无线标准的工作组 局域网</a></li><li><a href="https://www.geeksforgeeks.org/ieee-802-11-architecture/">IEEE 802.11 架构 - GeeksforGeeks</a></li></ul><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><img src="/2025/06/10/160-ieee802-11-xie-yi/1749522542245.png" class="" width="1749522542245"><h3 id="Address-1-to-4-地址-1-到-4"><a href="#Address-1-to-4-地址-1-到-4" class="headerlink" title="Address 1 to 4  地址 1 到 4"></a><strong>Address 1 to 4  地址 1 到 4</strong></h3><p>These fields contain standard IEEE 802 MAC addresses (48 bit each). The meaning of each address is defined by DS bits in the frame control field.<br>这些字段包含标准的 IEEE 802 MAC 地址（每个 48 位）。每个地址的含义由帧控制字段中的 DS 位定义。</p><blockquote><p>找资料的目的是,在使用ESP32收发802.11数据帧的时候,了解mac地址的位置</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言回炉</title>
      <link href="/2025/06/09/159-c-yu-yan-hui-lu/"/>
      <url>/2025/06/09/159-c-yu-yan-hui-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;      &#x2F;&#x2F; 标准输入输出库: 提供了像 snprintf 这样的函数，用于格式化字符串。#include &lt;string.h&gt;     &#x2F;&#x2F; 字符串处理库: 提供了像 strlen, strncpy, strcmp 这样的函数，用于操作C风格字符串。#include &lt;stdlib.h&gt;    &#x2F;&#x2F;malloc 和 free<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><p>python中的input，当遇到第一个空白时就不再输入。</p><h2 id="sscanf"><a href="#sscanf" class="headerlink" title="sscanf"></a>sscanf</h2><p>按照格式提取字符串</p><pre class="line-numbers language-none"><code class="language-none">int sscanf(const char *str, const char *format, ...);str：要读取的源字符串。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf"></a>snprintf</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; snprintf(char *str, size_t size, const char *format, ...);    &#x2F;&#x2F; 安全的格式化输出函数，它会将格式化的结果写入 str，最多写入 size-1 个字符，并自动添加 &#39;\0&#39;。    &#x2F;&#x2F; %d: 整数, %02X: 两位大写十六进制数 (不足两位前面补0), %s: 字符串。    &#x2F;&#x2F; \&quot; 转义双引号，使其作为普通字符出现在输出字符串中。    &#x2F;&#x2F; \r\n: 回车换行符。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>TYPE_HEX=0x%02X</code>：固定文本，<code>%02X</code> 会被第三个变量 <code>type_code</code> 的值替换。</p><ul><li><code>X</code>：表示以大写字母输出十六进制数。</li><li><code>02</code>：表示最少输出两位，如果不足两位，前面用 <code>0</code> 填充。例如，如果 <code>type_code</code> 是10（十六进制是A），会输出 <code>0A</code>；如果是255（十六进制是FF），会输出 <code>FF</code>。</li></ul></blockquote><h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h2><p>用C函数strlen()获取字符串的长度。</p><p>C语言用\0标记字符串的结束</p><p>strlen()得出的字符串中的字符数包括空格和标点符号,sizeof给出的更大,由于将字符串末尾不可见的空字符也计算在内,所以一般使用sizeof都需要-1</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">strlen(data_line) 获取 data_line 字符串的长度 (不包括末尾的空字符 &#39;\0&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; strncpy(destination, source, num);&#x2F;&#x2F; 从源字符串 source 复制最多 num 个字符到目标字符串 destination。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="atoi"><a href="#atoi" class="headerlink" title="atoi"></a>atoi</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">atoi(const char *str); 将数字字符串转换为整数 (int)。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>缺点是会将浮点数转变为整数，840.5-&gt;840</p><p><code>atoi</code> (ASCII to Integer) 函数在 C 和 C++ 中用于将字符串转换为整数。它的转换规则如下：</p><ol><li><strong>跳过前导空白字符</strong>：例如空格、制表符等。</li><li><strong>处理可选的正负号</strong>：<code>+</code> 或 <code>-</code>。</li><li><strong>读取连续的数字字符</strong>：’0’ 到 ‘9’。</li><li><strong>在第一个非数字字符处停止</strong>：一旦遇到不属于数字的字符，它就会停止解析，并返回到目前为止已经成功转换的整数值。</li></ol><h2 id="atof"><a href="#atof" class="headerlink" title="atof"></a>atof</h2><p>⚠️:atoi与atof在严肃的程序里是不被推荐的由于(缺乏错误处理和会出现未定义协议)</p><p><strong>f 后缀的意义</strong>: 在 C&#x2F;C++ 中，浮点数字面量默认是 <code>double</code> (双精度浮点数) 类型。</p><ul><li><code>1240.0</code> 是一个 <code>double</code> 类型的值（通常占8个字节）。</li><li><code>1240.0f</code> 是一个 <code>float</code> 类型的值（通常占4个字节）。</li></ul><h2 id="strtol"><a href="#strtol" class="headerlink" title="strtol"></a>strtol</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; strtol(const char *nptr, char **endptr, int base);    &#x2F;&#x2F; 将字符串 nptr 按照 base 指定的进制转换为长整数 (long int)。    &#x2F;&#x2F; NULL 作为第二个参数表示不关心转换结束的位置。    &#x2F;&#x2F; 16 表示按十六进制转换。    &#x2F;&#x2F; (uint8_t) 是类型转换，将结果转换为8位无符号整数。    uint8_t type_code &#x3D; (uint8_t)strtol(type_str, NULL, 16);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int result1 &#x3D; strcmp(s1, s2); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比较字符数，s1大于s2，则result&#x3D;1，反之等于-1，相等则为0。</p><h2 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp"></a>strncmp</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int strncmp(const char *s1, const char *s2, size_t n);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比较字符串</p><p><strong>n</strong>：最多比较的字符数。</p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 在任务函数内部定义uint8_t *data_tmp &#x3D; (uint8_t *)malloc(UART_BUF_SIZE);uint8_t *data_tmp: 定义一个指向 uint8_t（无符号8位整数，即字节）类型的指针 data_tmp。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>malloc(UART_BUF_SIZE): 从<code>堆内存中动态分配一块内存</code>。UART_BUF_SIZE 是一个预定义的宏，指定了分配内存的大小（例如 1024 字节）。</p><p>(uint8_t <em>): 强制类型转换，因为 malloc 函数返回的是一个通用的 void</em> 指针。</p><blockquote><p>作用: 这个 data_tmp 缓冲区用来临时存放从 UART 驱动的内部环形缓冲区（Ring Buffer）中读取出来的原始字节数据。我们一次性从驱动读取一批数据到这里，然后再逐字节地进行分析和处理，这样比一个字节一个字节地调用 uart_read_bytes 效率更高。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; static const char *TAG &#x3D; &quot;UART_FILTER_FORWARD&quot;;&#x2F;&#x2F; 定义一个静态常量字符指针 TAG。&#x2F;&#x2F; &#39;static&#39; 意味着这个变量只在当前文件 (main.c) 中可见。&#x2F;&#x2F; &#39;const char *&#39; 表示它是一个指向常量字符（字符串字面量）的指针。&#x2F;&#x2F; ESP_LOGx 系列宏使用这个 TAG 来标识日志信息的来源模块，方便调试。static const char *TAG &#x3D; &quot;UART_FILTER_FORWARD&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><strong>作用</strong>：这是一个标准的 C 语言关键字，但在中断和多任务编程中至关重要。它告诉编译器：“这个变量随时可能在你看不到的地方被改变（比如在中断里），所以请不要对它进行优化。每次使用它时，都必须老老实实地从内存中重新读取，每次修改它时，都必须立即写回内存。”</p><h1 id="指针类型转换和结构体成员访问"><a href="#指针类型转换和结构体成员访问" class="headerlink" title="指针类型转换和结构体成员访问"></a>指针类型转换和结构体成员访问</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c">const wifi_promiscuous_pkt_t *pkt &#x3D; (wifi_promiscuous_pkt_t *)buf;const uint8_t *payload &#x3D; pkt-&gt;payload; &#x2F;&#x2F; payload是数据包的实际内容const int len &#x3D; pkt-&gt;rx_ctrl.sig_len;  &#x2F;&#x2F; len是数据包的长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>const wifi_promiscuous_pkt_t *pkt &#x3D; (wifi_promiscuous_pkt_t *)buf;</strong><ul><li><code>buf</code>: 通常，<code>buf</code> 是一个 <code>void *</code> 类型的指针，它指向从网卡混杂模式（promiscuous mode）捕获到的原始数据包的起始地址。混杂模式允许网卡接收所有流经它的数据包，而不仅仅是发给它自己的数据包。</li><li><code>(wifi_promiscuous_pkt_t *)buf</code>: 这是一个<strong>强制类型转换 (type casting)</strong>。它告诉编译器，将 <code>buf</code> 这个 <code>void *</code> 指针所指向的内存区域，按照 <code>wifi_promiscuous_pkt_t</code> 结构体的定义来解释。</li><li><code>const wifi_promiscuous_pkt_t *pkt</code>: 定义了一个名为 <code>pkt</code> 的<strong>常量指针</strong>，它指向一个 <code>wifi_promiscuous_pkt_t</code> 类型的结构体。<code>const</code> 关键字表示通过 <code>pkt</code> 指针不能修改它所指向的数据。</li><li><strong>作用：</strong> 这行代码的目的是将捕获到的原始数据 <code>buf</code> 解释为一个预定义的 <code>wifi_promiscuous_pkt_t</code> 结构体。这个结构体通常定义了 Wi-Fi 捕获数据包的通用格式，包括一些控制信息和实际的载荷数据。</li></ul></li><li><strong>const uint8_t *payload &#x3D; pkt-&gt;payload;</strong><ul><li><code>pkt-&gt;payload</code>: 这里使用了<strong>箭头操作符 -&gt;</strong>。当 <code>pkt</code> 是一个指向结构体的指针时，<code>pkt-&gt;payload</code> 用于访问 <code>pkt</code> 所指向的 <code>wifi_promiscuous_pkt_t</code> 结构体内部的 <code>payload</code> 成员。</li><li><code>payload</code> 成员通常是一个 <code>uint8_t *</code> 类型的指针，它指向数据包的<strong>实际内容</strong>，也就是 MAC 帧的头部和载荷部分。</li><li><strong>作用：</strong> 这一步从解析后的数据包结构体中提取出我们最关心的部分——数据包的实际有效载荷，并将其存储在一个 <code>const uint8_t *</code> 类型的指针 <code>payload</code> 中，方便后续处理。</li></ul></li><li>**const int len &#x3D; pkt-&gt;rx_ctrl.sig_len; **<ul><li><code>pkt-&gt;rx_ctrl</code>: 同样使用箭头操作符访问 <code>pkt</code> 指向的结构体中的 <code>rx_ctrl</code> 成员。<code>rx_ctrl</code> 通常是一个嵌套的结构体，包含接收到的数据包的各种控制信息，比如信号强度、数据包长度等。</li><li><code>rx_ctrl.sig_len</code>: 访问 <code>rx_ctrl</code> 结构体中的 <code>sig_len</code> 成员。<code>sig_len</code> 通常代表了<strong>实际接收到的数据包的有效长度</strong>（信号长度）。</li><li><strong>作用：</strong> 获取数据包的长度，这在后续遍历 <code>payload</code> 时非常重要，可以避免越界访问。</li></ul></li></ul><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><img src="/2025/06/09/159-c-yu-yan-hui-lu/1751273304979.png" class="" width="1751273304979"><img src="/2025/06/09/159-c-yu-yan-hui-lu/1751273417665.png" class="" width="1751273417665"><h1 id="math"><a href="#math" class="headerlink" title="math"></a>math</h1><h2 id="powf-ratio-FIT-A"><a href="#powf-ratio-FIT-A" class="headerlink" title="powf(ratio, FIT_A)"></a>powf(ratio, FIT_A)</h2><p>计算 ratio 的 FIT_A 次方</p><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><ul><li>const: 数据是只读的</li><li>static: 作用域限制在当前文件</li><li>while</li><li>typedef</li><li></li></ul><h1 id="分文件管理"><a href="#分文件管理" class="headerlink" title="分文件管理"></a>分文件管理</h1><p>分文件管理时，</p><p>在.c文件中定义,.h文件中extern声明,那么包含这个.h文件的其他.c文件就都可以使用声明过的函数或者变量了。</p><p>不可以在头文件中定义,因为包含头文件的源文件都会定义,会导致重定义的报错。</p><p><strong>特殊情况（补充说明，但对你目前解决问题没有直接影响）：</strong></p><ol><li><strong>static 关键字：</strong><ul><li>对于变量，<code>static</code> 放在全局作用域时，会使其具有<strong>内部链接属性</strong>。这意味着该变量只在定义它的那个 <code>.c</code> 文件内部可见，其他 <code>.c</code> 文件即使有同名的 <code>static</code> 变量，它们也是独立的互不影响的副本。</li><li>这就是 ESP-IDF 推荐日志 <code>TAG</code> 的做法：每个 <code>.c</code> 文件都有自己的 <code>static const char *TAG = &quot;MODULE_NAME&quot;;</code>，它们是独立的。</li><li>对于函数，<code>static</code> 也会使其具有内部链接属性，函数只在当前 <code>.c</code> 文件内可见。</li></ul></li><li><strong>inline 关键字：</strong><ul><li>对于函数，<code>inline</code> 是一种提示编译器进行内联优化的关键字。为了使 <code>inline</code> 函数能在多个 <code>.c</code> 文件中被定义而不会出现重复定义错误，C++ 标准（以及 C99&#x2F;C11 标准）规定 <code>inline</code> 函数允许多重定义，但所有定义必须完全相同。链接器会选择其中一个定义。这在头文件中定义小函数时常用。</li></ul></li></ol><h1 id="union联合体"><a href="#union联合体" class="headerlink" title="union联合体"></a>union联合体</h1><p><code>union</code> 通用事件结构体的核心功能，就是用一种标准化的“容器”，将系统中各种不同类型、不同来源的事件&#x2F;消息进行统一封装。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 定义“标签”的种类typedef enum &#123;    EVENT_FROM_NETWORK,  &#x2F;&#x2F; 标签：网络来的    EVENT_FROM_BUTTON,   &#x2F;&#x2F; 标签：按键来的    EVENT_FROM_SENSOR,   &#x2F;&#x2F; 标签：传感器来的&#125; event_type_t;&#x2F;&#x2F; 一个包含所有可能数据类型的 &quot;魔术内胆&quot;typedef union &#123;    network_command_t net_cmd;   &#x2F;&#x2F; 网络指令（可能是一个结构体）    button_press_t    btn_press; &#x2F;&#x2F; 按键动作（可能是一个枚举）    float             sensor_val;  &#x2F;&#x2F; 传感器读数（可能是一个浮点数）&#125; event_payload_t;&#x2F;&#x2F; 最终的 &quot;快递盒&quot; 结构体typedef struct &#123;    event_type_t      type;    &#x2F;&#x2F; 外面的“标签”    event_payload_t   payload; &#x2F;&#x2F; 里面的“魔术内胆”&#125; universal_event_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP-IDF开发ESP32 UART</title>
      <link href="/2025/06/09/158-esp-idf-kai-fa-esp32-uart/"/>
      <url>/2025/06/09/158-esp-idf-kai-fa-esp32-uart/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li><p>ESP IDF</p></li><li><p>ESP32-S3</p></li><li><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.4.1/esp32s3/api-reference/peripherals/uart.html">通用异步接收器&#x2F;发送器 (UART)  — ESP-IDF 编程指南 v5.4.1 文档</a></p></li><li><p><a href="https://github.com/espressif/esp-idf/blob/v5.4.1/examples/peripherals/uart/uart_async_rxtxtasks/main/uart_async_rxtxtasks_main.c">官方例程</a></p></li></ul><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol><li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.4.1/esp32s3/api-reference/peripherals/uart.html#uart-api-setting-communication-parameters">设置通信参数</a> - 设置波特率、数据位、停止位等</li><li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.4.1/esp32s3/api-reference/peripherals/uart.html#uart-api-setting-communication-pins">设置通信管脚</a> - 分配连接设备的管脚</li><li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.4.1/esp32s3/api-reference/peripherals/uart.html#uart-api-driver-installation">安装驱动程序</a> - 为 UART 驱动程序分配 ESP32-S3 资源</li><li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.4.1/esp32s3/api-reference/peripherals/uart.html#uart-api-running-uart-communication">运行 UART 通信</a> - 发送&#x2F;接收数据</li><li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.4.1/esp32s3/api-reference/peripherals/uart.html#uart-api-using-interrupts">使用中断</a> - 触发特定通信事件的中断</li><li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.4.1/esp32s3/api-reference/peripherals/uart.html#uart-api-deleting-driver">删除驱动程序</a> - 如无需 UART 通信，则释放已分配的资</li></ol><h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;freertos&#x2F;FreeRTOS.h&quot;#include &quot;freertos&#x2F;task.h&quot;#include &quot;esp_system.h&quot;#include &quot;esp_log.h&quot;#include &quot;driver&#x2F;uart.h&quot;#include &quot;string.h&quot;#include &quot;driver&#x2F;gpio.h&quot;static const int RX_BUF_SIZE &#x3D; 1024;#define TXD_PIN (GPIO_NUM_4)#define RXD_PIN (GPIO_NUM_5)void uart_init(void)&#123;    const uart_config_t uart_config &#x3D; &#123;        .baud_rate &#x3D; 115200,        .data_bits &#x3D; UART_DATA_8_BITS,        .parity &#x3D; UART_PARITY_DISABLE,        .stop_bits &#x3D; UART_STOP_BITS_1,        .flow_ctrl &#x3D; UART_HW_FLOWCTRL_DISABLE,        .source_clk &#x3D; UART_SCLK_DEFAULT,    &#125;;    &#x2F;&#x2F; We won&#39;t use a buffer for sending data.    uart_driver_install(UART_NUM_0, RX_BUF_SIZE * 2, 0, 0, NULL, 0);    uart_param_config(UART_NUM_0, &amp;uart_config);    &#x2F;&#x2F;uart_set_pin(UART_NUM_0, TXD_PIN, RXD_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);&#125;static void tx_task(void *arg)&#123;    static const char *TX_TASK_TAG &#x3D; &quot;TX_TASK&quot;;    esp_log_level_set(TX_TASK_TAG, ESP_LOG_INFO);    while (1)    &#123;        &#x2F;&#x2F; sendData(TX_TASK_TAG, &quot;Hello world&quot;);        &#x2F;&#x2F; Write data to UART.        char *test_str &#x3D; &quot;Hello World!\n&quot;;        uart_write_bytes(UART_NUM_0, (const char *)test_str, strlen(test_str));        vTaskDelay(2000 &#x2F; portTICK_PERIOD_MS);    &#125;&#125;void app_main(void)&#123;    uart_init();    &#x2F;&#x2F; xTaskCreate(rx_task, &quot;uart_rx_task&quot;, 1024 * 2, NULL, configMAX_PRIORITIES - 1, NULL);    xTaskCreate(tx_task, &quot;uart_tx_task&quot;, 1024 * 2, NULL, configMAX_PRIORITIES - 2, NULL);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li><p>关于ESP32-S3将USB-OTG与Uart0都引出到Type-c，但是前者却无法通信，ESP32-C3确可以正常</p><p>需要配置</p><blockquote><p>ctrl+shift+p输入 menuconfig 开启usb cdc</p></blockquote><p>开启后会出现无法烧录的问题</p><pre class="line-numbers language-none"><code class="language-none">-- Configuring incomplete, errors occurred!HINT: The component &#39;esp_log&#39; could not be found. This could be because: component name was misspelled, the component was not added to the build, the component has been moved to the IDF component manager, the component has been removed and refactored into some other component or the component may not be supported by the selected target.Please look out for component in &#39;https:&#x2F;&#x2F;components.espressif.com&#39; and add using &#39;idf.py add-dependency&#39; command.Refer to the migration guide for more details about moved components.Refer to the build-system guide for more details about how components are found and included in the build.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>暂未解决，且程序也需要改动，不能使用UART来进行通信</p><p><strong>设置的不对，直接在menuconfig中搜索不知道把什么东西设置成cdc模式了</strong></p></li></ol><p>​       应该搜索<code>ESP System Settings</code></p><img src="/2025/06/09/158-esp-idf-kai-fa-esp32-uart/1749631568465.png" class="" width="1749631568465"><ol start="2"><li>又出现</li></ol><p><strong><code>esp32:ninja: build stopped: subcommand failed. ninja failed with exit code 1.</code></strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">REQUIRES esp_tinyusbidf.py add-dependency espressif&#x2F;esp_tinyusbidf.py fullcleanidf.py build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/mondraker/article/details/135834794">ESP-IDF:如何在menuconfig中设置</a></p><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-guides/usb-otg-console.html">USB OTG 控制台 - ESP32-S3 - — ESP-IDF 编程指南 v5.4.1 文档</a></p><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/kconfig.html#config-esp-console-uart">项目配置 - ESP32-S3 - — ESP-IDF 编程指南 v5.4.1 文档</a></p><p>并且ESP32-C3在IDF中并不需要配置USB-CDC,可以直接进行烧录</p><h1 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h1><p>GPT推荐的，直接看参考手册有点费劲</p><p><strong>1.先看官方示例（examples）再看 API</strong><br> ESP-IDF 的安装目录或 GitHub 上都带有大量示例工程。先运行、调试一个最简单的 UART 收发示例，把流程跑通，再回过头带着“我到底做了什么”去看 API 文档，理解成本会低很多。</p><p><strong>2.阅读英文原版</strong><br> 中文翻译有时不够准确或不够及时，英文原版通常更清晰，也能保证术语一致。地址：</p><blockquote><p><a href="https://docs.espressif.com/projects/esp-idf/en/v5.4.1/esp32s3/api-reference/peripherals/uart.html">https://docs.espressif.com/projects/esp-idf/en/v5.4.1/esp32s3/api-reference/peripherals/uart.html</a></p></blockquote><p><strong>3.利用社区资料和博客</strong><br> 例如在 ESP32 中文社区、掘金、知乎、ESP32 论坛里，很多大佬会写「如何从零撸 UART 驱动」这样带有完整注释的教程，配图讲原理，帮助理解底层细节。</p><p><strong>4.梳理宏和结构体</strong><br> 在本地建个笔记，把常用的 <code>uart_config_t</code>、<code>uart_event_t</code>、<code>uart_isr_handle_t</code> 等结构体和宏（如 <code>UART_NUM_1</code>、<code>UART_TX_FIFO_EMPTY_INT_ENA_M</code>）抄一份表格，画成时序图或流程图，加深印象。</p><p><strong>5.结合芯片 TRM 看硬件原理</strong><br> ESP32-S3 的技术参考手册（TRM）里对 UART 硬件寄存器、FIFO、DMA 通道有更详细的电路和状态机描述，配合 API 调用看，能把软件控制和硬件行为对应起来。</p><p><strong>6.动手实验、加入调试</strong><br> 在代码里加上 <code>ESP_LOGI()</code> 打印，或者接上逻辑分析仪&#x2F;示波器，看寄存器写入、TX&#x2F;RX 信号波形。实操往往比 “纯读文档” 更能帮你串起知识点。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>todolist网站搭建</title>
      <link href="/2025/06/08/157-todolist-wang-zhan-da-jian/"/>
      <url>/2025/06/08/157-todolist-wang-zhan-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h1 id="搭建在服务器上"><a href="#搭建在服务器上" class="headerlink" title="搭建在服务器上"></a>搭建在服务器上</h1><h1 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h1><h1 id="配置ssl证书"><a href="#配置ssl证书" class="headerlink" title="配置ssl证书"></a>配置ssl证书</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>续流二极管</title>
      <link href="/2025/06/06/156-xu-liu-er-ji-guan/"/>
      <url>/2025/06/06/156-xu-liu-er-ji-guan/</url>
      
        <content type="html"><![CDATA[<h1 id="续流二极管"><a href="#续流二极管" class="headerlink" title="续流二极管"></a>续流二极管</h1><p>像<code>风扇、电机、蜂鸣器</code>等感性负载（线圈类）在断电时容易产生高压反向电动势，这个时候需要续流二极管缓慢释放电压。</p><h1 id="续流二极管的特点"><a href="#续流二极管的特点" class="headerlink" title="续流二极管的特点"></a>续流二极管的特点</h1><p>1）续流二极管具有<code>反向击穿电压（VRM）较高</code>的特点。当电感器中的反向电压超过续流二极管的VRM时，续流二极管就会进入导通状态，形成一个低阻抗通道，使电流继续流动。</p><p>2）续流二极管具有低正向电压降（VF）和低开启时间（ton），这使得它能够<code>迅速响应电感器的能量释放</code>，并提供可靠的续流路径。</p><p>3）续流二极管还具有低反向恢复时间（trr），这意味着它可以快速关闭并准备下一个周期的操作。</p><h2 id="1N4007与B5819W"><a href="#1N4007与B5819W" class="headerlink" title="1N4007与B5819W"></a>1N4007与B5819W</h2><p><strong>1N4007</strong> 是经典的通用整流硅二极管，属于1N400x系列（1N4001～1N4007）中耐压最高的一款，主要用于50&#x2F;60 Hz电源整流与一般低频逆变器中<a href="https://www.mouser.com/datasheet/2/149/1N4007-888322.pdf?srsltid=AfmBOoq8j_y0LO_I3F_SVPh3cULQA53CVHa-jxRnH4Ojw3A5PDxrgo_F&utm_source=chatgpt.com">mouser.com</a><a href="https://www.alldatasheet.com/view.jsp?Searchword=1n4007&utm_source=chatgpt.com">alldatasheet.com</a>。<br> <strong>B5819W</strong> 则是一款表面贴装肖特基势垒二极管，型号为B5817W～B5819W系列中的40 V版本（B5819W），其标称平均正向整流电流1 A、最大反向电压40 V，常用于低压高频逆变、电源免费轮（free‐wheeling）以及极性保护等场景[smc-diodes.com](<a href="https://www.smc-diodes.com/propdf/B5817W-B5819W">https://www.smc-diodes.com/propdf/B5817W-B5819W</a> N1752 REV.-.pdf?utm_source&#x3D;chatgpt.com)<a href="https://www.mccsemi.com/products/diodes/small-signal-schottky-diodes/B5819W?utm_source=chatgpt.com">mccsemi.com</a>。</p><h2 id="主要电气参数对比"><a href="#主要电气参数对比" class="headerlink" title="主要电气参数对比"></a>主要电气参数对比</h2><table><thead><tr><th>参数</th><th>1N4007</th><th>B5819W (肖特基)</th><th>说明</th></tr></thead><tbody><tr><td>最大重复反向电压 VRRM</td><td>1000 V</td><td>40 V</td><td>1N4007适合高压整流，B5819W适合低压高频应用</td></tr><tr><td>平均整流正向电流 IF(AV)</td><td>1 A</td><td>1 A</td><td>两者额定电流相同，但使用场景不同</td></tr><tr><td>峰值正向浪涌电流 IFSM</td><td>30 A (8.3 ms 单半波)</td><td>25 A (8.3 ms 单波)</td><td>都支持几十安的浪涌，但1N4007稍高<a href="https://www.mouser.com/datasheet/2/149/1N4007-888322.pdf?srsltid=AfmBOoq8j_y0LO_I3F_SVPh3cULQA53CVHa-jxRnH4Ojw3A5PDxrgo_F&utm_source=chatgpt.com">mouser.com</a><a href="https://semiware.com/news/wp-content/uploads/2024/11/B5819W-schottky-diode-datasheet-1.pdf?utm_source=chatgpt.com">semiware.com</a></td></tr><tr><td>正向压降 VF</td><td>~1.1 V (@ IF&#x3D;1 A)</td><td>0.60 V (max) (@ IF&#x3D;1 A)</td><td>B5819W正向压降显著低于1N4007，损耗更小<a href="https://www.mouser.com/datasheet/2/149/1N4007-888322.pdf?srsltid=AfmBOoq8j_y0LO_I3F_SVPh3cULQA53CVHa-jxRnH4Ojw3A5PDxrgo_F&utm_source=chatgpt.com">mouser.com</a>[smc-diodes.com](<a href="https://www.smc-diodes.com/propdf/B5817W-B5819W">https://www.smc-diodes.com/propdf/B5817W-B5819W</a> N1752 REV.-.pdf?utm_source&#x3D;chatgpt.com)</td></tr><tr><td>反向漏电流 IR</td><td>典型5 μA (@ VR&#x3D;1000 V, Ta&#x3D;25 °C)</td><td>最大1 mA (@ VR&#x3D;40 V, Ta&#x3D;25 °C)</td><td>肖特基漏电比普通硅整流高几个数量级<a href="https://www.mouser.com/datasheet/2/149/1N4007-888322.pdf?srsltid=AfmBOoq8j_y0LO_I3F_SVPh3cULQA53CVHa-jxRnH4Ojw3A5PDxrgo_F&utm_source=chatgpt.com">mouser.com</a>[smc-diodes.com](<a href="https://www.smc-diodes.com/propdf/B5817W-B5819W">https://www.smc-diodes.com/propdf/B5817W-B5819W</a> N1752 REV.-.pdf?utm_source&#x3D;chatgpt.com)</td></tr><tr><td>典型结电容 CT</td><td>15 pF (@ VR&#x3D;4 V, f&#x3D;1 MHz, Ta&#x3D;25 °C)</td><td>120 pF (@ VR&#x3D;4 V, f&#x3D;1 MHz, Ta&#x3D;25 °C)</td><td>肖特基结电容较大，不利于超高频应用，但对一般开关足够<a href="https://www.mouser.com/datasheet/2/149/1N4007-888322.pdf?srsltid=AfmBOoq8j_y0LO_I3F_SVPh3cULQA53CVHa-jxRnH4Ojw3A5PDxrgo_F&utm_source=chatgpt.com">mouser.com</a>[smc-diodes.com](<a href="https://www.smc-diodes.com/propdf/B5817W-B5819W">https://www.smc-diodes.com/propdf/B5817W-B5819W</a> N1752 REV.-.pdf?utm_source&#x3D;chatgpt.com)</td></tr><tr><td>典型反向恢复时间 Trr</td><td>~30 μs （慢恢复类型）</td><td>极短，几乎无反向恢复时间</td><td>1N4007为慢恢复二极管，B5819W为肖特基，反向恢复极快</td></tr><tr><td>结温范围 Tj</td><td>–55 ℃ ～ +175 ℃</td><td>–50 ℃ ～ +125 ℃</td><td>1N4007允许更高结温，但B5819W为表贴，实际散热受限</td></tr></tbody></table><blockquote><p><strong>反向恢复时间</strong>：</p><ul><li>从1N4007典型性能曲线可看出，其反向恢复时间大约为几十微秒（见图示）<a href="https://www.mouser.com/datasheet/2/149/1N4007-888322.pdf?srsltid=AfmBOoq8j_y0LO_I3F_SVPh3cULQA53CVHa-jxRnH4Ojw3A5PDxrgo_F&utm_source=chatgpt.com">mouser.com</a>；</li><li>肖特基二极管B5819W的反向恢复时间非常快，属于“零恢复时间”特性，适合开关电源等高频场合<a href="https://semiware.com/news/wp-content/uploads/2024/11/B5819W-schottky-diode-datasheet-1.pdf?utm_source=chatgpt.com">semiware.com</a>。</li></ul></blockquote><h2 id="典型应用场景对比"><a href="#典型应用场景对比" class="headerlink" title="典型应用场景对比"></a>典型应用场景对比</h2><ol><li><strong>1N4007 适用场景</strong><ul><li>高压电源整流：利用其1000 V耐压，适合50&#x2F;60 Hz桥式整流、逆变器保护等<a href="https://www.mouser.com/datasheet/2/149/1N4007-888322.pdf?srsltid=AfmBOoq8j_y0LO_I3F_SVPh3cULQA53CVHa-jxRnH4Ojw3A5PDxrgo_F&utm_source=chatgpt.com">mouser.com</a>；</li><li>高频率要求不高的场合：由于反向恢复慢，不建议用于&gt;几十kHz开关电源高频整流。</li><li><strong>示例</strong>：家电电源适配器整流桥、逆变器免费轮二极管、极性保护等。</li></ul></li><li><strong>B5819W 适用场景</strong><ul><li>低压开关电源：40 V耐压足以承担常见12 V、24 V输出的二极管自由切换；</li><li>高频逆变与极性保护：其低正向压降减少功耗、高速恢复减少开关损耗；</li><li>SMT电子模块：板载空间有限但要求高效整流或续流。</li><li><strong>示例</strong>：笔记本适配器二次侧整流、LED恒流驱动电源续流、降压转换器输出整流。</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>若项目需要<strong>高电压（可达1000 V）</strong>、<strong>低成本插件式整流</strong>、或工作在<strong>低频环境</strong>，且对正向损耗没有苛刻要求，1N4007为首选；</li><li>若需求是<strong>40 V以内的低压整流</strong>、<strong>高频快速切换</strong>、注重<strong>低正向压降和高速恢复</strong>，则B5819W更合适。</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.bom2buy.com/blog/4507.html">续流二极管有何作用?为什么会有这些作用?-bom2buy</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>windows环境下Wireshark抓取802.11数据包</title>
      <link href="/2025/06/06/155-wireshark-de-shi-yong-fang-fa/"/>
      <url>/2025/06/06/155-wireshark-de-shi-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a><a href="https://www.wireshark.org/docs/wsug_html_chunked/ChCapPrerequisitesSection.html">wireshark</a></h1><p>常见的陷阱：</p><ul><li>您可能需要特殊权限才能开始实时捕获。</li><li>您需要选择正确的网络接口来捕获数据包数据。</li><li>您需要在网络中的正确位置进行捕获，以查看您 想看看。</li></ul><p><strong>查看网卡是否支持Monitor mode</strong></p><p>CMD中输入命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">netsh wlan show drivers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\Administrator&gt;netsh wlan show drivers接口名称: WLAN    驱动程序                  : Realtek 8822CE Wireless LAN 802.11ac PCI-E NIC    供应商                    : Realtek Semiconductor Corp.    提供程序                  : Realtek Semiconductor Corp.    日期                      : 2022&#x2F;6&#x2F;24    版本                      : 2024.10.138.0    INF 文件                  : oem207.inf    类型                      : 本机 WLAN 驱动程序    支持的无线电类型          : 802.11n 802.11g 802.11b 802.11ac 802.11n 802.11a    支持 FIPS 140-2 模式: 是    支持 802.11w 管理帧保护 : 是    支持的承载网络  : 否    基础结构模式中支持的身份验证和密码:                                开放式             无                                WPA2 - 个人       CCMP                                开放式             WEP-40bit                                开放式             WEP-104 位                                开放式             WEP                                WPA - 企业        TKIP                                WPA - 个人        TKIP                                WPA2 - 企业       TKIP                                WPA2 - 个人       TKIP                                WPA - 企业        CCMP                                WPA - 个人        CCMP                                WPA2 - 企业       CCMP                                WPA3 - 个人       CCMP                                WPA3 - 企业       GCMP-256                                OWE             CCMP                                供应商定义的          TKIP                                供应商定义的          CCMP                                供应商定义的          供应商定义的                                供应商定义的          供应商定义的                                WPA2 - 企业       供应商定义的                                WPA2 - 企业       供应商定义的                                供应商定义的          供应商定义的                                供应商定义的          供应商定义的    支持的无线显示器: 是 (图形驱动程序: 是，WLAN 驱动程序: 是)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没显示<code>支持的网络监视模式: 是</code></p><p>不支持 monitor mode</p><img src="/2025/06/06/155-wireshark-de-shi-yong-fang-fa/image-20250607094336183.png" class="" title="image-20250607094336183"><p><strong>打算使用外置网卡</strong></p><p>- </p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Wireshark-是否必须搭配-Npcap-使用"><a href="#Wireshark-是否必须搭配-Npcap-使用" class="headerlink" title="Wireshark 是否必须搭配 Npcap 使用"></a>Wireshark 是否必须搭配 Npcap 使用</h2><p>是的，在 Windows 下 <strong>必须使用 Npcap</strong>，因为：</p><blockquote><ul><li><strong>Npcap 是 Wireshark 抓包的底层驱动库</strong>（基于 WinPcap，但已优化、现代化）。</li><li>它负责拦截网络接口上的原始数据包。</li><li><strong>WinPcap 已停止维护</strong>，且不支持 Windows 10&#x2F;11 的新特性，如 Loopback 抓包、监控模式（虽然多数网卡不支持 monitor mode）。</li></ul></blockquote><p>使用 <strong>Npcap 最新版本</strong>：<a href="https://nmap.org/npcap/">https://nmap.org/npcap/</a></p><ul><li>安装时勾选：<ul><li>✅ <em>“Support raw 802.11 traffic”</em></li><li>✅ <em>“Install Npcap in WinPcap API-compatible Mode”</em></li></ul></li></ul><h2 id="可连接WiFi-无法抓包"><a href="#可连接WiFi-无法抓包" class="headerlink" title="可连接WiFi,无法抓包"></a>可连接WiFi,无法抓包</h2><p>首先wifi beacon数据帧是802.11协议的，包括一些wifi热点名称什么的，那么我的电脑既然能看到wifi名称，并且连接使用并进行通信，为什么无法抓到包呢</p><p>802.11 数据帧包括 Wi-Fi Beacon 帧</p><h3 id="什么是-802-11-帧？"><a href="#什么是-802-11-帧？" class="headerlink" title="什么是 802.11 帧？"></a>什么是 802.11 帧？</h3><p>Wi-Fi 协议层是基于 <strong>IEEE 802.11</strong> 标准的，它定义了：</p><ul><li><strong>管理帧</strong>（例如：Beacon、Probe、Authentication、Association）</li><li><strong>控制帧</strong>（例如：ACK、RTS&#x2F;CTS）</li><li><strong>数据帧</strong>（例如：携带 IP&#x2F;TCP 等信息的数据）</li></ul><p>其中：</p><h3 id="Beacon-帧（信标帧）"><a href="#Beacon-帧（信标帧）" class="headerlink" title="Beacon 帧（信标帧）"></a>Beacon 帧（信标帧）</h3><ul><li>每个 Wi-Fi 热点（AP）大约每 100 毫秒发送一次；</li><li>包含：SSID（Wi-Fi 名称）、BSSID（MAC 地址）、信道、加密方式等；</li><li>是 <strong>广播帧</strong>，不需要关联即可接收。</li></ul><h3 id="❓为什么能连上-Wi-Fi，却抓不到这些帧？"><a href="#❓为什么能连上-Wi-Fi，却抓不到这些帧？" class="headerlink" title="❓为什么能连上 Wi-Fi，却抓不到这些帧？"></a>❓为什么能连上 Wi-Fi，却抓不到这些帧？</h3><p>这是<strong>核心问题</strong>，答案在于 <strong>网卡的工作模式不同</strong>：</p><p>✅ 你的笔记本能看到 Wi-Fi 名称（SSID）是因为：</p><blockquote><p>网卡处于 <strong>管理模式（managed mode）</strong>，这是默认联网用的模式。</p></blockquote><p>它只处理：</p><ul><li>跟你连接的 AP 之间的通信；</li><li>忽略绝大多数广播帧和其他 Wi-Fi 流量；</li><li>且操作系统对网卡驱动做了 <strong>封装处理</strong>，你看到的是以太网数据，而不是原始 802.11 帧。</li></ul><h3 id="抓不到-Beacon-帧："><a href="#抓不到-Beacon-帧：" class="headerlink" title="抓不到 Beacon 帧："></a>抓不到 Beacon 帧：</h3><ol><li><strong>你的无线网卡没有进入“监控模式（Monitor Mode）”</strong><ul><li>Monitor Mode 是一种“旁路监听”状态，可以接收<strong>任何信道、任何源头</strong>发出的 Wi-Fi 帧；</li><li>它不会像 Managed Mode 那样只接收与自己有关的帧。</li></ul></li><li><strong>Windows 驱动（如 Realtek）屏蔽了原始 Wi-Fi 帧访问权限</strong><ul><li>Windows 网络栈屏蔽了 PHY 层和 MAC 层的访问；</li><li>所以 Wireshark 默认只抓到封装后的 IP&#x2F;TCP&#x2F;HTTP，而看不到 Beacon、Probe 等原始帧。</li></ul></li></ol><hr><blockquote><p><em>驱动或者操作系统对底层进行了屏蔽和封装</em>*</p></blockquote><h1 id="可用芯片"><a href="#可用芯片" class="headerlink" title="可用芯片"></a>可用芯片</h1><p><a href="https://github.com/morrownr/USB-WiFi">morrownr&#x2F;USB-WiFi：适用于 Linux 的 USB WiFi 适配器信息</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/zzwwhhpp/article/details/113077747?ops_request_misc=%7B%22request_id%22:%223f842fadafd77f474a9d333be409a22c%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=3f842fadafd77f474a9d333be409a22c&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-113077747-null-null.142%5Ev102%5Epc_search_result_base2&utm_term=wireshark&spm=1018.2226.3001.4187">网络分析工具——WireShark的使用（超详细）-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/711435039">Windows下使用USB网卡捕获6GHz报文（自编程序&#x2F;mt7921网卡） - 知乎</a></p><p>⚠️:这个讲的很好<a href="https://www.bilibili.com/opus/939200435887013909">Windows 上的 Wireshark 抓包教程 - 哔哩哔哩</a></p><p><a href="https://blog.csdn.net/DontDash/article/details/140425401">Windows下使用USB网卡抓WiFi报文&#x2F;空口抓包（虚拟机+Wireshark抓包）_winsniffer-CSDN博客</a></p><blockquote><p>空口抓包需要开启网卡监听模式，而这个操作又需要网卡芯片与驱动支持。Windows空口抓包的难点在于Windows下的网卡<code>原生驱动</code>都是不支持开启网卡监听模式的，而Linux下的原生驱动大多支持开启网卡监听模式，如果能将Linux中的驱动“移植”到Windows系统中，那就能很好解决这个问题。<br>根据此构想，笔者实现了一种简易、低成本、适用性广的Windows下空口抓包方案。<strong>通过<a href="https://zhida.zhihu.com/search?content_id=245643816&content_type=Article&match_order=1&q=VMware%E8%99%9A%E6%8B%9F%E6%9C%BA&zhida_source=entity">VMware虚拟机</a>启用一个Kali虚拟机，在Kali下开启无线网卡的监听模式，并使用rpcapd暴露虚拟机种的网卡接口，最后在Windows下使用Wireshark的远程抓包功能即可实现空口抓包。</strong></p></blockquote><p><a href="https://www.aneasystone.com/archives/2016/08/wireless-analysis-one-monitoring.html">实战无线网络分析（篇一）无线监听 - aneasystone’s blog</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>蜂鸣器</title>
      <link href="/2025/06/06/154-feng-ming-qi/"/>
      <url>/2025/06/06/154-feng-ming-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h1><p>响度与电压成正比</p><p>音色与频率呈正比，频率越高，声音越尖</p><h3 id="有源蜂鸣器-震荡源"><a href="#有源蜂鸣器-震荡源" class="headerlink" title="有源蜂鸣器(震荡源)"></a>有源蜂鸣器(震荡源)</h3><p>发声原理:振荡器产生音频信号电流通过线圈,产生磁场,电磁线圈和磁场一起起作用使振动磨片周期震动</p><blockquote><p>电生磁,使震动膜片震动</p></blockquote><p><code>需要大电流</code>,所以会连接一个三极管因为三极管有开关和放大作用,51单片机只有10ma的电流</p><h3 id="无源蜂鸣器"><a href="#无源蜂鸣器" class="headerlink" title="无源蜂鸣器"></a>无源蜂鸣器</h3><h1 id="蜂鸣器驱动电路"><a href="#蜂鸣器驱动电路" class="headerlink" title="蜂鸣器驱动电路"></a>蜂鸣器驱动电路</h1><h2 id="NPN"><a href="#NPN" class="headerlink" title="NPN"></a>NPN</h2><img src="/2025/06/06/154-feng-ming-qi/1749198164271.png" class="" width="1749198164271"><img src="/2025/06/06/154-feng-ming-qi/1749198179112.png" class="" width="1749198179112"><p>图一比图二更响亮</p><h2 id="完善电路"><a href="#完善电路" class="headerlink" title="完善电路"></a>完善电路</h2><p>续流二极管：蜂鸣器本质上是一个感性元件，其电流不能瞬变，因此必须有一个续流二极管提供续流。否则，在蜂鸣器两端会产生几十伏的尖峰电压，可能损坏三极管，并干扰整个电路系统的其他部分。</p><p>滤波电容： 作用是滤波，滤除蜂鸣器电流对其他部分的影响，也可以改善电源的交流阻抗，如果可能，最好是再并联一个220uF的电解电容。</p><h2 id="更新电路"><a href="#更新电路" class="headerlink" title="更新电路"></a>更新电路</h2><p>发现上电时，蜂鸣器会轻响一声，于是加上下拉电阻。</p><p><strong>R14是限流电阻，限制的是谁的电流</strong></p><blockquote><p>电路的电流取决于当前电压下的负载,由电源提供的电压，以及整个电路中的总等效电阻（即“负载”）共同决定的。</p></blockquote><p><strong>c的电流会流到b吗</strong></p><blockquote><p>不会，I_B控制三极管，从E留出，I_C是被控制的电流，是流向负载的电流，这两个电流都汇合到发射极，但它们是两个独立的电流回路。</p><p>⚠️：三极管的特性就是用小的基极电流来控制大的集电极电流。</p></blockquote><p>另外，下拉电阻为10k，当gpio4为高电平3.3v时，三极管导通，然后vbe&#x3D;0.7v，这时ibe&#x3D;0.07ma，我不理解的是为什么接入地了还能正常保证高电平，我总是弄不懂上拉下拉</p><p>我们来分析当GPIO4输出高电平3.3V时的情况：</p><p><strong>R25 (10kΩ) 的作用：</strong></p><p>当GPIO4输出高电平3.3V时，R25实际上是<strong>并联在R14和三极管基极之间，与三极管基极-发射极PN结和R14串联的回路形成一个分流回路</strong>。</p><ul><li><strong>电压分配：</strong><ul><li>GPIO4输出3.3V。</li><li>Q3基极-发射极之间的PN结导通电压 (VBE_on) 大约是0.7V。</li><li>所以，R14两端的电压是 VR14&#x3D;VGPIO4−VBE_on&#x3D;3.3V−0.7V&#x3D;2.6V。</li><li>通过R14流向基极的电流 (IB) 是 IB&#x3D;VR14&#x2F;R14&#x3D;2.6V&#x2F;1kΩ&#x3D;2.6mA。</li></ul></li><li><strong>R25对高电平的影响：</strong><ul><li>当GPIO4输出3.3V时，Q3的基极电压被钳位在约0.7V (相对于地)。</li><li>所以，R25两端的电压是Q3基极的电压，即大约0.7V。</li><li>流过R25的电流 (IR25) 是 IR25&#x3D;VBE_on&#x2F;R25&#x3D;0.7V&#x2F;10kΩ&#x3D;0.07mA。</li></ul></li><li><strong>GPIO4总输出电流：</strong><ul><li>GPIO4需要提供的总电流是流过R14和流过R25电流之和：IGPIO4_total&#x3D;IB+IR25&#x3D;2.6mA+0.07mA&#x3D;2.67mA。</li><li>这个电流通常在GPIO4的允许范围内。</li></ul></li></ul><p><strong>所以，当GPIO4是高电平（主动输出电压）时，R25确实会分走一部分电流到地，但这并不会阻止GPIO4输出高电平，也不会阻止三极管导通。</strong> R25的作用是当GPIO4<strong>不输出高电平</strong>，而是处于<strong>低电平或高阻态</strong>时才发挥关键作用。</p><img src="/2025/06/06/154-feng-ming-qi/1752733476355.png" class="" width="1752733476355"><h2 id="PNP"><a href="#PNP" class="headerlink" title="PNP"></a>PNP</h2><p>PNP三极管是高电平截止，低电平导通</p><img src="/2025/06/06/154-feng-ming-qi/1749198065262.png" class="" width="1749198065262"><img src="/2025/06/06/154-feng-ming-qi/1749198078912.png" class="" width="1749198078912"><h2 id="贴片电容"><a href="#贴片电容" class="headerlink" title="贴片电容"></a>贴片电容</h2><p><strong>贴片电容</strong>102等于1NF，103等于10NF， 104等于100NF，105等于1UF，106等于10UF</p><p>102，即10×102 pF&#x3D;1nF;</p><p>103，即10×103 pF&#x3D;10nF;</p><p>104，即10×104 pF&#x3D;100nF;</p><p>105，即10×105 pF&#x3D;1000nF&#x3D;1uF;</p><p>106，即10×106 pF&#x3D;10000nF&#x3D;10uF</p><p>10u+是10u钽电容</p><p>电阻同理,102就是10*10平方&#x3D;1000Ω&#x3D;1k</p><p><a href="https://www.semiee.com/file/TWGMC/TWGMC-SI2301.pdf">https://www.semiee.com/file/TWGMC/TWGMC-SI2301.pdf</a>)</p><h1 id="上拉-下拉电阻"><a href="#上拉-下拉电阻" class="headerlink" title="上拉&#x2F;下拉电阻"></a>上拉&#x2F;下拉电阻</h1><p>上拉电阻和下拉电阻都是为了在没有主动信号输入时，为某个引脚提供一个<strong>确定的默认电压状态</strong>，防止引脚电压浮动，导致电路误动作。</p><p><strong>高阻态 (High Impedance&#x2F;Hi-Z):</strong> 引脚处于一种<strong>断开</strong>的状态。它既不主动输出高电平，也不主动输出低电平。此时，引脚的<strong>输出电阻非常大</strong>（理论上接近无限大，所以称作“高阻”）。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxNTIzOTcyMw==&mid=2650219414&idx=1&sn=b0adbcdb979af6f00d57a3c7b63b78ba&chksm=83849cd2b4f315c4f65647da79da864effbe686f5dd38fb4936f0b9c4e1a712546aab0cbecca&scene=27">蜂鸣片，蜂鸣器的原理以及驱动电路的个人理解</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Arduino安装Ameba开发板</title>
      <link href="/2025/06/03/153-arduino-an-zhuang-ameba-kai-fa-ban/"/>
      <url>/2025/06/03/153-arduino-an-zhuang-ameba-kai-fa-ban/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Arduino IDE 2.3.6</li><li>本地代理127.0.0.1:7890</li><li>proxfier</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>SDK<a href="https://github.com/Ameba-AIoT/ameba-arduino-d?tab=readme-ov-file">Ameba-AIoT&#x2F;ameba-arduino-d： AmebaD Arduino 第三方包 SDK</a></p><p>添加链接(文件-&gt;首选项-&gt;开发版地址)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">https:&#x2F;&#x2F;github.com&#x2F;Ameba-AIoT&#x2F;ameba-arduino-d&#x2F;raw&#x2F;master&#x2F;Arduino_package&#x2F;package_realtek_amebad_index.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>报错</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Some indexes could not be updated. Get &quot;https:&#x2F;&#x2F;github.com&#x2F;Ameba-AIoT&#x2F;ameba-arduino-d&#x2F;raw&#x2F;master&#x2F;Arduino_package&#x2F;package_realtek_amebad_index.json&quot;: dial tcp 20.205.243.166:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.: https:&#x2F;&#x2F;github.com&#x2F;Ameba-AIoT&#x2F;ameba-arduino-d&#x2F;raw&#x2F;master&#x2F;Arduino_package&#x2F;package_realtek_amebad_index.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个开启本地全局代理一般可以解决</p><p>然后打开开发版管理器,搜索<code>**ameba**</code>安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">平台安装失败：&#39;Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz):3.1.8&#39; 2 UNKNOWN: Get &quot;https:&#x2F;&#x2F;github.com&#x2F;ambiot&#x2F;ambd_arduino&#x2F;raw&#x2F;master&#x2F;Arduino_package&#x2F;release&#x2F;ameba_d_toolchain_windows-1.0.1.tar.bz2&quot;: read tcp 192.168.71.92:63610-&gt;20.205.243.166:443: wsarecv: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>原因分析</strong>：</p><ol><li><strong>Arduino IDE（尤其是 2.x 版）不会自动使用 Windows 系统设置里的“代理”</strong>。即便你在 Windows 设置 → 网络和 Internet → 代理 中把“手动设置代理服务器”打开，写了 <code>127.0.0.1:10808</code>（V2Ray 本地 SOCKS5&#x2F;HTTP 端口），IDE 并不会自动去读取这块设置。</li><li><strong>当你用 Proxifier、Clash 这类“进程级拦截”软件时，如果配置有误，Arduino 进程的网络流量也可能没有被拦截到代理</strong>。常见误区包括：<ul><li>进程名称（Applications）写错了：例如 Proxifier 规则里写成 <code>&quot;arduino ide.exe&quot;</code>，但实际 IDE 进程是 <code>arduino.exe</code>，两者不匹配，拦截不到。</li><li>DNS 请求没有走代理：默认情况下 Proxifier 是让 Windows 本地先做 DNS 解析，从而把 <code>raw.githubusercontent.com</code> 解析到一个 IP。如果该 IP 无法直连（被屏蔽或限速），就会出现 “no data of the requested type” 或 “lookup … failed” 的错误。</li><li>规则优先级排错：如果“默认（Default）”规则比 “Arduino” 规则排在更前面，所有流量都走“Direct”，就根本不会走代理。</li></ul></li></ol><h2 id="Proxifier"><a href="#Proxifier" class="headerlink" title="Proxifier"></a>Proxifier</h2><p>Proxifier 是一款在 Windows 和 macOS 平台上常用的网络代理工具，其主要功能是将系统中所有（或指定）应用程序的网络连接“强制”通过一个或多个代理服务器进行转发。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Profile-&gt;Proxy Server-&gt;配置本地代理端口(代理软件内可以看到)</p><img src="/2025/06/03/153-arduino-an-zhuang-ameba-kai-fa-ban/1748932943075.png" class="" width="1748932943075"><p>在rule里面设置过代理的应用</p><img src="/2025/06/03/153-arduino-an-zhuang-ameba-kai-fa-ban/1748933004753.png" class="" width="1748933004753"><img src="/2025/06/03/153-arduino-an-zhuang-ameba-kai-fa-ban/1748933056282.png" class="" width="1748933056282"><p><strong>然后继续尝试安装</strong></p><p>DNS报错</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">平台安装失败：&#39;Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz):3.1.8&#39; 2 UNKNOWN: Get &quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Ameba-AIoT&#x2F;ameba-arduino-d&#x2F;master&#x2F;Arduino_package&#x2F;release&#x2F;ameba_d_toolchain_windows-1.0.1.tar.bz2&quot;: dial tcp: lookup raw.githubusercontent.com: getaddrinfow: The requested name is valid, but no data of the requested type was found.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="DNS-解析依旧本地化，没走到代理服务器"><a href="#DNS-解析依旧本地化，没走到代理服务器" class="headerlink" title="DNS 解析依旧本地化，没走到代理服务器"></a>DNS 解析依旧本地化，没走到代理服务器</h3><ul><li><strong>问题表现</strong>：错误信息里写到 “lookup raw.githubusercontent.com: getaddrinfow: The requested name is valid, but no data of the requested type was found.” 这实际上是一个 DNS 解析层面的问题：<ul><li>Windows 本地 DNS 未能正确解析 <code>raw.githubusercontent.com</code>，可能解析到了一个被屏蔽或根本没有 A 记录／AAAA 记录的结果。</li><li>由于 DNS 解析没有经过代理，IDE 拿到错误的 IP，或者根本没有 IP，就直接连不通。</li></ul></li><li><strong>原因分析</strong>：即便你某个代理软件（Clash&#x2F;Proxifier&#x2F;V2RayN）已经启动，只要没有设置“DNS 走代理”，默认情况下 DNS 查询还是走本地系统，外网 DNS 解析失败就导致 IDE 进一步发 TCP 请求时直接超时。</li></ul><blockquote><p>双击窗口右下角DNS,取消第一个,勾选第二个</p><img src="/2025/06/03/153-arduino-an-zhuang-ameba-kai-fa-ban/1748933152898.png" class="" width="1748933152898"></blockquote><p>安装完成!还顺便把esp32的包更到最新了,over</p><blockquote><p>⚠️：这个软件不用时需要关掉,否则容易出现ssh远程服务器失败,或者无法上网的情况</p><p>记得关掉arduino 首选项里的代理</p></blockquote><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.xiaoz.org/archives/20785">如何使用Proxifier实现应用级代理：一步步教程 - 小z博客</a></p><p><a href="https://xz.aliyun.com/news/12613">渗透必备：使用Proxifier玩转代理-先知社区</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nezha探针搭建(V1.12.4)</title>
      <link href="/2025/06/02/152-nezha-tan-zhen-da-jian/"/>
      <url>/2025/06/02/152-nezha-tan-zhen-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="https://nezha.wiki/guide/dashboard.html">安装 Dashboard | 哪吒服务器监控</a></p><p>按照官方文档安装完之后，发现德国的服务器延迟太高，访问速度慢，决定套cdn</p><h1 id="反代"><a href="#反代" class="headerlink" title="反代"></a>反代</h1><p>又由于该网站默认端口为8008,所以无法直接套cdn,需要反代<a href="https://haxiox.github.io/2024/02/05/84l-nginx-fan-xiang-dai-li/">🔥Nginx反向代理 | 南北的猫</a></p><p>当前地址</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http:&#x2F;&#x2F;dashboard.example.com:8008&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://nezha.wiki/guide/q3.html">Dashboard 反向代理配置 | 哪吒服务器监控</a></p><p>我没有配置<code>grpc</code>与<code>weibsocket</code></p><ol><li>安装<code>nginx</code></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt updatesudo apt install -y nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.安装证书</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt install -y certbot python3-certbot-nginxsudo certbot certonly --nginx \  -d 域名\  --agree-tos --no-eff-email -m 邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>记下默认位置</p><blockquote><p>Successfully received certificate.<br>Certificate is saved at: &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;monitor.mortal.eu.org&#x2F;fullchain.pem<br>Key is saved at:         &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;monitor.mortal.eu.org&#x2F;privkey.pem<br>vim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;nezha.conf</p></blockquote><p>3.编辑nezha nginx配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;nezha-dashboard.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 80;    server_name 域名;    # 强制所有 HTTP 访问跳转到 HTTPS    return 301 https:&#x2F;&#x2F;$host$request_uri;&#125;server &#123;    listen 443 ssl http2;    server_name 域名;    # --- SSL 证书路径（Let’s Encrypt 默认路径） ---    ssl_certificate     &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;域名&#x2F;fullchain.pem;    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;域名&#x2F;privkey.pem;    ssl_session_cache   shared:TLS:10m;    ssl_session_timeout 10m;    ssl_protocols       TLSv1.2 TLSv1.3;    ssl_ciphers         HIGH:!aNULL:!MD5;        # 如果你使用 Cloudflare，请根据 Cloudflare 文档适当修改下面两行：    # 例如启用真实客户端 IP，替换 X-Real-IP 为 CF-Connecting-IP    #set_real_ip_from  103.21.244.0&#x2F;22;   # Cloudflare IP 段示例    #real_ip_header    CF-Connecting-IP;    set_real_ip_from  103.21.244.0&#x2F;22;    set_real_ip_from  103.22.200.0&#x2F;22;    set_real_ip_from  103.31.4.0&#x2F;22;    set_real_ip_from  104.16.0.0&#x2F;13;    set_real_ip_from  104.24.0.0&#x2F;14;    set_real_ip_from  108.162.192.0&#x2F;18;    set_real_ip_from  131.0.72.0&#x2F;22;    set_real_ip_from  141.101.64.0&#x2F;18;    set_real_ip_from  162.158.0.0&#x2F;15;    set_real_ip_from  172.64.0.0&#x2F;13;    set_real_ip_from  173.245.48.0&#x2F;20;    set_real_ip_from  188.114.96.0&#x2F;20;    set_real_ip_from  190.93.240.0&#x2F;20;    set_real_ip_from  197.234.240.0&#x2F;22;    set_real_ip_from  198.41.128.0&#x2F;17;    set_real_ip_from  2400:cb00::&#x2F;32;    set_real_ip_from  2606:4700::&#x2F;32;    set_real_ip_from  2803:f800::&#x2F;32;    set_real_ip_from  2405:b500::&#x2F;32;    set_real_ip_from  2405:8100::&#x2F;32;    set_real_ip_from  2a06:98c0::&#x2F;29;    set_real_ip_from  2c0f:f248::&#x2F;32;    real_ip_header    CF-Connecting-IP;        location &#x2F; &#123;        # 反向代理到 Dashboard 服务所在的 HTTP 8008        proxy_pass         http:&#x2F;&#x2F;127.0.0.1:8008;        proxy_set_header   Host $host;        proxy_set_header   X-Real-IP $remote_addr;        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_http_version 1.1;        proxy_set_header   Connection &quot;&quot;;        # 防止 Websocket 断开，可加以下        proxy_set_header   Upgrade $http_upgrade;        proxy_set_header   Connection &quot;upgrade&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.cloudflare.com/zh-cn/ips/">clouflare官方IP 范围 | Cloudflare</a></p><p>4.链接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;nezha.conf &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;sudo nginx -t &amp;&amp; sudo systemctl reload nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="Agent-开机自启"><a href="#Agent-开机自启" class="headerlink" title="Agent 开机自启"></a>Agent 开机自启</h1><p>将 <code>nezha-agent</code> 放到系统可执行路径，并用 systemd 管理，让它开机自启并自动重启。</p><ol><li><p>创建服务文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sh -c &#39;cat &gt; &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;nezha-agent.service &lt;&lt; EOF<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>创建 systemd 单元文件</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[Unit]Description&#x3D;Nezha AgentAfter&#x3D;network.target[Service]Type&#x3D;simpleWorkingDirectory&#x3D;&#x2F;opt&#x2F;nezha&#x2F;agentExecStart&#x3D;&#x2F;opt&#x2F;nezha&#x2F;agent&#x2F;nezha-agent -c &#x2F;opt&#x2F;nezha&#x2F;agent&#x2F;config.ymlRestart&#x3D;always[Install]WantedBy&#x3D;multi-user.targetEOF&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>启动并启用开机自启</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable nezha-agentsystemctl start nezha-agent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>启动服务：<code>systemctl start nezha-agent</code></li><li>停止服务：<code>systemctl stop nezha-agent</code></li><li>重启服务：<code>systemctl restart nezha-agent</code></li><li>查看状态：<code>systemctl status nezha-agent</code></li></ul></li></ol><h2 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h2><p>Agent 配置文件位于：<code>/opt/nezha/agent/config.yml</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bat脚本</title>
      <link href="/2025/06/02/151-bat-jiao-ben/"/>
      <url>/2025/06/02/151-bat-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>bat文件<code>中文</code>会被当做命令执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">@rem ﻿@echo off@echo offREM &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;REM 文件名：utf8_test.bat (保存为 UTF-8 带 BOM)REM 功能：演示如何让 UTF-8 带 BOM 在 CMD 下既不乱码，也不报 BOM 相关错误REM 日期：2025-06-02REM &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;REM 切换到 UTF-8 代码页chcp 65001 &gt;nulecho 当前代码页: %CDP%echo.REM 正常输出一对中英文echo 中文示例：这是用 UTF-8 无 BOM 保存，也用 chcp 65001 切换后的中文echo English sample: This is an English test.echo.REM 故意“裸文字”测试测试裸中文会被当作命令执行if errorlevel 1 (    echo.    echo 错误：上一行“裸中文”被当作命令执行并失败。    echo 通常会看到：&#39;测试裸中文会被当作命令执行&#39; 不是内部或外部命令...)echo.pauseexit &#x2F;b 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>ps1</code>文件,powershell启动,就是没有<code>.bat</code>有感觉</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>夸克网盘自动签到</title>
      <link href="/2025/06/01/150-kua-ke-wang-pan-zi-dong-qian-dao/"/>
      <url>/2025/06/01/150-kua-ke-wang-pan-zi-dong-qian-dao/</url>
      
        <content type="html"><![CDATA[<h1 id="开源脚本"><a href="#开源脚本" class="headerlink" title="开源脚本"></a>开源脚本</h1><p><a href="https://github.com/Liu8Can/Quark_Auot_Check_In?tab=readme-ov-file">Liu8Can&#x2F;Quark_Auot_Check_In: 纯粹的夸克网盘自动签到领空间，托管到GitHub自动执行，一劳永逸。</a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li><p>使用proxypin手机端抓包软件</p></li><li><p>已经从存储安装CA证书（虽然我不知道他的作用）</p></li></ul><p>好的，现在我卡在了抓不到包这一步，没有账号了，明天再试试</p><blockquote><p>使用repable，安装证书后，抓到了，但是发现sign与vcode都是动态变量</p></blockquote><p>换了最新的一组键值，github action正常执行，我不明白</p><p>所以猜测作者获取了加密算法,也可能这些变化的sign与vcode在一段时间内都是有效的</p><h1 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h1><p>python复现失败，报错401</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>摸一下ipv6</title>
      <link href="/2025/06/01/149-mo-yi-xia-ipv6/"/>
      <url>/2025/06/01/149-mo-yi-xia-ipv6/</url>
      
        <content type="html"><![CDATA[<h1 id="本地ipv6配置"><a href="#本地ipv6配置" class="headerlink" title="本地ipv6配置"></a>本地ipv6配置</h1><p>我在网络-属性中看到</p><img src="/2025/06/01/149-mo-yi-xia-ipv6/image-20250601150154222.png" class="" title="image-20250601150154222"><p>然后我以为我有ipv6，经过<a href="https://www.test-ipv6.com/">IPv6 测试</a>后，发现本地IPv6地址可能只是链路本地地址（fe80::开头），这种地址无法访问互联网</p><p>需要全局单播地址才能连接外部IPv6服务器。</p><p>打开命令行，<code>ipconfig</code></p><p>发现</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">无线局域网适配器 WLAN:   连接特定的 DNS 后缀 . . . . . . . :   本地链接 IPv6 地址. . . . . . . . : fe80::9095:5329:2298:180c%3   IPv4 地址 . . . . . . . . . . . . : 192.168.31.78   子网掩码  . . . . . . . . . . . . : 255.255.255.0   默认网关. . . . . . . . . . . . . : 192.168.31.1隧道适配器 Teredo Tunneling Pseudo-Interface:   连接特定的 DNS 后缀 . . . . . . . :   IPv6 地址 . . . . . . . . . . . . : 2001隐藏   本地链接 IPv6 地址. . . . . . . . : fe80::2c16:1c7f:505c:8d62%13   默认网关. . . . . . . . . . . . . : ::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>主要问题：</strong></p><ol><li><strong>缺少原生IPv6支持</strong> - 你的WLAN适配器（主要网络连接）只有链路本地IPv6地址（fe80::开头），没有全局IPv6地址</li><li><strong>路由器不支持IPv6</strong> - 你的路由器（192.168.31.1）没有分配IPv6前缀给你的设备</li><li><strong>依赖Teredo隧道</strong> - 系统启用了Teredo隧道来提供IPv6连接，但这种方式不稳定</li></ol><p><strong>解决方案：</strong></p><p><strong>方法1：检查路由器设置</strong></p><ul><li>登录路由器管理界面（192.168.31.1）</li><li>查找”IPv6设置”或”高级设置”</li><li>启用IPv6功能（如果有的话）</li><li>联系ISP确认是否提供IPv6服务</li></ul><p><strong>方法2：优化Teredo隧道</strong> 以管理员身份运行命令提示符：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 重置Teredonetsh interface teredo set state disablednetsh interface teredo set state type&#x3D;defaultnetsh interface ipv6 reset# 重启网络服务ipconfig &#x2F;flushdns<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法3：测试当前IPv6连接</strong></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 测试Teredo是否工作ping -6 ipv6.google.comping -6 2001:4860:4860::8888# 检查路由netsh interface ipv6 show route<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>临时解决方案：</strong> 如果以上方法都不行，可以使用IPv6隧道服务（如Hurricane Electric的tunnel broker）来获得稳定的IPv6连接。</p><p>你可以先试试重置Teredo，然后测试能否ping通IPv6地址。</p><p>进入路由器的后台管理界面,打开ipv6配置后,<code>ipconfig</code></p><pre class="line-numbers language-none"><code class="language-none">无线局域网适配器 WLAN:   连接特定的 DNS 后缀 . . . . . . . :   IPv6 地址 . . . . . . . . . . . . : 2408:822f:1ab1:67c::255   IPv6 地址 . . . . . . . . . . . . : 2408:隐藏   临时 IPv6 地址. . . . . . . . . . : 2408:隐藏   本地链接 IPv6 地址. . . . . . . . : fe80::9095:5329:2298:180c%3   IPv4 地址 . . . . . . . . . . . . : 192.168.31.78   子网掩码  . . . . . . . . . . . . : 255.255.255.0   默认网关. . . . . . . . . . . . . : fe80::46f7:70ff:fe1e:9728%3                                       192.168.31.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Teredo隧道的作用：</strong> Teredo是微软开发的一种IPv6过渡技术，它的目的是让处于IPv4网络中的设备也能访问IPv6资源。</p><p><strong>为什么之前没开IPv6也有IPv6地址：</strong></p><ol><li>Windows默认启用Teredo<ul><li>Windows系统默认会启用Teredo隧道服务</li><li>即使你的路由器不支持IPv6，Teredo也会创建一个虚拟的IPv6连接</li><li>这就是你看到的<code>2001:0:2851:b9f0:2c16:1c7f:505c:8d62</code>这个地址</li></ul></li><li>Teredo的工作原理：<ul><li>将IPv6数据包封装在IPv4数据包中传输</li><li>通过微软的Teredo服务器中转</li><li>让你的设备获得一个公网IPv6地址（2001::&#x2F;32开头）</li></ul></li><li>链路本地地址（fe80::）：<ul><li>这是IPv6的基本功能，类似IPv4的169.254.x.x</li><li>即使没有路由器支持，网卡也会自动生成</li><li>只能在本地网段使用，无法访问互联网</li></ul></li></ol><p><strong>那么之前我有teredo的ipv6为什么无法连接ipv6的服务器和网站呢</strong></p><p>延迟\超时\屏蔽,总之Teredo不好用</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS</title>
      <link href="/2025/05/28/147-freertos/"/>
      <url>/2025/05/28/147-freertos/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h1><p>FreeRTOS是一个轻量级的实时操作系统，专为微控制器和小型嵌入式系统设计。它具有以下特点：</p><ul><li>开源且免费使用</li><li>占用资源少，适合资源受限的设备</li><li>支持多任务并发执行</li><li>提供任务调度、任务间通信、定时器等功能</li><li>可移植性强，支持多种处理器架构</li></ul><blockquote><p>总结：大佬封装的支持多任务并发的嵌入式操作系统</p></blockquote><h3 id="FreeRTOS-核心概念入门"><a href="#FreeRTOS-核心概念入门" class="headerlink" title="FreeRTOS 核心概念入门"></a>FreeRTOS 核心概念入门</h3><p>在开始写代码之前，我们先理解几个 FreeRTOS 最核心的概念：</p><ol><li><strong>任务 (Task)</strong>：<ul><li>你可以把任务看作是一个独立的、拥有自己执行流程的小程序或函数。</li><li>在 FreeRTOS 中，你的应用程序会被分解成一个或多个任务。</li><li>每个任务都有自己的<strong>堆栈 (Stack)</strong>，用来存储局部变量和函数调用信息。</li><li>每个任务都有一个<strong>优先级 (Priority)</strong>，优先级高的任务会优先获得 CPU 时间。</li><li>任务可以处于不同的<strong>状态</strong> (运行、就绪、阻塞、挂起)。</li></ul></li><li><strong>调度器 (Scheduler)</strong>：<ul><li>调度器是 FreeRTOS 的“大脑”。它的工作是决定在任何时刻，哪个任务应该占用 CPU 运行。</li><li>FreeRTOS 通常使用<strong>抢占式调度 (Preemptive Scheduling)</strong>：如果一个高优先级的任务准备好运行了，调度器会立即中断当前正在运行的低优先级任务，让高优先级任务执行。</li><li>调度器也支持<strong>时间片轮转 (Time Slicing)</strong>：对于相同优先级的任务，调度器会给每个任务分配一小段 CPU 时间（时间片），然后轮流执行它们。</li></ul></li><li><strong>时钟节拍 (Tick)</strong>：<ul><li>FreeRTOS 需要一个周期性的硬件定时器中断，称为“时钟节拍”或“系统节拍”(System Tick)。</li><li>这个节拍是 FreeRTOS 进行时间管理和任务调度的基础。例如，<code>vTaskDelay()</code> 函数就是基于时钟节拍来实现延时的。</li><li>在 ESP-IDF 中，这个时钟节拍已经由底层配置好了，你通常不需要关心它的具体实现。</li></ul></li></ol><h1 id="ESP32应用"><a href="#ESP32应用" class="headerlink" title="ESP32应用"></a>ESP32应用</h1><p><strong>ESP-IDF 是深度基于 FreeRTOS 构建的，对于绝大多数开发者来说，使用 ESP-IDF 进行开发，就是在隐式或显式地使用 FreeRTOS。</strong></p><p>让我们来详细拆解一下这个关系。</p><h3 id="1-ESP32-的硬件与软件层次"><a href="#1-ESP32-的硬件与软件层次" class="headerlink" title="1. ESP32 的硬件与软件层次"></a>1. ESP32 的硬件与软件层次</h3><p>我们可以把 ESP32 的软件系统看作一个“千层蛋糕”：</p><pre class="line-numbers language-none"><code class="language-none">+---------------------------------------------------+|                  你的应用程序 (Your Application)   |  &lt;-- 你写的代码，比如 uart_echo_task, sniffer_task+---------------------------------------------------+|      ESP-IDF 高层组件 (Wi-Fi, Bluetooth, HTTP)      |  &lt;-- 比如 esp_wifi_start(), esp_http_client_perform()+---------------------------------------------------+|      ESP-IDF 驱动层 (Driver Layer)                |  &lt;-- 比如 uart_driver_install(), gpio_set_level()+---------------------------------------------------+|           FreeRTOS (实时操作系统内核)             |  &lt;-- 任务调度、队列、信号量、定时器等+---------------------------------------------------+|      底层硬件抽象层 (HAL) &amp; Bootloader           |  &lt;-- 直接与硬件寄存器打交道的部分+---------------------------------------------------+|                   ESP32 硬件 (Hardware)           |  &lt;-- 芯片本身 (CPU, Wi-Fi, GPIO...)+---------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这个结构可以看出：</p><ul><li><strong>FreeRTOS 处于非常底层的位置</strong>，它直接管理着 CPU 核心，决定了在任何一个时刻，哪个代码片段（任务）可以运行。</li><li><strong>你写的应用程序</strong> 和 <strong>ESP-IDF 的所有高级功能</strong> 都运行在 FreeRTOS 之上，作为 FreeRTOS 的“任务”存在。</li></ul><h3 id="2-“ESP32-的底层全是-FreeRTOS”-这句话为什么有道理？"><a href="#2-“ESP32-的底层全是-FreeRTOS”-这句话为什么有道理？" class="headerlink" title="2. “ESP32 的底层全是 FreeRTOS” - 这句话为什么有道理？"></a>2. “ESP32 的底层全是 FreeRTOS” - 这句话为什么有道理？</h3><ol><li><strong>任务调度是核心</strong>：ESP-IDF 的整个系统都是围绕 FreeRTOS 的多任务机制设计的。比如，Wi-Fi 协议栈、蓝牙协议栈、TCP&#x2F;IP 协议栈（LwIP）等这些复杂的功能，都在后台作为独立的、高优先级的 FreeRTOS 任务运行。当你调用 <code>esp_wifi_start()</code> 时，你实际上是启动了几个由乐鑫官方写好的后台任务。</li><li><strong>app_main 本身就是一个任务</strong>：你的程序入口 <code>app_main</code> 函数，实际上并不是一个像传统单片机 <code>main()</code> 函数那样从头跑到尾的东西。在系统启动后，ESP-IDF 会初始化好底层服务，然后创建一个名为 “main” 的 FreeRTOS 任务，并让这个任务去执行 <code>app_main</code> 函数。所以，<strong>你写的第一个函数就已经跑在 FreeRTOS 的环境里了</strong>。</li><li><strong>驱动和组件是“线程安全”的</strong>：由于系统是多任务的，ESP-IDF 的大部分 API 都被设计为“线程安全”的。这意味着你可以在不同的任务中调用同一个驱动函数（比如 <code>esp_log_write</code>），而不用担心数据会混乱。这背后都是通过 FreeRTOS 的互斥锁（Mutexes）或信号量（Semaphores）等同步机制来实现的。</li><li><strong>事件驱动模型</strong>：ESP-IDF 大量使用事件循环（Event Loop）。当你连接 Wi-Fi 时，你不是写一个 <code>while(isConnected == false)</code> 的循环去等待，而是注册一个回调函数。当 Wi-Fi 连接成功或失败时，Wi-Fi 的后台任务会通过 FreeRTOS 的队列（Queue）发送一个事件，然后事件循环任务接收到这个事件，再调用你注册的回调函数。整个过程都是由 FreeRTOS 的通信机制驱动的。</li></ol><h2 id="临界区、互斥锁、信号量"><a href="#临界区、互斥锁、信号量" class="headerlink" title="临界区、互斥锁、信号量"></a>临界区、互斥锁、信号量</h2><ol><li><ul><li>“临界区”是一个源自<strong>操作系统 (Operating System) 理论</strong>的概念。它指的是一段代码，这段代码会访问一个共享资源（比如一个全局变量、一个串口），在同一时间，绝不能被多个任务同时访问。</li><li>在您的项目中，<strong>FreeRTOS</strong> 就是一个嵌入式操作系统。是 <strong>FreeRTOS</strong> 提供了实现“临界区”这个概念的具体工具，也就是 <code>taskENTER_CRITICAL()</code> 和 <code>taskEXIT_CRITICAL()</code> 这两个函数。</li></ul></li></ol><p><strong>简单来说</strong>：C语言是您用来写代码的<strong>语言</strong>，而 FreeRTOS 是为您提供多任务、队列、互斥锁、临界区等高级功能的<strong>平台或库</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以，最准确的理解是：</p><p><strong>ESP-IDF 将 FreeRTOS 作为其操作系统的内核，并围绕其构建了整个软件框架。你无法绕过 FreeRTOS 来使用 ESP-IDF。</strong></p><ul><li>对于<strong>简单项目</strong>，你可以把它当作一个“增强版的 Arduino”，只在 <code>app_main</code> 里写代码，只使用 <code>vTaskDelay()</code>，这时你是在<strong>被动地、隐式地</strong>享受 FreeRTOS 带来的好处。</li><li>对于<strong>复杂项目</strong>，你必须把它当作一个真正的多任务嵌入式系统，主动学习并使用 FreeRTOS 提供的 <strong>Task, Queue, Semaphore</strong> 等强大工具来组织你的代码。这才是发挥 ESP32 和 ESP-IDF 全部潜力的正确方式。</li></ul><h1 id="STM32-标准库开发-vs-ESP-IDF-基于-FreeRTOS"><a href="#STM32-标准库开发-vs-ESP-IDF-基于-FreeRTOS" class="headerlink" title="STM32 标准库开发 vs ESP-IDF (基于 FreeRTOS)"></a>STM32 标准库开发 vs ESP-IDF (基于 FreeRTOS)</h1><table><thead><tr><th>特性</th><th>STM32F103 + 标准库 (裸机开发)</th><th>ESP32-S3 + ESP-IDF (基于 RTOS)</th></tr></thead><tbody><tr><td><strong>执行模型</strong></td><td><strong>单线程，顺序执行</strong>。程序从 <code>main()</code> 函数开始，通常进入一个 <code>while(1)</code> 无限循环。所有事情都在这个循环里排队完成。</td><td><strong>多任务，并发执行</strong>。<code>app_main</code> 本身就是一个任务。你可以创建多个任务，由 FreeRTOS 在它们之间快速切换，实现“伪并行”。</td></tr><tr><td><strong>CPU 控制权</strong></td><td><strong>你完全掌控 CPU</strong>。CPU 严格按照你的代码顺序执行。一个耗时操作（如 <code>delay()</code>）会<strong>完全霸占</strong> CPU，期间其他任何事情都做不了。</td><td><strong>你与 RTOS 共享 CPU</strong>。当你调用 <code>vTaskDelay()</code> 时，你是在<strong>主动放弃</strong> CPU，让 FreeRTOS 去运行其他任务。CPU 利用率极高。</td></tr><tr><td><strong>实时性</strong></td><td><strong>难以保证</strong>。如果在主循环里有一个耗时很长的函数，那么排在它后面的任务就必须等待，响应时间无法预测。</td><td><strong>可预测</strong>。通过为不同任务设置不同优先级，可以确保重要任务（如电机控制）总能优先获得 CPU 时间，响应更及时。</td></tr><tr><td><strong>代码结构</strong></td><td><strong>状态机（State Machine）</strong>。所有逻辑都挤在 <code>main</code> 函数的 <code>while(1)</code> 循环里，通常用 <code>if-else</code> 或 <code>switch-case</code> 结构来管理不同的状态。代码容易变得复杂和臃肿。</td><td><strong>模块化（Modular）</strong>。每个功能（如按键处理、屏幕显示、网络通信）都可以封装成一个独立的任务，代码结构清晰，易于维护和扩展。</td></tr><tr><td><strong>资源管理</strong></td><td><strong>由你手动管理</strong>。所有全局变量都可以被任何代码访问，容易产生冲突，需要开发者自己小心处理。</td><td><strong>由 RTOS 辅助管理</strong>。可以使用队列、信号量、互斥锁等机制来安全地在任务间共享数据和资源，避免冲突。</td></tr><tr><td><strong>底层关系</strong></td><td><strong>直接操作硬件</strong>。标准库函数本质上是对硬件寄存器的封装。你写的代码非常接近硬件底层。</td><td><strong>通过 RTOS 和驱动层</strong>。你的代码通过 FreeRTOS 和 ESP-IDF 驱动层与硬件交互，多了一层抽象，但也更安全、更方便。</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cursor使用第三方api</title>
      <link href="/2025/05/28/146-cursor-shi-yong-di-san-fang-api/"/>
      <url>/2025/05/28/146-cursor-shi-yong-di-san-fang-api/</url>
      
        <content type="html"><![CDATA[<h1 id="三方API"><a href="#三方API" class="headerlink" title="三方API"></a>三方API</h1><ul><li><p><a href="https://happyapi.org/">https://happyapi.org/</a></p></li><li><p><a href="https://openrouter.ai/">https://openrouter.ai/</a></p></li></ul><h1 id="Cursor配置"><a href="#Cursor配置" class="headerlink" title="Cursor配置"></a>Cursor配置</h1><ul><li>上面为创建令牌之后的key</li><li>下方为api的根目录，参考api文档</li></ul><p>然后add model,名称为api网站写的模型名称,我这里为</p><p>⚠️:第三方api只能使用ask功能,且需要选中模型<code>claude-3-7-sonnet-20250219</code></p><p>然后就可以快乐的使用了</p><blockquote><p>但是无法读取项目文件使cursor功力大减</p><p>且cursor会缩减回答文本,不如官网</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>共模电路</title>
      <link href="/2025/05/27/144-gong-mo-dian-lu/"/>
      <url>/2025/05/27/144-gong-mo-dian-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="共模信号和差模信号"><a href="#共模信号和差模信号" class="headerlink" title="共模信号和差模信号"></a>共模信号和差模信号</h1><p>通常电源线有三根线：火线L、零线N和地线PE。</p><p>电压和电流的变化通过导线传输时有两种形态。</p><p>一种是两根导线，分别作为往返线路传输，我们称之为<strong>差模</strong>。</p><p>另一种是两根导线做去路，地线做返回传输, 我们称之为<strong>共模</strong>。</p><p><img src="https://picx.zhimg.com/v2-6619bc19a4075c7c01befe4c5195372f_1440w.jpg" alt="img"></p><blockquote><p>就是差模是<code>+</code>出<code>-</code>回</p><p>共模<code>+</code>出<code>-</code>出但是GND回</p></blockquote><h2 id="共模干扰"><a href="#共模干扰" class="headerlink" title="共模干扰"></a>共模干扰</h2><p>任何两根电源线上所存在的干扰，均可用共模干扰和差模干扰来表示。</p><p><img src="https://picx.zhimg.com/v2-73a646e6be358e866b8bc8cb5d4781fd_1440w.jpg" alt="img"></p><p>共模干扰在导线与地（机壳）之间传输，属于非对称性干扰，它定义为任何载流导体与参考地之间的不希望存在的电位差。</p><p>差模干扰在两导线之间传输，属于对称性干扰，它定义为任何两个载流导体之间的不希望存在的电位差。</p><p>在一般情况下，共模干扰幅度大、频率高，还可以通过导线产生辐射，所造成的干扰较大。差模干扰幅度小、频率低、所造成的干扰较小。</p><h3 id="抑制方法"><a href="#抑制方法" class="headerlink" title="抑制方法"></a>抑制方法</h3><p>共模干扰作为<a href="https://zhida.zhihu.com/search?content_id=209599005&content_type=Article&match_order=1&q=EMC%E5%B9%B2%E6%89%B0&zhida_source=entity">EMC干扰</a>中最为常见且危害较大的干扰，我们抑制它最直接的方法就是滤波。</p><blockquote><p>在电路中串入<a href="https://zhida.zhihu.com/search?content_id=209599005&content_type=Article&match_order=1&q=%E5%85%B1%E6%A8%A1%E7%94%B5%E6%84%9F&zhida_source=entity"><strong>共模电感</strong></a>，当有共模干扰电流流经线圈时，由于共模干扰电流的同向性，<strong>会在线圈内产生同向的磁场而增大线圈的感抗</strong>，使线圈表现为高阻抗，产生较强的阻尼效果，以此衰减共模干扰电流，达到滤波的目的.</p></blockquote><blockquote><p>当电路中的正常差模电流流经共模电感时，电流在同相绕制的共模电感线圈中产生反向的磁场而相互抵消，因而对正常的差模电流基本没有衰减作用。</p></blockquote><p>USB信号上的共模干扰抑制方法，一般会在端口加一个共模电感。</p><p><a href="https://zhuanlan.zhihu.com/p/546595721">共模干扰与差模干扰</a></p><h3 id="共模干扰产生原因"><a href="#共模干扰产生原因" class="headerlink" title="共模干扰产生原因"></a><strong>共模干扰产生原因</strong></h3><p>主要有以下几种：</p><p>1、电网串入共模干扰电压。</p><p>2、辐射干扰（如雷电，设备电弧，附近电台，大功率辐射源）在信号线上感应出共模干扰，原因是交变的磁场产生交变的电流，地线—零线回路面积与地线—火线回路面积不相同，两个回路阻抗不同等原因造成电流大小不同。</p><p>3、接地电压不一样，简单的说就电位差而造就了共模干扰。</p><p>4、设备内部的线路对电源线造成的共模干扰。</p><h3 id="共模干扰电流"><a href="#共模干扰电流" class="headerlink" title="共模干扰电流"></a><strong>共模干扰电流</strong></h3><p>共模干扰一般是以共模干扰电流存在的形式出现的，一般情况下，共模干扰电流产生的原因有三个方面：</p><p>1、外界电磁场在电路走线中的所有导线上感应出来电压（这个电压相对于大地是等幅和同相的），由这个电压产生的电流。</p><p>2、由于电路走线两端的器件所接的地电位不同，在这个地电位差的驱动下产生的电流。</p><p>3、器件上的电路走线与大地之间有电位差，这样电路走线上会产生共模干扰电流。</p><h2 id="共模电路"><a href="#共模电路" class="headerlink" title="共模电路"></a>共模电路</h2><p>串联一个共模电感+一点滤波电容,具体参数网上查找前辈们的经验</p><h2 id="共模电感"><a href="#共模电感" class="headerlink" title="共模电感"></a>共模电感</h2><p>共模扼流圈 （Common Mode Choke），也叫共模电感，是在一个闭合磁环上对称绕制方向相反、匝数相同的线圈。常用于过滤共模的电磁干扰，抑制高速信号线产生的电磁波向外辐射发射，提高系统的<a href="http://www.elecfans.com/tags/EMC/">EMC</a>，在实际应用中一般是在差分的信号线上加共模电感。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/19b172ba87d35d4d84fb2c522d022dcd.jpeg" alt="img"></p><p><strong>共模电感抑制共模干扰：</strong></p><p>根据右手螺旋定则，在同一磁环绕上方向相反的两个线圈通过极性相同，幅值相等的两个电压时，产生的磁通相互叠加，感抗为：Xl&#x3D;wL,感抗很大。差分信号产生的磁通就相互抵消。</p><h1 id="共模干扰测量方法"><a href="#共模干扰测量方法" class="headerlink" title="共模干扰测量方法"></a>共模干扰测量方法</h1><p><strong>使用示波器的频谱分析功能测量共模干扰</strong></p><p>现代数字示波器通常集成了FFT(快速傅里叶变换)频谱分析功能，可用于简单的共模干扰测量。以下是详细步骤：</p><h2 id="所需设备"><a href="#所需设备" class="headerlink" title="所需设备"></a>所需设备</h2><ol><li>带FFT功能的数字示波器（最好支持EMI预测或频谱分析）</li><li>高频探头（至少100MHz带宽）</li><li>共模探头或自制共模测试夹具</li><li>50Ω终端电阻（可选）</li></ol><h2 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h2><h3 id="1-制作简易共模测试夹具（如无专用共模探头）"><a href="#1-制作简易共模测试夹具（如无专用共模探头）" class="headerlink" title="1. 制作简易共模测试夹具（如无专用共模探头）"></a>1. 制作简易共模测试夹具（如无专用共模探头）</h3><ul><li>在铁氧体环上缠绕2-3匝线圈</li><li>将线圈两端连接到示波器探头</li><li>这样当共模电流通过被测电缆时，会在线圈中感应出电压</li></ul><h3 id="2-示波器设置"><a href="#2-示波器设置" class="headerlink" title="2. 示波器设置"></a>2. 示波器设置</h3><ul><li>打开示波器，连接探头</li><li>将探头补偿设置为适合高频测量（通常为50Ω）</li><li>选择适当的时基（建议从10μs&#x2F;div开始）</li><li>垂直灵敏度设为较高（如20mV&#x2F;div）</li></ul><h3 id="3-激活FFT功能"><a href="#3-激活FFT功能" class="headerlink" title="3. 激活FFT功能"></a>3. 激活FFT功能</h3><ul><li>在示波器菜单中找到”Math”或”FFT”选项</li><li>设置FFT参数： <ul><li>窗口函数：选择Hanning或Blackman窗口（更适合EMI测量）</li><li>采样点数：选择最大值（通常8k或16k点）</li><li>频率范围：设置上限至少为30MHz（EMI测量常用范围）</li></ul></li></ul><h3 id="4-测量设置"><a href="#4-测量设置" class="headerlink" title="4. 测量设置"></a>4. 测量设置</h3><ul><li>将被测电源适配器接入插排并开启</li><li>用共模探头（或自制测试夹具）夹住Type-C线缆</li><li>确保测试环境相对安静（远离强电磁干扰源）</li></ul><h3 id="5-执行测量"><a href="#5-执行测量" class="headerlink" title="5. 执行测量"></a>5. 执行测量</h3><ul><li>调整示波器触发模式为”自动”</li><li>观察FFT显示窗口中的频谱图</li><li>记录频谱中的峰值及其频率</li><li>移动探头位置测量不同部位的共模干扰</li></ul><h3 id="6-分析数据"><a href="#6-分析数据" class="headerlink" title="6. 分析数据"></a>6. 分析数据</h3><ul><li>寻找频谱中的明显峰值</li><li>特别关注150kHz-30MHz范围内的干扰</li><li>记录最强干扰的频率点</li><li>与相关EMI标准限值比较（如有）</li></ul><h2 id="优化测量技巧"><a href="#优化测量技巧" class="headerlink" title="优化测量技巧"></a>优化测量技巧</h2><ol><li>改善测量精度<ul><li>使用接地的金属板作为参考平面</li><li>保持探头引线尽可能短</li><li>使用适当的探头衰减比（通常为10:1）</li></ul></li><li>频段分段测量<ul><li>低频段（150kHz-1MHz）：使用较长时基</li><li>高频段（1MHz-30MHz）：使用较短时基</li><li>分段测量可提高特定频段的分辨率</li></ul></li><li>共模与差模区分<ul><li>共模：探头围绕整个电缆（包括正负线）</li><li>差模：探头只测量单根导线</li></ul></li><li>对比测量<ul><li>测量添加共模滤波前后的频谱变化</li><li>比较不同负载条件下的干扰情况</li><li>在不同操作模式下进行测试</li></ul></li></ol><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/ZQ07506149/article/details/82818403">电路基础知识之什么是共模电感&#x2F;共模信号&#x2F;差分信号</a></p><p>作者是初学者，文章内容有误欢迎指出，一起学习</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>公钥与私钥</title>
      <link href="/2025/05/24/148-gong-yao-yu-si-yao/"/>
      <url>/2025/05/24/148-gong-yao-yu-si-yao/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ol><li><p><strong>公钥／私钥一一对应</strong></p><ul><li>私钥 → 推算出公钥；公钥无法反推私钥。</li><li>只有与服务器 <code>authorized_keys</code> 中某行公钥匹配的那把私钥，才能登录。</li></ul></li><li><p><strong><code>authorized_keys</code> 的格式</strong></p><ul><li><p>存放在用户目录下（如 <code>/root/.ssh/authorized_keys</code>）</p></li><li><p>文件中<strong>每行一把</strong>公钥：</p><pre class="line-numbers language-none"><code class="language-none">ssh-rsa AAAAB3… user@hostssh-ed25519 BBBBB… deploy@ci<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>可以有多把公钥，任何一把对应的私钥都可登录；删行即可撤销访问。</p></li></ul><p><del>不知道为什么ZGO家的服务器只有初始重装时的ssh密钥才可以，后续面板添加的无效</del></p><blockquote><p>是的，面板有问题，公钥没有被加入到<code>/root/.ssh/authorized_keys</code></p></blockquote></li></ol><h1 id="密钥登录部署"><a href="#密钥登录部署" class="headerlink" title="密钥登录部署"></a>密钥登录部署</h1><ol><li><p><strong>在本地生成一对密钥</strong>(在哪生成都可以)</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa -b 2048 -f ~&#x2F;.ssh&#x2F;my_id_rsa  # 这会生成 ~&#x2F;.ssh&#x2F;my_id_rsa（私钥）和 ~&#x2F;.ssh&#x2F;my_id_rsa.pub（公钥）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>把公钥传到服务器</strong></p><ul><li><p>通过 ZGO 面板：</p><ul><li>在 “Add SSH Key” 界面，只粘入 <code>my_id_rsa.pub</code> 的内容，点击 <strong>Save</strong>（<strong>不要</strong>点 Generate）。</li></ul></li><li><p>或者手动：</p><pre class="line-numbers language-none"><code class="language-none">mkdir -p &#x2F;root&#x2F;.sshchmod 700 &#x2F;root&#x2F;.sshecho &#39;ssh-rsa AAAA…your-key… user@host&#39; \  &gt;&gt; &#x2F;root&#x2F;.ssh&#x2F;authorized_keyschmod 600 &#x2F;root&#x2F;.ssh&#x2F;authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>验证 <code>authorized_keys</code></strong></p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;root&#x2F;.ssh&#x2F;authorized_keys# 确认里面有一整行从 my_id_rsa.pub 复制过来的公钥ls -ld &#x2F;root&#x2F;.ssh           # 应该是 700ls -l  &#x2F;root&#x2F;.ssh&#x2F;authorized_keys  # 应该是 600<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>用私钥登录</strong><br> 在你本地（或 Termius、WSL、Git Bash）执行：</p><pre class="line-numbers language-none"><code class="language-none">ssh -i ~&#x2F;.ssh&#x2F;my_id_rsa root@38.49.38.67<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>调试</strong><br> 如果仍然失败，加上 <code>-vvv</code>：</p><pre class="line-numbers language-none"><code class="language-none">ssh -vvv -i ~&#x2F;.ssh&#x2F;my_id_rsa root@38.49.38.67<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看到 <code>Offering public key: ... my_id_rsa</code> 且 <code>Server accepts key:</code> 就会通过。</p></li></ol><hr><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><strong>主机密钥</strong>（<code>/etc/ssh/ssh_host_*</code> 文件）只是 <strong>服务器</strong> 用来证明「我真的是这台机器」，与你能否「以 root 身份登录」无直接关系。</li><li><strong>用户密钥</strong>（你生成的 <code>id_rsa</code>&#x2F;<code>.pub</code>）才是验证「你是谁」的凭证，必须加入对应用户的 <code>authorized_keys</code>。</li></ul><p>在 <code>/root/.ssh/authorized_keys</code> 里目前只放了一行公钥；但实际上你可以往这个文件里<strong>每行添加一串公钥</strong>，也就相当于授权了多把私钥。(但其实没必要同一把私钥就可以)</p><hr><p><strong>1. <code>authorized_keys</code> 能存放多把公钥</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;root&#x2F;.ssh&#x2F;authorized_keys  内容示例：ssh-rsa AAAAB3Nza… 第一把公钥 user1@pc1ssh-rsa AAAAB3Nza… 第二把公钥 user2@laptopssh-ed25519 AAAAC3Nza… 第三把公钥 deploy@ci<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>每行一把</strong>：文件里每一行都是一把整的公钥。</li><li><strong>多把公钥</strong>：只要把更多公钥追加到这个文件，就能让对应的私钥都能登录。</li><li><strong>撤销访问</strong>：删除某一行就马上失效。</li></ul><hr><p><strong>2. <code>/etc/ssh</code> 目录下那些文件是什么</strong></p><table><thead><tr><th>名称</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td><code>sshd_config</code></td><td>文件</td><td>SSH 服务端配置，控制监听端口、认证方式、根登录等。</td></tr><tr><td><code>sshd_config.d/</code></td><td>目录</td><td>用于拆分存放额外的服务端配置片段。</td></tr><tr><td><code>ssh_config</code></td><td>文件</td><td>SSH 客户端配置，控制发起连接时的默认行为（比如默认端口、默认私钥路径等）。</td></tr><tr><td><code>ssh_config.d/</code></td><td>目录</td><td>拆分存放额外的客户端配置。</td></tr><tr><td><code>moduli</code></td><td>文件</td><td>DH 密钥交换时用到的一组大素数列表，支持多种 <code>diffie-hellman-group-*</code> 算法。</td></tr><tr><td><code>ssh_host_rsa_key</code></td><td>文件（私钥）</td><td>服务器的 RSA 主机私钥，用于向客户端证明“我就是这台服务器”。</td></tr><tr><td><code>ssh_host_rsa_key.pub</code></td><td>文件（公钥）</td><td>上面那把私钥对应的公钥，客户端第一次连接时会保存到 <code>known_hosts</code>，用于后续验证服务器身份。</td></tr><tr><td><code>ssh_host_ecdsa_key</code></td><td>文件（私钥）</td><td>服务器的 ECDSA 主机私钥。</td></tr><tr><td><code>ssh_host_ecdsa_key.pub</code></td><td>文件（公钥）</td><td>对应 ECDSA 主机公钥。</td></tr><tr><td><code>ssh_host_ed25519_key</code></td><td>文件（私钥）</td><td>服务器的 Ed25519 主机私钥。</td></tr><tr><td><code>ssh_host_ed25519_key.pub</code></td><td>文件（公钥）</td><td>对应 Ed25519 主机公钥。</td></tr></tbody></table><ul><li><strong>主机密钥</strong>（<code>ssh_host_*</code>）只关乎“服务器身份”，让客户端确认它连的是正确的机器；</li><li><strong>用户公钥</strong>（<code>authorized_keys</code>）才关乎“谁能登录”，与 <code>/etc/ssh</code> 下的主机密钥完全无关。</li></ul><hr><h2 id="增加公钥"><a href="#增加公钥" class="headerlink" title="增加公钥"></a>增加公钥</h2><ol><li><p>编辑 <code>/root/.ssh/authorized_keys</code>：</p><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;root&#x2F;.ssh&#x2F;authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>每行粘入一个新的公钥字符串（完整的 <code>ssh-rsa AAAA…</code> 或 <code>ssh-ed25519 …</code>）。</p></li><li><p>保存后保证权限仍然是：</p><pre class="line-numbers language-none"><code class="language-none">chmod 700 &#x2F;root&#x2F;.sshchmod 600 &#x2F;root&#x2F;.ssh&#x2F;authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>此后，任何对应这些公钥的私钥都可以用来登录 <code>root</code>。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Rmoteid接收端开发</title>
      <link href="/2025/05/22/143-rmoteid-jie-shou-duan-kai-fa/"/>
      <url>/2025/05/22/143-rmoteid-jie-shou-duan-kai-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>GB42590标准</li><li>F3411.40165-UAS-Remote-ID国际标准</li><li>ESP32系列开发板</li><li>ESP-IDF</li><li><a href="https://www.faa.gov/uas/getting_started/remote_id">无人机的远程识别 |美国联邦航空管理局</a></li><li><a href="https://thedroneprofessor.com/wp-content/uploads/2022/11/F3411.40165-UAS-Remote-ID.pdf?utm_source=chatgpt.com">F3411.40165-UAS-Remote-ID.pdf</a></li></ul><h1 id="WIFI-Beacon"><a href="#WIFI-Beacon" class="headerlink" title="WIFI Beacon"></a>WIFI Beacon</h1><p>现在无人机都需要 采用WI-FI Beacon广播协议发送报文，ESP32没有官方例程，所以去<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.4.1/esp32s3/api-reference/network/esp_wifi.html#_CPPv417esp_wifi_80211_tx16wifi_interface_tPKvib">官方文档</a>找相关方法</p><p>根据GB42590文件了解到wifi信标帧格式，于是用两个ESP32开发板，分别为接收端与发射端开发</p><img src="/2025/05/22/143-rmoteid-jie-shou-duan-kai-fa/1747904815392.png" class="" width="1747904815392"><h1 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h1><h1 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h1><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>1.<strong>可以接收到发送端的数据，但是接收不到无人机的数据</strong></p><blockquote><p>无人机需要起飞才可以</p></blockquote><ol start="13"><li>无人机开始广播远程识别信号的条件是什么？</li></ol><p>The drone will start broadcasting the FAA Remote ID signal when all of the following conditions are met.<br>当满足以下所有条件时，无人机将开始广播 FAA Remote ID 信号。</p><p>• The drone has built-in Remote ID functionality.<br>• 无人机具有内置的 Remote ID 功能。</p><p>• The drone is within airspace of the United States.<br>• 飞行器在美国领空内。</p><p>• The drone is in flight (i.e. the propellers are turning).<br>• 飞行器正在飞行（即螺旋桨在转动）。</p><p><a href="https://support.dji.com/help/content?customId=en-us03400007747&documentType=artical&lang=en&paperDocType=paper&re=HK&spaceId=34">大疆国外RID文件</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP-IDF开发ESP32</title>
      <link href="/2025/05/21/142-esp-idf-kai-fa-esp32/"/>
      <url>/2025/05/21/142-esp-idf-kai-fa-esp32/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>ESP32-Nano 板子之所以在刷机时 COM 号“跳变”，而你的 S3 板子没有，是因为它们 USB-UART 实现的方式不同：</p><ul><li><strong>ESP32-S3 开发板</strong> 通常用外置 CP210x&#x2F;FTDI 芯片，只要上电就一直挂在同一个 VID&#x2F;PID 上，重启或进下载模式也不会重新枚举，就一直是那个 COM 口。</li><li><strong>ESP32-Nano 板</strong> 则用原生 TinyUSB 或集成的 USB-UART 控制器（CH9102、RISC-V CDC 等），它在正常运行时和进下载（BOOT）时会用<strong>两个不同的 USB 设备描述符</strong>，系统就给了两个不同的 COM 号（比如正常时 COM9，进下载后又变成 COM10）。</li></ul><hr><h3 id="几种常见的应对办法"><a href="#几种常见的应对办法" class="headerlink" title="几种常见的应对办法"></a>几种常见的应对办法</h3><ol><li><p><strong>固定一个你看到的 COM 口号</strong></p><ul><li>在 Windows 设备管理器里，对 Nano 的两个端口分别右键 → 属性 → “端口设置” → “高级” → 手动改一个固定号（如 COM3），避免系统随意分配。</li><li>然后在 VS Code&#x2F;<code>idf.py</code> 里一律使用这个固定号即可。</li></ul></li><li><p><strong>改用「自动端口识别」</strong></p><ul><li>VS Code ESP-IDF 扩展里有 “Monitor (Auto-detect port)” 功能，或者点击 “Flash project” 时选择 “Automatically detect port” 选项，扩展会在刷写前后自动扫描设备并切换，不必手动指定 COM 号。</li><li>如果用命令行，也可以不指定 <code>-p COMx</code>，让 esptool 去找第一个 ESP 设备。</li></ul></li><li><p><strong>分别指定下载和 Monitor 的端口</strong></p><ul><li><p>在启动下载时（BOOT loader 阶段）系统是给第二个 VID&#x2F;PID，你可以在脚本里区分：</p><pre class="line-numbers language-none"><code class="language-none"># 先用空的 -p ，让 esptool 自动选，刷完之后…idf.py flash# 再切回第一个端口用 monitoridf.py -p COM9 monitor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>或者在 <code>idf.py menuconfig</code> → “Serial flasher config” 中把 “Flasher port” 设为 <code>auto</code>。</p></li></ul></li><li><p><strong>给刷机板加一个独立的 USB-UART 适配器</strong></p><ul><li>如果不想折腾系统枚举，也可以把 Nano 的下载脚（IO0&#x2F;EN）留空，用板子上的 USB 供电，然后用外接 CP2102 转接器连 TX&#x2F;RX&#x2F;EN&#x2F;IO0 来刷，这样就只会出现一个由 CP2102 提供的稳定 COM 口。</li></ul></li></ol><hr><p><strong>小结</strong>：ESP32-Nano 在进入下载模式时切换了 USB 描述符，所以 Windows 给它分配了新的 COM 号。推荐的快速解决：</p><ol><li>在设备管理器里给这个 Nano USB 设备手动固定一个 COM 号；</li><li>或者打开 VS Code 的“自动端口检测”功能，让工具自己选口；<br> 这样一来，不管是刷机模式还是运行模式，都能稳定地找到同一个串口。</li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>要让 Sniffer 接收到你自己发的 Vendor IE</strong>，必须先把它「广播」出去。</p><ul><li>最简单的：切 AP 模式 + <code>esp_wifi_set_vendor_ie</code></li><li>或者：手工拼 802.11 Beacon + <code>esp_wifi_80211_tx</code></li></ul><h1 id="烧录固件"><a href="#烧录固件" class="headerlink" title="烧录固件"></a>烧录固件</h1><p>在ESP-IDF编译后德 打印数据获取固件以及固件地址</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_48057513/article/details/143827373?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Ctr-5-143827373-blog-138012468.235%5Ev43%5Epc_blog_bottom_relevance_base6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Ctr-5-143827373-blog-138012468.235%5Ev43%5Epc_blog_bottom_relevance_base6&utm_relevant_index=5">ESP32s3烧录bin，乐鑫下载工具flash_download_tool_乐鑫烧录工具-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建中转服务器</title>
      <link href="/2025/05/14/134-da-jian-zhong-zhuan-fu-wu-qi/"/>
      <url>/2025/05/14/134-da-jian-zhong-zhuan-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>线路好但ip解锁差与线路差但ip解锁好的机混合一下<del>因为穷</del></p><p>本机-&gt;中转-&gt;落地-&gt;目标网站，延迟&#x3D;1+2&lt;3（也要考虑地理位置）</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>中转机（线路优秀）</li><li>落地机（解锁优秀）</li></ul><h1 id="3X-UI面板搭建"><a href="#3X-UI面板搭建" class="headerlink" title="3X-UI面板搭建"></a>3X-UI面板搭建</h1><h2 id="Alpine系统安装包"><a href="#Alpine系统安装包" class="headerlink" title="Alpine系统安装包"></a>Alpine系统安装包</h2><p>换国内源再安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed -i &#39;s&#x2F;dl-cdn.alpinelinux.org&#x2F;mirrors.ustc.edu.cn&#x2F;g&#39; &#x2F;etc&#x2F;apk&#x2F;repositories                                                                    apk updateapk add curlapk add busybox-extras<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Gost-搭建"><a href="#Gost-搭建" class="headerlink" title="Gost 搭建"></a>Gost 搭建</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>无线电花花</title>
      <link href="/2025/05/12/141-wu-xian-dian-hua-hua/"/>
      <url>/2025/05/12/141-wu-xian-dian-hua-hua/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/UncleWa/article/details/124576371">USRP系列（一）：软件定义无线电（SDR）_usrp软件无线电-CSDN博客</a></p><p>sdr软件定义无线电</p><p>noaa卫星信号</p><p><a href="https://www.rtl-sdr.com/"></a></p><h1 id="软件定义无线电"><a href="#软件定义无线电" class="headerlink" title="软件定义无线电"></a>软件定义无线电</h1><p>rtl-sdr.com</p><h2 id="已知功能"><a href="#已知功能" class="headerlink" title="已知功能"></a>已知功能</h2><ul><li>收听广播（已验证）</li><li>收听飞机广播，塔台信息（未验证）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Arduino安装ESP32开发环境</title>
      <link href="/2025/05/12/140-arduino-an-zhuang-esp32-huan-jing/"/>
      <url>/2025/05/12/140-arduino-an-zhuang-esp32-huan-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="离线"><a href="#离线" class="headerlink" title="离线"></a>离线</h1><p>就是直接下载安装包放在对应位置</p><blockquote><p>C:\Users\VIBTEK\AppData\Local\Arduino15\packages\esp32\hardware\esp32</p><p>完整路径示例：</p><p>C:\Users\你的用户名\AppData\Local\Arduino15\packages\esp32\hardware\esp32\3.2.0</p></blockquote><p>报错</p><p>ϵͳ�Ҳ���ָ����·����<br>exit status 1</p><p>Compilation error: exit status 1</p><p>官方库地址</p><p><a href="https://github.com/espressif/arduino-esp32?tab=readme-ov-file">arduino-esp32</a></p><p><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/installing.html">官方文档</a>)</p><h1 id="在线"><a href="#在线" class="headerlink" title="在线"></a>在线</h1><p><strong>1.File（文件） &gt; Preferences（首选项）</strong></p><p><strong>2.添加 ESP32 开发板索引地址</strong></p><p>在“附加开发板管理器网址”中粘贴以下内容：</p><p><a href="https://dl.espressif.com/dl/package_esp32_index.json">https://dl.espressif.com/dl/package_esp32_index.json</a></p><p><strong>3.打开开发板管理器并搜索 ESP32</strong><br>点击菜单栏：</p><blockquote><p>Tools（工具） &gt; Board（开发板） &gt; Board Manager（开发板管理器）</p></blockquote><p>在搜索框中输入：</p><blockquote><p>esp32</p></blockquote><p>你将看到类似以下内容：</p><blockquote><p>esp32 by Espressif Systems<br>最新版本：3.2.0<br>支持多种开发板（包括 DevKitC、NodeMCU、ESP32-C3、S3、S2、PICO 等）</p></blockquote><p><strong>4.选择版本并安装</strong></p><p>点击该项右下角的“<strong>Install（安装）</strong>”按钮：</p><ul><li>如果你希望安装稳定版，推荐安装 <strong>2.0.9</strong></li><li>如果你希望体验最新版本（如支持 ESP32-S3 OTA、Matter 等），可以选择 <strong>3.2.0</strong></li></ul><p>5.安装成功后开发板管理器会显示版本</p><img src="/2025/05/12/140-arduino-an-zhuang-esp32-huan-jing/1747036039181.png" class="" width="1747036039181"><blockquote><p>低版本的可以多下载几次，成功率高，2.0.9的一次ok</p></blockquote><p><a href="https://blog.csdn.net/Zhang_sheng_nan/article/details/147839995">参考文章</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-C3板子</title>
      <link href="/2025/04/29/139-esp32-c3-ban-zi/"/>
      <url>/2025/04/29/139-esp32-c3-ban-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1.电脑识别不到串口号</p><p>2.无法进入下载模式（）</p><p>   1.arduino ide cbc可正常烧录</p><p>​2.arduino ide cbc可正常烧录，但是无法打开串口监视器</p><p>​3.模块出现问题，上电短路导致板子硬件连接出现问题</p><p> 3.一直重启，串口打印0xfffffff</p><p>4.设备管理器串口一直刷新，boot上电后写入超时</p><p>cbc烧录过程中烧录后程序正常运行，无法打开串口监视器，串口也不再刷新</p><p>vs烧录成功正常模式，但是串口不打印</p><p>但是arduino无法烧录了</p><blockquote><p>A serial exception error occurred: Cannot configure port, something went wrong. Original message: OSError(22, ‘�����߳��˳���Ӧ�ó�����������ֹ I&#x2F;O ������’, None, 995)<br>Note: This error originates from pySerial. It is likely not a problem with esptool, but with the hardware connection or drivers.<br>For troubleshooting steps visit: <a href="https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html">https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html</a></p></blockquote><p><strong>换台电脑可以正常使用</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="一、电脑识别不到串口号"><a href="#一、电脑识别不到串口号" class="headerlink" title="一、电脑识别不到串口号"></a>一、电脑识别不到串口号</h3><p>1.考虑短路或者断路-&gt;万用表测试-&gt;一切正常</p><p>2.首先type-c引脚连锡，怀疑模块损坏-&gt;更换-&gt;未解决</p><p>3.考虑其他元器件损坏-&gt;又焊一版本-&gt;无解</p><p>4.考虑原理图错误-&gt;比对-&gt;无解</p><p>5.测试电阻</p><p>6.测试电压-&gt;发现GPIO9的压降不正常-&gt;GPT老师-&gt;找到问题</p><blockquote><p>去除复位电路导致EN引脚悬空，被自动下载电路拉低，芯片一直处于复位状态</p><p>通过“自动下载电路”把 BOOT（IO0）也拉低,芯片持续复位</p></blockquote><img src="/2025/04/29/139-esp32-c3-ban-zi/1745914031148.png" class="" width="1745914031148"><img src="/2025/04/29/139-esp32-c3-ban-zi/1745914035144.png" class="" width="1745914035144"><img src="/2025/04/29/139-esp32-c3-ban-zi/1745914038646.png" class="" width="1745914038646"><p>7.下载模式下蜂鸣器响</p><p>8.platform下载模式无法烧录</p><p>9.arduino可以烧录但是</p><p><code>Writing at 0x001240f7... (100 %) Wrote 1137632 bytes (692273 compressed) at 0x00010000 in 10.9 seconds (effective 838.8 kbit/s)... Hash of data verified.Leaving... Hard resetting with RTC WDT...A serial exception error occurred: Cannot configure port, something went wrong. Original message: OSError(22, &#39;ָ�������ڵ��豸��&#39;, None, 433) Note: This error originates from pySerial. It is likely not a problem with esptool, but with the hardware connection or drivers. For troubleshooting steps visit: https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html Failed uploading: uploading error: exit status 1</code></p><p><strong>从日志看，固件已经成功写入</strong>，只是最后一步“硬复位”后，串口没及时重枚举／被断开，导致 esptool 在重连时拿不到设备就报了“OSError(22, ‘找不到设备’)”的错误。这不影响实际烧录，只是自动复位和串口重打开的环节出了问题。</p><h3 id="为什么会出现这个错误"><a href="#为什么会出现这个错误" class="headerlink" title="为什么会出现这个错误"></a>为什么会出现这个错误</h3><ol><li><strong>硬复位太快</strong><br> esptool 在下载完毕后会自动拉低 EN（通过 DTR→C→Q1）来让芯片重启，但同时它也马上尝试重新打开同一个 COM 口。如果 ESP 重启过程中过快（或复位脉冲太长），USB-串口芯片一瞬间掉线，PC 端 port 就消失了，esptool 再访问就报“找不到设备”。</li><li><strong>自动下载电路拉高&#x2F;拉低冲突</strong><br> 如果你的 EN 上拉（10 kΩ+100 nF）或 DTR 耦合电容参数不够理想，可能导致复位脉冲持续／反弹，板子不上电也不上载，引起端口反复重枚举，PC 端口同样就不稳定。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案-A：手动复位并重试"><a href="#方案-A：手动复位并重试" class="headerlink" title="方案 A：手动复位并重试"></a>方案 A：手动复位并重试</h4><ol><li>在 IDE “上传” 开始时，先手动按住 BOOT（IO0），</li><li>松开后短按 EN（RST），</li><li>等看到 “Connecting…” 后再松开 BOOT，<br> 这样可以用更可控的速度让 ESP 进入下载模式并重启，IDE 往往就能顺利完成复位后重连。</li></ol><h4 id="方案-B：微调自动复位脉冲"><a href="#方案-B：微调自动复位脉冲" class="headerlink" title="方案 B：微调自动复位脉冲"></a>方案 B：微调自动复位脉冲</h4><ul><li><strong>缩短耦合电容</strong>：把 DTR→EN 的 0.1 µF 改成 0.047 µF 或在 EN 上拉电阻并联更小的电容（如 47 nF），让复位脉冲更窄，USB-串口的掉线时间更短。</li><li><strong>加延时脚本</strong>：在 PlatformIO 或 Arduino 的烧录脚本里，在复位后等待 50–100 ms 再去打开串口。</li></ul><h4 id="方案-C：加缓冲电路"><a href="#方案-C：加缓冲电路" class="headerlink" title="方案 C：加缓冲电路"></a>方案 C：加缓冲电路</h4><ul><li>在 EN 节点上再并联一个 <strong>1 kΩ + 100 nF</strong> 的 RC 滤波，软化复位沿，让 ESP 復位更平滑、USB-串口不至于“咔嚓”断线太久。</li><li>或者在 DTR→C→Q1 前串个 <strong>22 Ω</strong> 小电阻，限制脉冲幅度，减少对 USB-串口掉线的影响。</li></ul><h2 id="更新版本"><a href="#更新版本" class="headerlink" title="更新版本"></a>更新版本</h2><p>在网页版打开备份就可以导入了</p><h3 id="二、无法进入下载模式（）"><a href="#二、无法进入下载模式（）" class="headerlink" title="二、无法进入下载模式（）"></a>二、无法进入下载模式（）</h3><h3 id="三、一直重启，串口打印0xfffffff"><a href="#三、一直重启，串口打印0xfffffff" class="headerlink" title="三、一直重启，串口打印0xfffffff"></a>三、一直重启，串口打印0xfffffff</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>USB不识别端口号</title>
      <link href="/2025/04/29/138-usb-bu-shi-bie-duan-kou-hao/"/>
      <url>/2025/04/29/138-usb-bu-shi-bie-duan-kou-hao/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>起因</strong>：你将电脑 USB 口与 Type-C 口连接时，Type-C接口的<strong>引脚短路</strong>了。</p><p><strong>症状</strong>：</p><ul><li>短路时，电脑右下角不断弹出 “电压不足”、”无法驱动”之类的警告。</li><li>修复短路后，再插入设备，<strong>这个 USB 口无法识别串口设备</strong>（即 COM 口不出现了）</li></ul><h3 id="可能原因分析"><a href="#可能原因分析" class="headerlink" title="可能原因分析"></a>可能原因分析</h3><ol><li><strong>USB控制器过流保护触发</strong><ul><li>电脑主板的 USB 控制器检测到了异常（短路&#x2F;过流），<strong>关闭了该端口供电或通信</strong>。</li><li>有些主板会<strong>自动恢复</strong>，有些则需要<strong>重启</strong>，甚至部分严重情况要关机断电。</li></ul></li><li><strong>端口物理损坏</strong><ul><li>如果短路电流过大，有可能烧掉了<strong>USB控制器芯片</strong>、<strong>保护电路</strong>或者<strong>端口自身</strong>。</li><li>这种情况，硬件损坏，修复起来就比较复杂了。</li></ul></li><li><strong>驱动程序异常</strong><ul><li>短路可能导致 Windows&#x2F;系统<strong>错误地禁用了对应的 USB 端口</strong>。</li><li>可能需要重新扫描硬件、重装驱动。</li></ul></li><li><strong>设备本身受损</strong><ul><li>如果你的 Type-C 设备也遭遇电击或者过流，有可能<strong>设备内部损坏</strong>，导致即使插在好的 USB 口上也无法识别。</li></ul></li></ol><h3 id="解决步骤（按由简到难的顺序来）"><a href="#解决步骤（按由简到难的顺序来）" class="headerlink" title="解决步骤（按由简到难的顺序来）"></a>解决步骤（按由简到难的顺序来）</h3><ol><li><strong>彻底关机断电</strong><ul><li><strong>正常关机</strong>（不是重启）。</li><li><strong>拔掉电源</strong>（台式机要断掉电源开关，笔记本最好也断掉电池或者等几分钟放电）。</li><li>等 5 分钟后重新开机。这是为了清空主板的<strong>保护状态</strong>，有些 USB 保护芯片需要断电才能复位。</li></ul></li><li><strong>检查其他 USB 口</strong><ul><li>换一个正常的 USB 口试试，如果其他口可以识别，基本可以确认是个别端口的问题。</li><li>如果其他口也出问题，可能是<strong>控制器部分损坏</strong>了。</li></ul></li><li><strong>设备管理器检查</strong><ul><li>打开 Windows 设备管理器（<code>Win+X</code> → <code>设备管理器</code>）。</li><li>查看“端口 (COM 和 LPT)”和“通用串行总线控制器”项。</li><li>看是否有<strong>黄色感叹号</strong>或者<strong>未知设备</strong>，右键卸载掉出问题的设备，再点击菜单栏上的“扫描检测硬件改动”。</li></ul></li><li><strong>BIOS设置检查</strong><ul><li>有些主板在检测到严重 USB 错误后，<strong>BIOS会关闭部分端口</strong>。</li><li>重启时进 BIOS，检查 USB 端口是否被禁用。</li></ul></li><li><strong>硬件进一步确认</strong><ul><li>如果以上操作无效，可能就是硬件损坏了。轻度损坏可能只是某个端口（可以禁用不用），严重的话则可能需要更换主板或者外接 USB Hub。</li></ul></li><li><strong>外接 USB Hub 作为替代方案</strong><ul><li>如果损坏的是电脑自带的 USB 口，而主控制器还能用，可以接一个有独立供电的 USB Hub（带电源适配器那种），用 Hub 的端口代替坏掉的端口。</li></ul></li></ol><hr><h3 id="补充建议"><a href="#补充建议" class="headerlink" title="补充建议"></a>补充建议</h3><ul><li>短路后尽量<strong>不要反复插拔</strong>，容易加剧损坏。</li><li>检查 Type-C 线材或模块本身是否有损伤，<strong>确认短路源彻底排除</strong>。</li><li>如果串口通讯对你很重要（比如开发板、调试设备），建议买一块<strong>独立的 USB 转串口模块</strong>，能更安全地调试。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>测量电源纹波</title>
      <link href="/2025/04/17/137-ce-liang-dian-yuan-wen-bo/"/>
      <url>/2025/04/17/137-ce-liang-dian-yuan-wen-bo/</url>
      
        <content type="html"><![CDATA[<h2 id="测量工具"><a href="#测量工具" class="headerlink" title="测量工具"></a>测量工具</h2><ul><li>示波器</li><li>万用表</li></ul><h2 id="示波器测量电源纹波"><a href="#示波器测量电源纹波" class="headerlink" title="示波器测量电源纹波"></a>示波器测量电源纹波</h2><ul><li>（按对应通道按键设置例CH1）</li><li>交流耦合</li><li>带宽显示20MHZ（过高会有高频噪声）</li><li><code>x10 </code>+ <code>x10</code>的探头</li><li>一般20mv，20ms以上（这个设置低了，超过太多的看不到）</li><li>接地弹簧</li><li>auto</li><li>带负载与空载均需要测试</li></ul><h3 id="🔧-推荐测点："><a href="#🔧-推荐测点：" class="headerlink" title="🔧 推荐测点："></a>🔧 推荐测点：</h3><ul><li>测量点 &#x3D; 电源滤波电容正端（靠近负载）</li><li>接地点 &#x3D; 该电容负端（靠近GND面）</li><li>探头贴近焊盘，线尽可能短</li></ul><h2 id="PCB问题"><a href="#PCB问题" class="headerlink" title="PCB问题"></a>PCB问题</h2><ol><li><strong>PCB布局未形成有效“电流环闭合路径”</strong></li></ol><p>从你的第二张 PCB 图可以看出：</p><ul><li>电感 L2 与 C8~C11 的<strong>GND 走线偏细或绕线过长</strong></li><li>电容布在一起，但并没有<strong>尽量靠近实际负载（如U12或主控）</strong></li><li>电源线与地回路不够对称，<strong>GND平面割裂严重</strong></li></ul><ol start="2"><li><strong>电容ESR叠加&#x2F;电容摆放不当</strong></li></ol><ul><li>你用了多个 MLCC（多层陶瓷电容）并联，如果它们走线不等长、没有共同的接地短路径，<strong>等效串联阻抗（ESR）会相互抵消或增强纹波</strong></li><li>最好每个大电容 + 一个 100nF，且靠近负载芯片或高频源（如DC-DC）</li></ul><hr><ol start="3"><li><strong>滤波电感参数不匹配实际纹波频率</strong></li></ol><ul><li>如果你后面接的是 <strong>开关频率在 500kHz~1MHz</strong> 的 DC-DC，但你用了 4.7uH 电感 + 电容组合</li><li>那么 LC 滤波器的截止频率未必刚好覆盖纹波主频</li></ul><p>fc&#x3D;12πLC≈33kHz（对L&#x3D;4.7uH，C&#x3D;22uF）f_c &#x3D; \frac{1}{2\pi\sqrt{LC}} ≈ 33kHz（对 L&#x3D;4.7uH，C&#x3D;22uF）fc&#x3D;2πLC1≈33kHz（对L&#x3D;4.7uH，C&#x3D;22uF）</p><p>→ 对高频纹波（如 500kHz）可能衰减有限</p><h2 id="纹波优化方案"><a href="#纹波优化方案" class="headerlink" title="纹波优化方案"></a>纹波优化方案</h2><ul><li>电源头</li></ul><p><strong>方案一：改善PCB布局（首推）</strong></p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>电容尽量贴近负载或电源引脚</td><td>降低高频回路阻抗</td></tr><tr><td>所有滤波电容共用一块“完整接地面”</td><td>防止回路漂移、地弹效应</td></tr><tr><td>GND 必须为大面积实心平面</td><td>避免切割地平面造成电磁干扰</td></tr><tr><td>电感前电容（C8）接地更短、更粗</td><td>保证高频能量快速回路闭合</td></tr></tbody></table><p><strong>方案二：电容组合优化</strong></p><table><thead><tr><th>动作</th><th>说明</th></tr></thead><tbody><tr><td>为每个大电容搭配一个 0.1uF 的贴片陶瓷电容</td><td>高频旁路有效，贴近芯片引脚</td></tr><tr><td>保持单个高频电容（如 C12）靠近负载主控电源脚</td><td>而非都放一排</td></tr><tr><td>确认电容为 X5R&#x2F;X7R 型号（低ESR）</td><td>陶瓷贴片电容优于钽电容</td></tr></tbody></table><hr><p><strong>方案三：必要时替换电感或加 LC 级联</strong></p><table><thead><tr><th>动作</th><th>说明</th></tr></thead><tbody><tr><td>增加二级 LC 结构（两段 L+C）</td><td>提高滤波深度</td></tr><tr><td>替换为 2.2uH 或 10uH 进行实验</td><td>结合开关频率实际纹波频点调整 LC 截止频率</td></tr></tbody></table><p><a href="https://blog.csdn.net/tian362/article/details/125222134">电源测试周之电压纹波测试注意事项_纹波为什么要在20mhz下测试-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常用DC-DC芯片方案</title>
      <link href="/2025/04/16/136-chang-yong-dc-dc-xin-pian-fang-an/"/>
      <url>/2025/04/16/136-chang-yong-dc-dc-xin-pian-fang-an/</url>
      
        <content type="html"><![CDATA[<h2 id="DC-DC"><a href="#DC-DC" class="headerlink" title="DC-DC"></a>DC-DC</h2><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="left"></th></tr></thead><tbody><tr><td align="center">SY8089A1AAC</td><td align="center">2A</td><td align="center">2.5V~5.5V</td><td align="left">1.2&#x2F;1.8&#x2F;3.3V</td></tr><tr><td align="center">TPS62097RWKR</td><td align="center">2A</td><td align="center">2.5V~6V</td><td align="left">1.8V&#x2F;3.3V</td></tr><tr><td align="center">SY8843QWC</td><td align="center">3A</td><td align="center">2.7V~5.5V</td><td align="left">1.8&#x2F;3.3V</td></tr></tbody></table><h2 id="发热问题"><a href="#发热问题" class="headerlink" title="发热问题"></a>发热问题</h2><p>功率&#x3D;压差×电流</p><p>所以——<strong>芯片不管是谁，只要输入输出电压差和负载电流一样，热功耗 P 是相等的。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> DC-DC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOS管与开关电路</title>
      <link href="/2025/04/14/135-mos-guan-yu-kai-guan-dian-lu/"/>
      <url>/2025/04/14/135-mos-guan-yu-kai-guan-dian-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="Mos管"><a href="#Mos管" class="headerlink" title="Mos管"></a>Mos管</h1><ul><li>vgstj（阈值电压）</li><li>rdson（导通电阻）</li><li>cgs（寄生电容，影响开关时间，与rdson呈反比）</li></ul><img src="/2025/04/14/135-mos-guan-yu-kai-guan-dian-lu/1748505029921.png" class="" width="1748505029921"><img src="/2025/04/14/135-mos-guan-yu-kai-guan-dian-lu/1749801559251.png" class="" width="1749801559251"><p><strong>PMOS</strong>管,体二极管的方向相反</p><h2 id="NMOS"><a href="#NMOS" class="headerlink" title="NMOS"></a>NMOS</h2><h3 id="AO3400A"><a href="#AO3400A" class="headerlink" title="AO3400A"></a>AO3400A</h3><ul><li><p>1个N沟道 耐压:30V 电流:5.8A</p></li><li><p><strong>阈值电压：1.4v</strong></p></li></ul><img src="/2025/04/14/135-mos-guan-yu-kai-guan-dian-lu/1748574878064.png" class="" width="1748574878064"><h3 id="低边开关（Low-Side-Switch）"><a href="#低边开关（Low-Side-Switch）" class="headerlink" title="低边开关（Low-Side Switch）"></a>低边开关（Low-Side Switch）</h3><h3 id="1-电路形式"><a href="#1-电路形式" class="headerlink" title="1. 电路形式"></a>1. 电路形式</h3><pre class="line-numbers language-none"><code class="language-none">+VCC ──→── 负载 ──→──●───┐                    │   │                   漏(D) Q1(N-MOS)                   源(S)                    │                   GND<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Q1</strong>：通常选用 N 沟道（N-MOS），因为其电子迁移率高、导通电阻低、成本低。</li><li><strong>门极(G)</strong>：直接由 MCU GPIO（3.3 V 或 5 V）驱动即可，只要保证 V<sub>GS</sub> ≥ V<sub>th</sub>（门源阈值，一般 2–4 V）就能导通。</li></ul><h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h3><ul><li><strong>开通</strong>：GPIO 输出高电平（Vsense≈3.3 V），若 V<sub>GS</sub>&#x3D;3.3 V–0 V&#x3D;3.3 V ≥ 阈值，Q1 导通，负载接地，电流流过。</li><li><strong>关闭</strong>：GPIO 输出低电平（0 V），V<sub>GS</sub>&#x3D;0 V–0 V&#x3D;0 V＜阈值，Q1 截止，负载无回路，断电。</li></ul><h3 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>驱动简单：门极相对地 (Source&#x3D;GND)</td><td>负载公共端浮动：地被切断，会影响 EMI／共模噪声</td></tr><tr><td>N-MOS 导通阻抗低</td><td>无法切断负载对地的干扰电流</td></tr><tr><td>成本低，布局方便</td><td>负载地线电位不稳定时会给 MCU 带来风险</td></tr></tbody></table><h2 id="PMOS"><a href="#PMOS" class="headerlink" title="PMOS"></a>PMOS</h2><hr><h3 id="高边开关（High-Side-Switch）"><a href="#高边开关（High-Side-Switch）" class="headerlink" title="高边开关（High-Side Switch）"></a>高边开关（High-Side Switch）</h3><h3 id="1-P-沟道-MOSFET-简单高边开关"><a href="#1-P-沟道-MOSFET-简单高边开关" class="headerlink" title="1. P 沟道 MOSFET 简单高边开关"></a>1. P 沟道 MOSFET 简单高边开关</h3><pre class="line-numbers language-none"><code class="language-none">+VCC ──●─── 源(S) Q2(P-MOS) 漏(D)───→── 负载 ──→── GND       │      R_pullup      100 kΩ       │     Gate ←─ MCU GPIO (3.3 V)／R_gate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Q2</strong>：P 沟道 MOSFET，源极接 +VCC，漏极接负载。</li><li><strong>上拉电阻</strong> R_pullup：保证 Gate 默认与 +VCC 同电位，Q2 关断。</li><li><strong>门极驱动</strong>：MCU 低电平拉 Gate→V<sub>GS</sub>&#x3D;0–VCC＜0→Q2 导通；MCU 高电平（3.3 V）时，R_pullup 将 Gate 拉回 +VCC→V<sub>GS</sub>&#x3D;VCC–VCC&#x3D;0 V→Q2 关断。</li><li></li></ul><h3 id="2-N-沟道-MOSFET-“驱动-高边”-方案"><a href="#2-N-沟道-MOSFET-“驱动-高边”-方案" class="headerlink" title="2. N 沟道 MOSFET “驱动+高边” 方案"></a>2. N 沟道 MOSFET “驱动+高边” 方案</h3><pre class="line-numbers language-none"><code class="language-none">+VCC ──●─── 源(S) Q3(N-MOS) 漏(D)───→── 负载 ──→── GND       │      Boot-strap &#x2F; 驱动芯片         ┌───────────┐         │ Gate Driver│         └───────────┘              │             MCU<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Q3</strong>：N 沟道 MOSFET 导通电阻更低，适合大电流场合。</li><li><strong>高边驱动器</strong>：利用升压（Charge Pump）或 Boot-strap 电路，将 Gate 提升到比 +VCC 更高（如 VCC+10 V），保证 V<sub>GS</sub> ≥ V<sub>th</sub>。</li><li><strong>应用</strong>：电机驱动、电源管理 IC、通信开关等对效率和热量敏感的场合。</li></ul><h3 id="3-工作原理要点"><a href="#3-工作原理要点" class="headerlink" title="3. 工作原理要点"></a>3. 工作原理要点</h3><table><thead><tr><th>方案</th><th>导通条件</th><th>关断条件</th><th>驱动难度</th></tr></thead><tbody><tr><td>P-MOS 高边</td><td>Gate 拉低 V<sub>GS</sub>&#x3D;0–VCC＜0</td><td>Gate&#x3D;VCC V<sub>GS</sub>&#x3D;0</td><td>MCU 3.3 V 直接可行</td></tr><tr><td>N-MOS+驱动 高边</td><td>Gate 驱到 VCC+ΔV</td><td>Gate≈0 或&#x3D;VCC 断开</td><td>需外部驱动芯片&#x2F;电荷泵</td></tr></tbody></table><hr><h2 id="门极驱动与保护"><a href="#门极驱动与保护" class="headerlink" title="门极驱动与保护"></a>门极驱动与保护</h2><ol><li><strong>门极限流电阻</strong>（50–200 Ω）：抑制寄生电容充放电冲击，防止振铃。</li><li><strong>栅极保护二极管</strong>：防止 Gate–Source 过压、ESD 损伤。</li><li><strong>驱动电平匹配</strong>：确保 V<sub>GS(max)</sub>（常 ±20 V）不被超越。</li><li><strong>布线与旁路</strong>：靠近 MOSFET 放置小型旁路电容（100 nF）和大容量电解&#x2F;铝电容，抑制突发电流。</li></ol><p><strong>高边开关 vs. 低边开关</strong></p><table><thead><tr><th>特性</th><th>低边开关 (Low-side)</th><th>高边开关 (High-side)</th></tr></thead><tbody><tr><td><strong>开关位置</strong></td><td>负极 (GND) 端串接开关</td><td>正极 (VCC) 端串接开关</td></tr><tr><td><strong>常用器件</strong></td><td>N 沟道 MOSFET</td><td>P 沟道 MOSFET &#x2F; PNP &#x2F; 专用高边开关 IC</td></tr><tr><td><strong>驱动电平</strong></td><td>Gate 只要相对于 GND 提高到 ≥V<sub>th</sub> 即可</td><td>P 沟端要拉到低于 VCC-V<sub>th</sub>，3.3 V IO 直接很难关断</td></tr><tr><td><strong>优点</strong></td><td>驱动简单：ESP32 3.3 V 即可；导通阻抗低；成本低</td><td>负载始终与地共地，模拟测量更直观；对地参考不变</td></tr><tr><td><strong>缺点</strong></td><td>负载地浮空时，有时候测量参考地不方便</td><td>P 沟 R<sub>DS(on)</sub> 通常比 N 沟高；要做电平移位；成本略高</td></tr></tbody></table><h3 id="何时用哪一种？"><a href="#何时用哪一种？" class="headerlink" title="何时用哪一种？"></a>何时用哪一种？</h3><ul><li><strong>对地信号敏感（要测 GND 侧电压）</strong><br> 推荐用 <strong>高边开关</strong>，负载地不可切断。</li><li><strong>只需控制通／断，又要地参考一致</strong><br> <strong>低边开关</strong> 最简单，用 N 沟 MOSFET 接地端即可。</li></ul><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>你的电路里，Q4 接在 module GND 侧，属于 <strong>低边开关</strong>。只要把 Q4 的 Source 直接接地，Gate 上拉电阻 R22 去掉，就能保证 ESP32 3.3 V 驱动有效关断&#x2F;导通。</li><li>如果未来想把开关放在 VCC 侧，就要换成 P 沟 MOSFET（或专用高边开关 IC）＋一个 N 沟做电平移位，才能用 3.3 V GPIO 控制 5 V VCC。</li></ul><p>这样你就既校验了原理图，也清楚了高、低边开关的原理和选型思路。祝顺利！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>mos管可做开关使用，nmos比较常用，G极高，则导通，G低则断开，另外，G极通常串联两个电阻，一个是用来<code>限制电流，抑制震荡</code>的,一个是用来<code>下拉到地</code>的。</p><p><strong>注意:</strong></p><blockquote><p>首先单片机io电压要高于<code>vgsth</code>,比如3.3v单片机选择<code>AO3400A</code>,vgsth为1.4v就可以,不可以太大或者太小,会出现无法驱动或者失去开关作用问题</p></blockquote><h1 id="开关电路图"><a href="#开关电路图" class="headerlink" title="开关电路图"></a>开关电路图</h1><p>这个是按键控制上电状态的电路图</p><img src="/2025/04/14/135-mos-guan-yu-kai-guan-dian-lu/1744782871788.png" class="" width="1744782871788"><p>注意：</p><p>供电电流不能太小，否则会一直自动重启</p><p><strong>基础开关电路的理解</strong></p><p>上半部分是开关机电路，首先Key_BAT被拉高，按键按下后被拉低，mcu控制BAT_Control拉高保持，NPN三极管高电平导通导致AO3401 PMOS的栅极G被拉低，使MOS管导通。</p><p><strong>右下角电路是电源切换电路</strong></p><p>当电池供电时，Q2的栅极为低电平，Q2截止，但是通过体二极管，将VCC缓慢拉高为4.7V</p><p>当usb供电时，Vg由于下拉电阻，电压远小于5v，Vcc&#x3D;5v（如下图可见）,Vgs&lt;0，Q2导通</p><p><strong>还是有点困惑</strong></p><p><a href="https://chatgpt.com/share/685e6742-ea44-8008-8e6b-942e1cbcd014">https://chatgpt.com/share/685e6742-ea44-8008-8e6b-942e1cbcd014</a></p><img src="/2025/04/14/135-mos-guan-yu-kai-guan-dian-lu/1755150245962.png" class="" width="1755150245962"><img src="/2025/04/14/135-mos-guan-yu-kai-guan-dian-lu/1755136464584.png" class="" width="1755136464584"><p>这是开关机电路，当检测到按键按下的时候电路导通，且拉高PCA_IO0_6为高电平，NPN三极管导通，使Pmos持续导通。</p><p>⚠️：<strong>三极管需要下拉电阻</strong>，且下拉电阻要在限流电阻的左边</p><h2 id="NPN-三极管（S8050）开关电路"><a href="#NPN-三极管（S8050）开关电路" class="headerlink" title="NPN 三极管（S8050）开关电路"></a>NPN 三极管（S8050）开关电路</h2><ul><li><strong>原理</strong><ul><li>PCA9555 → 基极电阻 → NPN (S8050) → 控制 PMOS 栅极 → 传感器电源。</li><li>高电平 → NPN 导通 → 栅极低 → PMOS 开 → 电源接通；</li><li>低电平 → NPN 截止 → 栅极被上拉 → PMOS 关断。</li></ul></li><li><strong>问题</strong><ul><li>IO 高电平只有 2.6 V，而不是 3.3 V。</li><li>关断时 VCC_OUT 仍有 2.6 V，不完全关断。</li></ul></li><li><strong>分析</strong><ol><li>IO 电平被基极电流钳位 → 压低到 2.6 V；</li><li>NPN 未完全截止，栅极未被拉到 3.3 V；</li><li>PMOS Vgs 没完全为 0，半导通。</li></ol></li><li><strong>解决方案</strong><ul><li>基极电阻 <strong>1k → 4.7k–10k</strong>；</li><li>在基极加 <strong>47k 下拉</strong>；</li><li>在 PMOS 栅极加 <strong>10k 上拉</strong>；</li><li>必要时更换 PMOS 型号，选择 Vgs(th) 较高、漏电小的型号。</li></ul></li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/CodeWorkerLiMing/p/12007346.html">MOS管做开关之初理解 - wdliming - 博客园</a></p><p><a href="https://blog.csdn.net/weixin_44115082/article/details/109193826">MOS管的使用_mos管限流电路-CSDN博客</a></p><p><a href="https://www.bilibili.com/video/BV1Mb4y1k7fd?spm_id_from=333.788.videopod.sections&vd_source=e33ad22b3d91cb180bef532ce5877b2e">【知识】既然有了nmos 为啥还要pmos_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32_C3_BLE</title>
      <link href="/2025/04/10/133-esp32-c3-ble/"/>
      <url>/2025/04/10/133-esp32-c3-ble/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ESP32-C3网上的蓝牙资料较少<del>可以说是没有</del></p><h2 id="ESP32-C3蓝牙广播"><a href="#ESP32-C3蓝牙广播" class="headerlink" title="ESP32-C3蓝牙广播"></a>ESP32-C3蓝牙广播</h2><p>使用<code>NimBLE-Arduino</code>库</p><p>没有文档，只有demo，gpt的库也有错误，先让gpt添加注释，再继续修改</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>随着广播数据的增多，接收端越来越难一个周期内接到所有数据，每个周期的iv还是不同的，所以会导致一直连接不上</p><blockquote><p>不对，随机iv再setup里面，所以是因为收发不同步的问题，导致有一部分数据永远也接收不到</p><p>这个就是调整三个地方，重复次数，周期时间，延时时间</p></blockquote><p><strong>关键</strong></p><p><code>pBLEScan-&gt;start(0, true);</code></p><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>1.常错</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">std::string manData &#x3D; advertisedDevice.getManufacturerData();Compilation error: conversion from &#39;String&#39; to non-scalar type &#39;std::string&#39; &#123;aka &#39;std::__cxx11::basic_string&lt;char&gt;&#39;&#125; requested<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><code>advertisedDevice.getManufacturerData()</code> 返回 <strong>Arduino String 类型</strong></p><p>你尝试 <strong>直接赋值给 std::string，但不兼容</strong></p><p><strong>解决方法</strong>：改用 <strong>Arduino String</strong>，或者 <strong>手动转换为 std::string</strong></p></blockquote><p>注意</p><p>platform添加库的时候，没有特殊说明不要加上版本，容易用到旧版本，不支持新的api</p><h2 id="CBC加密广播"><a href="#CBC加密广播" class="headerlink" title="CBC加密广播"></a>CBC加密广播</h2><p><strong>问题点</strong></p><p>串口乱码</p><p>你在串口中这样打印：</p><pre class="line-numbers language-none"><code class="language-none">Serial.printf(&quot;📡 发送段 [%04X]: %s\n&quot;, segmentID, mData.c_str());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但 <code>mData</code> 是<strong>原始二进制数据（密文）</strong>，它可能包含：</p><ul><li>控制字符（如 <code>0x01</code>, <code>0x0A</code>, <code>0x13</code>）</li><li>UTF-8 非法字节</li><li>串口不能解析的转义字符</li></ul><p>所以 <code>%s</code> 打印出来就变成乱码或花屏。</p><p>请把这一行：</p><pre class="line-numbers language-none"><code class="language-none">Serial.printf(&quot;📡 发送段 [%04X]: %s\n&quot;, segmentID, mData.c_str());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>替换为：</p><pre class="line-numbers language-none"><code class="language-none">Serial.printf(&quot;📡 发送段 [%04X]: &quot;, segmentID);for (size_t i &#x3D; 0; i &lt; mData.length(); i++) &#123;    Serial.printf(&quot;%02X &quot;, (uint8_t)mData[i]);&#125;Serial.println();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32_MQTT_OTA</title>
      <link href="/2025/04/07/125-esp32-mqtt-ota/"/>
      <url>/2025/04/07/125-esp32-mqtt-ota/</url>
      
        <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h2 id="OTA"><a href="#OTA" class="headerlink" title="OTA"></a>OTA</h2><h3 id="✅-第二步：准备-OTA-固件（v2-0）"><a href="#✅-第二步：准备-OTA-固件（v2-0）" class="headerlink" title="✅ 第二步：准备 OTA 固件（v2.0）"></a>✅ 第二步：<strong>准备 OTA 固件（v2.0）</strong></h3><p>将这个代码编译为你想升级的新版本，比如 v2.0：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;Arduino.h&gt;void setup() &#123;  Serial.begin(115200);  delay(1000);  Serial.println(&quot;✅ Hello from OTA-updated firmware v2.0!&quot;);&#125;void loop() &#123;  Serial.println(&quot;🔁 Running new firmware...&quot;);  delay(3000);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>编译后拿到 <code>.pio/build/esp32dev/firmware.bin</code>，放在 Python HTTP 服务器目录下。</p></blockquote><h2 id="✅-第三步：运行-Python-OTA-服务器"><a href="#✅-第三步：运行-Python-OTA-服务器" class="headerlink" title="✅ 第三步：运行 Python OTA 服务器"></a>✅ 第三步：<strong>运行 Python OTA 服务器</strong></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">cd &lt;含 firmware.bin 的目录&gt;python -m http.server 8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>控制台会显示：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Serving HTTP on :: port 8080 ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>1.ESP32连接超时</p><p>如果 <code>http://localhost:8080/firmware.bin</code> 可以访问，而 <code>http://192.168.71.88:8080/firmware.bin</code> 无法访问，那么说明你本地服务器只绑定了 <code>localhost</code> 地址（即只对本机可见），并没有对外网或者局域网开放。为了让 ESP32 设备通过 <code>192.168.71.88</code> 地址访问，你需要让服务器绑定到 <code>0.0.0.0</code> 或者明确绑定到局域网的 IP 地址。</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><hr><h4 id="1-确认服务器绑定到局域网-IP（0-0-0-0）"><a href="#1-确认服务器绑定到局域网-IP（0-0-0-0）" class="headerlink" title="1. 确认服务器绑定到局域网 IP（0.0.0.0）"></a>1. <strong>确认服务器绑定到局域网 IP（0.0.0.0）</strong></h4><p>确保你启动的 Python 服务器监听所有接口（0.0.0.0），而不仅仅是本地 <code>localhost</code>。你可以通过以下命令重新启动服务器：</p><pre class="line-numbers language-none"><code class="language-none">python -m http.server 8080 --bind 0.0.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者明确绑定到你的局域网 IP（在你的情况下是 <code>192.168.71.92</code>）：</p><pre class="line-numbers language-none"><code class="language-none">python -m http.server 8080 --bind 192.168.71.92<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将确保你在 <strong>任何设备</strong>（包括 ESP32）上都可以访问 <code>http://192.168.71.92:8080/firmware.bin</code>。</p><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2025/04/07/132-git/"/>
      <url>/2025/04/07/132-git/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-指令速查"><a href="#Git-指令速查" class="headerlink" title="Git 指令速查"></a>Git 指令速查</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td><code>git status</code></td><td>查看工作区和暂存区状态</td></tr><tr><td><code>git diff</code></td><td>查看未暂存的改动</td></tr><tr><td><code>git diff --staged</code></td><td>查看已暂存但未提交的改动</td></tr><tr><td><code>git log</code></td><td>查看提交历史</td></tr><tr><td><code>git branch</code></td><td>列出本地分支</td></tr><tr><td><code>git branch -r</code></td><td>列出远程分支</td></tr><tr><td><code>git checkout &lt;分支名&gt;</code></td><td>切换分支</td></tr><tr><td><code>git checkout -b &lt;新分支&gt;</code></td><td>新建并切换到分支</td></tr><tr><td><code>git merge &lt;分支&gt;</code></td><td>合并指定分支到当前分支</td></tr></tbody></table><p>⚠️：<strong>多个本地端推送一定要先拉取最新仓库</strong></p><ol><li><p>切到主干分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git checkout main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>拉取并以变基方式更新到远程最新：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git pull --rebase origin main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>这样本地的 <code>main</code> 就会同步到远程的最新提交。之后再从 <code>main</code> 分出一个 feature 分支去开发，就能保证你的改动是基于最新代码进行的，避免后续合并冲突</p><p>执行git pull的时候，相当于以此执行了下面的结合体</p><ul><li>git fetch ：从云端拉取最新代码</li><li>git merge：将云端代码与本地代码合并</li></ul><p><a href="https://mp.weixin.qq.com/s/n1KbNaT46SwVPCBxpW31ow">使用git pull拉取代码</a></p><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><ol><li><p><strong>进入项目目录</strong><br> 在资源管理器中右键 → <strong>Git Bash Here</strong></p></li><li><p><strong>初始化本地仓库</strong></p><pre class="line-numbers language-none"><code class="language-none">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>配置全局用户信息</strong><br> 仅需首次配置，或者当你换了机器／账户时再执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git config --global user.name  &quot;HaxIOX&quot;git config --global user.email &quot;isgeek01@gmail.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 本地用户配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git config user.name  &quot;whh&quot;git config user.email &quot;email&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">git config --get user.name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">git config --get user.email<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看当前配置**</p><pre class="line-numbers language-none"><code class="language-none">git config --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>1.在文件夹下<strong>git bash here</strong></p><h2 id="Clone-远程仓库"><a href="#Clone-远程仓库" class="headerlink" title="Clone 远程仓库"></a>Clone 远程仓库</h2><ul><li><p><strong>HTTPS 方式</strong></p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;账户:密码....detector.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>SSH 方式</strong></p><pre class="line-numbers language-none"><code class="language-none">git clone ..地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="添加、提交与推送"><a href="#添加、提交与推送" class="headerlink" title="添加、提交与推送"></a>添加、提交与推送</h2><ol><li><p><strong>将修改或新文件加入暂存区</strong></p><pre class="line-numbers language-none"><code class="language-none">git add .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或针对单个文件：</p><pre class="line-numbers language-none"><code class="language-none">git add path&#x2F;to&#x2F;file.ext<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>提交（Commit）</strong></p><pre class="line-numbers language-none"><code class="language-none">git commit -m &quot;Add core feature list to README&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-m</code> 后面跟的是本次提交的<strong>简洁描述</strong>。</li></ul></li><li><p><strong>关联远程仓库（首次推送时执行，或切换远程时）</strong></p><pre class="line-numbers language-none"><code class="language-none">git remote add origin &lt;远程仓库地址&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>推送到远程分支</strong></p><pre class="line-numbers language-none"><code class="language-none">git push -u origin main     # 若主分支为 main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>后续只需</p><pre class="line-numbers language-none"><code class="language-none">git push<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><hr><h2 id="拉取更新与-Rebas"><a href="#拉取更新与-Rebas" class="headerlink" title="拉取更新与 Rebas"></a>拉取更新与 Rebas</h2><ul><li><p><strong>拉取远程最新提交并在本地“衔接”</strong></p><pre class="line-numbers language-none"><code class="language-none">git pull origin master --rebase<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>--rebase</code> 会把你的本地提交“移到”刚拉下来的远程最新提交之后，避免产生多余的 merge commit。</p></blockquote></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">VIBTEK@DESKTOP-TG673JB MINGW64 ~&#x2F;Desktop&#x2F;Detector (master)$ git push -u origin mainerror: src refspec main does not match anyerror: failed to push some refs to &#39;codeup.aliyun.com:67975038cfc95bafa621705d&#x2F;drone&#x2F;detector.git&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个错误说明你的远程 <code>master</code> 分支上已经有提交，而你本地的 <code>master</code> 没有包含这些提交，所以 Git 为了防止你不小心覆盖别人工作，拒绝了直接推送。</p><p><code>git fetch origin</code></p><p><code>git merge origin/master</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">VIBTEK@DESKTOP-TG673JB MINGW64 ~&#x2F;Desktop&#x2F;Detector (master)$ git merge origin&#x2F;masterfatal: refusing to merge unrelated histories<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当你在本地和远程各自独立 <code>git init</code> 过一次，两个仓库就没有共同的祖先提交，Git 默认会拒绝合并“无关联历史”。</p><h3 id="合并两端历史"><a href="#合并两端历史" class="headerlink" title="合并两端历史"></a>合并两端历史</h3><ol><li><p><strong>拉取远程并允许合并无关联历史</strong></p><pre class="line-numbers language-none"><code class="language-none">git pull origin master --allow-unrelated-histories<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者先 <code>fetch</code> 再 <code>merge</code>：</p><pre class="line-numbers language-none"><code class="language-none">git fetch origingit merge origin&#x2F;master --allow-unrelated-histories<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>处理可能出现的冲突</strong></p><ul><li>编辑冲突文件，删除冲突标记（<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>、<code>=======</code>、<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>），</li><li><code>git add &lt;已解决文件&gt;</code>，</li><li>最后 <code>git commit</code> 完成这次合并。</li></ul></li><li><p><strong>推送到远程</strong></p><pre class="line-numbers language-none"><code class="language-none">git push -u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>这样，远程原有的内容和你本地的内容都会被保留并合并到一起。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git push origin mainTo github.com:god10000&#x2F;hexo-source.git! [rejected]            main -&gt; main (non-fast-forward)error: failed to push some refs to &#39;github.com:god10000&#x2F;hexo-source.git&#39;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. If you want to integrate the remote changes,hint: use &#39;git pull&#39; before pushing again.hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p><strong>拉取并在本地合并（默认模式）</strong></p><pre class="line-numbers language-none"><code class="language-none">git pull origin main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会把远程 <code>main</code> 的改动合并到你本地的 <code>main</code>，如果有冲突，Git 会提示你手动解决。</p></li><li><p><strong>推送到远程</strong></p><pre class="line-numbers language-none"><code class="language-none">git push origin main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>如果你不想产生多余的“合并提交”，可以改用 rebase 方式：</p><pre class="line-numbers language-none"><code class="language-none">git pull --rebase origin main# 解决冲突后：git push origin main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法二：强制推送（不推荐，除非你确定要覆盖远程）</strong></p><p>如果你确信远程的改动可以被丢弃，或者远程只有你一个人在用，也可以直接强制推送：</p><pre class="line-numbers language-none"><code class="language-none">git push --force origin main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>⚠️ 警告</strong>：强制推送会把远程分支改回你本地的状态，会丢掉远程已有的所有改动。务必在确认没有他人依赖这些提交时才使用。</p></blockquote><h3 id="修改已有远程仓库的地址"><a href="#修改已有远程仓库的地址" class="headerlink" title="修改已有远程仓库的地址"></a>修改已有远程仓库的地址</h3><ol><li><p><strong>查看当前远程地址</strong></p><pre class="line-numbers language-none"><code class="language-none">git remote -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会列出所有远程（如 <code>origin</code>）当前的 fetch 和 push 地址。</p></li><li><p><strong>用新的 URL 覆盖旧的 origin</strong></p><pre class="line-numbers language-none"><code class="language-none">git remote set-url origin &lt;新仓库地址&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，如果你要改成 SSH 地址：</p><pre class="line-numbers language-none"><code class="language-none">git remote set-url origin git@github.com:yourname&#x2F;new-repo.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者 HTTPS 地址：</p><pre class="line-numbers language-none"><code class="language-none">git remote set-url origin https:&#x2F;&#x2F;github.com&#x2F;yourname&#x2F;new-repo.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p><strong>添加远程 origin</strong></p><pre class="line-numbers language-none"><code class="language-none">git remote add origin git@github.com:HaxIOX&#x2F;HaxIOX.github.io.git git remote set-url origin git@github.com:HaxIOX&#x2F;Hexo-source.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Hexo仓库"><a href="#Hexo仓库" class="headerlink" title="Hexo仓库"></a>Hexo仓库</h2><h3 id="修改历史用户名"><a href="#修改历史用户名" class="headerlink" title="修改历史用户名"></a>修改历史用户名</h3><p><strong>源文件</strong></p><h3 id="A-用-git-filter-branch"><a href="#A-用-git-filter-branch" class="headerlink" title="A. 用 git filter-branch"></a>A. 用 <code>git filter-branch</code></h3><blockquote><p><strong>注意</strong>：此命令会重写整个历史，所有提交的 hash 都会变，后续需要强推 (<code>--force</code>) 并告知团队重新拉取。</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git filter-branch --env-filter &#39;OLD_EMAIL&#x3D;&quot;old@example.com&quot;CORRECT_NAME&#x3D;&quot;新用户名&quot;CORRECT_EMAIL&#x3D;&quot;newemail@example.com&quot;if [ &quot;$GIT_COMMITTER_EMAIL&quot; &#x3D; &quot;$OLD_EMAIL&quot; ]then    export GIT_COMMITTER_NAME&#x3D;&quot;$CORRECT_NAME&quot;    export GIT_COMMITTER_EMAIL&#x3D;&quot;$CORRECT_EMAIL&quot;fiif [ &quot;$GIT_AUTHOR_EMAIL&quot; &#x3D; &quot;$OLD_EMAIL&quot; ]then    export GIT_AUTHOR_NAME&#x3D;&quot;$CORRECT_NAME&quot;    export GIT_AUTHOR_EMAIL&#x3D;&quot;$CORRECT_EMAIL&quot;fi&#39; --tag-name-filter cat -- --branches --tags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>把 <code>OLD_EMAIL</code>、<code>CORRECT_NAME</code>、<code>CORRECT_EMAIL</code> 改成你要替换的内容。</p></li><li><p>执行完后，清理备份并压缩仓库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm -rf .git&#x2F;refs&#x2F;original&#x2F;git reflog expire --expire&#x3D;now --allgit gc --prune&#x3D;now --aggressive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>最后<strong>强制推送</strong>到远程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git push --force --tags origin &#39;refs&#x2F;heads&#x2F;*&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="B-用更现代的-git-filter-repo（需要先安装）"><a href="#B-用更现代的-git-filter-repo（需要先安装）" class="headerlink" title="B. 用更现代的 git filter-repo（需要先安装）"></a>B. 用更现代的 <code>git filter-repo</code>（需要先安装）</h3><pre class="line-numbers language-none"><code class="language-none">git filter-repo \  --replace-email &#39;old@example.com&#x3D;newemail@example.com&#39; \  --replace-text &lt;(printf &#39;old-name&#x3D;&gt;新用户名\n&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">git filter-repo --force --commit-callback &#39;# 把所有 author_name、committer_name 为 OldUser 的提交统一改成 git filter-repoif commit.author_name &#x3D;&#x3D; b&quot;wangjiqi&quot;:    commit.author_name &#x3D; b&quot;HaxIOX&quot;if commit.committer_name &#x3D;&#x3D; b&quot;wangjiqi&quot;:    commit.committer_name &#x3D; b&quot;HaxIOX&quot;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体用法可见<a href="https://github.com/newren/git-filter-repo">官方文档</a>。</p><p>或者</p><pre class="line-numbers language-none"><code class="language-none">git filter-repo \  --replace-email 旧邮箱&#x3D;新邮箱 \  --replace-name 旧用户名&#x3D;新用户名 \  --force  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>强制推送</p><pre class="line-numbers language-none"><code class="language-none">git push --force --tags origin +refs&#x2F;heads&#x2F;*:refs&#x2F;heads&#x2F;*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>⚠️记得备份</strong></p><p><strong>html文件</strong></p><p>也就是页面文件</p><blockquote><p>新建文件夹,复制源文件,然后修改仓库地址为静态界面的库,本地用户配置,再执行上面的命令</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MQTT</title>
      <link href="/2025/04/01/130-mqtt-fu-wu-qi/"/>
      <url>/2025/04/01/130-mqtt-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="emqx"><a href="#emqx" class="headerlink" title="emqx"></a><a href="https://so.csdn.net/so/search?q=emqx&spm=1001.2101.3001.7020">emqx</a></h3><ul><li><a href="https://mqttx.app/web-client/#/recent_connections/085eebeb-c5ba-4ed6-8d68-1f74c5ccb579">线上客户端</a></li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> <strong><a href="https://docs.emqx.com/zh/emqx/latest/messaging/mqtt-concepts.html#%E6%9C%8D%E5%8A%A1%E7%AB%AF">服务端</a></strong></p><blockquote><p>在发布消息的客户端和订阅的客户端之间充当中介，将所有接收到的消息转发到匹配的订阅客户端。所以有时我们也会直接将服务端称为 Broker。</p></blockquote><p><strong>所以是无法直接查看消息的，就是中介</strong></p><p>进入bin目录下，按住键盘Shift，鼠标右击打开<a href="https://so.csdn.net/so/search?q=%E7%BB%88%E7%AB%AF%E7%AA%97%E5%8F%A3&spm=1001.2101.3001.7020">终端窗口</a> </p><p>启动软件</p><blockquote><p>输入命令“.\emqx start”启动服务</p></blockquote><blockquote><p>服务器地址<a href="https://so.csdn.net/so/search?q=http&spm=1001.2101.3001.7020">http</a>:&#x2F;&#x2F;localhost:18083&#x2F;</p></blockquote><p>登录MQTT服务器后台管里界面，</p><p>默认账号为“admin”，</p><p>默认密码为“public”</p><p>创建认证</p><p>创建用户</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>ifconfig查看本地ip</p><p>然后写好user，pswd,Esp32使用PubSubClient.h库</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>两个客户端通信需要先订阅同一个主题，才能互相通信</p><p>发布与订阅是独立的，不订阅也可以发布</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/u011425939/article/details/144574619">【MQTT 协议 01】MQTT 服务器搭建_mqtt服务器搭建-CSDN博客</a></p><p><a href="https://docs.emqx.com/zh/emqx/latest/messaging/mqtt-concepts.html">MQTT 核心概念 | EMQX文档</a></p>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Orange Pi</title>
      <link href="/2025/03/30/128-orange-pi-shang-shou/"/>
      <url>/2025/03/30/128-orange-pi-shang-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="Orange-Pi"><a href="#Orange-Pi" class="headerlink" title="Orange Pi"></a>Orange Pi</h1><h2 id="1-连接WiFi"><a href="#1-连接WiFi" class="headerlink" title="1.连接WiFi"></a>1.连接WiFi</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">sudo apt install python3-pip -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nmcli d wifi connect “你的WiFi名称” password “你的WiFi密码”</p><p>ls &#x2F;dev&#x2F;ttyUSB*</p><h2 id="2-启动网络接口"><a href="#2-启动网络接口" class="headerlink" title="2. 启动网络接口"></a><strong>2. 启动网络接口</strong></h2><p>如果你是通过 <strong>Wi-Fi</strong> 连接的，检查无线网络是否启用：</p><pre class="line-numbers language-none"><code class="language-none">sudo ifconfig wlan0 up  # 启用 Wi-Fi 接口sudo dhclient wlan0    # 获取 IP 地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果是 <strong>有线</strong> 连接：</p><pre class="line-numbers language-none"><code class="language-none">sudo ifconfig eth0 up  # 启用以太网接口sudo dhclient eth0    # 获取 IP 地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>配网</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl restart networkingnmcli dev wifi  # 列出可用的 Wi-Fi 网络nmcli dev wifi connect &quot;ssid&quot; password &quot;passward&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">auto wlan0iface wlan0 inet dhcp    wpa-ssid &quot;VIBTEK-2.4G&quot;    wpa-psk &quot;vibrantech@1305-1&quot;sudo nmcli dev wifi connect &quot;VIBTEK-2.4G&quot; password &quot;vibrantech@1305-1&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果你当前使用的是香橙派的 AP（热点）模式</strong>，那么它不会自动连接外部 WiFi，也就 <strong>无法访问互联网</strong>。你需要 <strong>切换回 WiFi 客户端模式</strong> 来连接外网，然后再进行软件安装和更新。</p><hr><h3 id="🚀-1-关闭-AP-模式"><a href="#🚀-1-关闭-AP-模式" class="headerlink" title="🚀 1. 关闭 AP 模式"></a><strong>🚀 1. 关闭 AP 模式</strong></h3><p>你之前使用 <code>create_ap</code> 设置了 AP 模式，现在需要 <strong>关闭它</strong>：</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl stop create_apsudo systemctl disable create_ap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后 <strong>停止 hostapd 和 dnsmasq</strong>（AP 相关服务）：</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl stop hostapdsudo systemctl stop dnsmasq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h3 id="🚀-2-连接外部-WiFi"><a href="#🚀-2-连接外部-WiFi" class="headerlink" title="🚀 2. 连接外部 WiFi"></a><strong>🚀 2. 连接外部 WiFi</strong></h3><p>如果你的 Orange Pi 需要连接外部 WiFi 才能访问互联网，运行：</p><pre class="line-numbers language-none"><code class="language-none">nmcli d wifi list  # 列出可用 WiFinmcli d wifi connect &quot;你的WiFi名称&quot; password &quot;你的WiFi密码&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后检查 <strong>是否成功获取 IP</strong>：</p><pre class="line-numbers language-none"><code class="language-none">ip addr show wlan0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 IP 仍然是 <code>0.0.0.0</code>，尝试：</p><pre class="line-numbers language-none"><code class="language-none">sudo dhclient wlan0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>测试网络是否恢复：</strong></p><pre class="line-numbers language-none"><code class="language-none">ping -c 4 8.8.8.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 <code>ping</code> 成功，你的 Orange Pi <strong>已经联网，可以安装 pyserial 了！</strong></p><hr><p><strong>🚀 3. 重新切换回 AP 模式（可选）</strong></p><p>如果安装完成后，你想重新开启 <strong>AP（热点）模式</strong>：</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl enable create_apsudo systemctl start create_ap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你之前 <strong>手动启动了 hostapd 和 dnsmasq</strong>，也可以手动启动：</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl start hostapdsudo systemctl start dnsmasq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h3 id="🚀-总结"><a href="#🚀-总结" class="headerlink" title="🚀 总结"></a><strong>🚀 总结</strong></h3><p>✅ <strong>关闭 AP 模式，恢复 WiFi 客户端模式</strong></p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl stop create_apsudo systemctl disable create_apsudo systemctl stop hostapdsudo systemctl stop dnsmasq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>✅ <strong>连接外部 WiFi</strong></p><pre class="line-numbers language-none"><code class="language-none">nmcli d wifi connect &quot;WiFi名称&quot; password &quot;WiFi密码&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>✅ <strong>检查网络</strong></p><pre class="line-numbers language-none"><code class="language-none">ping -c 4 8.8.8.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>✅恢复 AP（热点）模式**</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl start create_ap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p> <strong>🔍 为什么 nmcli 失败，而 wpa_supplicant 手动连接可以成功？</strong></p><p>ChatGPT 说：</p><p>这是因为 <strong>nmcli 依赖于 NetworkManager，而 wpa_supplicant 是直接控制 WiFi 适配器的工具</strong>。以下是具体的原因分析：</p><hr><p><strong>🔹 1. nmcli 依赖 NetworkManager</strong></p><p><code>nmcli</code> 是 <code>NetworkManager</code> 的命令行工具，它的工作流程如下：</p><ol><li><strong>检查 NetworkManager 是否运行</strong>（如果 <code>systemctl status NetworkManager</code> 显示 <code>inactive</code>，<code>nmcli</code> 也会失败）。</li><li><strong>通过 NetworkManager 管理 WiFi 适配器</strong>，但如果 <code>NetworkManager</code> 没有正确检测到 <code>wlan0</code>，它就无法管理 WiFi 连接。</li><li><strong>如果 wlan0 处于 Master 模式（AP模式）或者被 rfkill 软禁用</strong>，<code>nmcli</code> 可能不会自动调整状态，而是直接报错。</li></ol><p>🛑 <strong>如果 NetworkManager 没有正确管理 wlan0，那么 nmcli 就会失败！</strong></p><h3 id="AP配网"><a href="#AP配网" class="headerlink" title="AP配网"></a>AP配网</h3><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>![1742957043881](Orange Pi&#x2F;1742957043881.png)</p><p>你的 <code>dnsmasq</code> <strong>启动成功</strong>，但日志显示：</p><pre class="line-numbers language-none"><code class="language-none">Failed to set DNS configuration: Unit dbus-org.freedesktop.network1.service not found.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个错误意味着 <strong>系统缺少 systemd-networkd 相关的服务</strong>，可能会导致 <strong>连接 WiFi 但无法获取 IP</strong>。</p><p><strong>🔹 2. 修复 systemd-networkd 服务</strong></p><p>如果 <code>dnsmasq</code> 依赖的 <code>dbus-org.freedesktop.network1.service</code> <strong>不存在</strong>，可能是 <code>systemd-networkd</code> <strong>未安装或未启动</strong>。</p><p>检查：</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl status systemd-networkd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 <strong>未安装</strong>，安装它：</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install systemd-networkd -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 <strong>未启动</strong>，启动并设置为开机启动：</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl enable --now systemd-networkd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后 <strong>重启 dnsmasq</strong>：</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl restart dnsmasq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你的 <code>hostapd</code> 失败的 <strong>核心错误</strong> 是：</p><pre class="line-numbers language-none"><code class="language-none">nl80211: Beacon set failed: -12 (Cannot allocate memory)Failed to set beacon parameterswlan0: Unable to setup interface.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这意味着 <strong>无线网卡驱动或内存分配问题</strong> 导致 <code>wlan0</code> 无法正常工作。我们可以尝试以下方法解决。</p><h2 id="🚀-在-Ubuntu-上配置-AP（WiFi-热点）"><a href="#🚀-在-Ubuntu-上配置-AP（WiFi-热点）" class="headerlink" title="🚀 在 Ubuntu 上配置 AP（WiFi 热点）"></a><strong>🚀 在 Ubuntu 上配置 AP（WiFi 热点）</strong></h2><p>你已经重装了 Ubuntu，现在我们 <strong>从零开始</strong> 配置 <strong>AP 热点</strong>（即 WiFi 共享）。</p><hr><p><strong>📌 1. 更新系统</strong></p><p>确保系统是最新的：</p><pre class="line-numbers language-none"><code class="language-none">sudo apt update &amp;&amp; sudo apt upgrade -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p> <strong>📌 2. 安装 AP 相关软件</strong></p><p>我们需要 <strong>hostapd（WiFi 热点管理）</strong> 和 <strong>dnsmasq（DHCP 服务器）</strong>：</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install -y hostapd dnsmasq iw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装后 <strong>先停止 hostapd 和 dnsmasq</strong>（稍后配置）：</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl stop hostapdsudo systemctl stop dnsmasq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><p><strong>📌 3. 关闭 wpa_supplicant（防止 WiFi 自动连接）</strong></p><p>如果 <code>wpa_supplicant</code> 在运行，它会干扰 AP 模式：</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl stop wpa_supplicantsudo systemctl disable wpa_supplicantsudo killall wpa_supplicant<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>检查是否仍在运行：</p><pre class="line-numbers language-none"><code class="language-none">ps aux | grep wpa_supplicant<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果仍然有输出，删除：</p><pre class="line-numbers language-none"><code class="language-none">sudo rm -rf &#x2F;var&#x2F;run&#x2F;wpa_supplicant<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p> <strong>📌 4. 配置 hostapd（WiFi 热点）</strong></p><p>编辑 <code>hostapd.conf</code>：</p><pre class="line-numbers language-none"><code class="language-none">sudo nano &#x2F;etc&#x2F;hostapd&#x2F;hostapd.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>粘贴以下内容：</p><pre class="line-numbers language-none"><code class="language-none">interface&#x3D;wlan0driver&#x3D;nl80211ssid&#x3D;OrangePi_APhw_mode&#x3D;gchannel&#x3D;6ieee80211n&#x3D;1wmm_enabled&#x3D;1ht_capab&#x3D;[HT40][SHORT-GI-20][DSSS_CCK-40]macaddr_acl&#x3D;0auth_algs&#x3D;1ignore_broadcast_ssid&#x3D;0wpa&#x3D;2wpa_passphrase&#x3D;12345678wpa_key_mgmt&#x3D;WPA-PSKrsn_pairwise&#x3D;CCMP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>保存退出</strong>（按 <code>CTRL + X</code> → <code>Y</code> → <code>Enter</code>）。</p><p>然后告诉 <code>hostapd</code> 读取配置：</p><pre class="line-numbers language-none"><code class="language-none">sudo nano &#x2F;etc&#x2F;default&#x2F;hostapd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到：</p><pre class="line-numbers language-none"><code class="language-none">#DAEMON_CONF&#x3D;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>改成：</p><pre class="line-numbers language-none"><code class="language-none">DAEMON_CONF&#x3D;&quot;&#x2F;etc&#x2F;hostapd&#x2F;hostapd.conf&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><strong>📌 5. 配置 dnsmasq（DHCP 服务器）</strong></p><p><strong>备份原 dnsmasq 配置</strong>（防止冲突）：</p><pre class="line-numbers language-none"><code class="language-none">sudo mv &#x2F;etc&#x2F;dnsmasq.conf &#x2F;etc&#x2F;dnsmasq.conf.bak<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>创建新的 dnsmasq.conf</strong>：</p><pre class="line-numbers language-none"><code class="language-none">sudo nano &#x2F;etc&#x2F;dnsmasq.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>粘贴：</p><pre class="line-numbers language-none"><code class="language-none">interface&#x3D;wlan0dhcp-range&#x3D;192.168.4.2,192.168.4.20,255.255.255.0,24h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>保存退出</strong>（<code>CTRL + X</code> → <code>Y</code> → <code>Enter</code>）。</p><hr><p><strong>📌 6. 配置 wlan0 静态 IP</strong></p><pre class="line-numbers language-none"><code class="language-none">sudo nano &#x2F;etc&#x2F;network&#x2F;interfaces<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加：</p><pre class="line-numbers language-none"><code class="language-none">auto wlan0iface wlan0 inet static    address 192.168.4.1    netmask 255.255.255.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>保存退出</strong>。</p><hr><p><strong>📌 7. 手动切换 wlan0 到 AP 模式</strong></p><pre class="line-numbers language-none"><code class="language-none">sudo ip link set wlan0 downsudo iw dev wlan0 set type __apsudo ip link set wlan0 up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>检查 <code>wlan0</code> 是否成功进入 AP 模式：</p><pre class="line-numbers language-none"><code class="language-none">iw dev wlan0 info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果输出：</p><pre class="line-numbers language-none"><code class="language-none">Interface wlan0        type AP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>说明 <strong>成功</strong>，可以继续下一步。</p><hr><p><strong>📌 8. 启动 hostapd 和 dnsmasq</strong></p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl restart hostapdsudo systemctl restart dnsmasq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>让它们开机自动启动</strong>：</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl enable hostapdsudo systemctl enable dnsmasq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>检查状态：</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl status hostapdsudo systemctl status dnsmasq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果 <strong>显示 active (running)</strong>，说明成功！</p><hr><p><strong>📌 9. 启用 NAT（让热点设备可以上网，可选）</strong></p><p>如果你的 <strong>Orange Pi 连接了以太网 eth0</strong>，可以启用 NAT：</p><pre class="line-numbers language-none"><code class="language-none">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADEsudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPTsudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>让规则 <strong>永久生效</strong>：</p><pre class="line-numbers language-none"><code class="language-none">sudo sh -c &quot;iptables-save &gt; &#x2F;etc&#x2F;iptables.ipv4.nat&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>开机自动应用</strong>：</p><pre class="line-numbers language-none"><code class="language-none">sudo nano &#x2F;etc&#x2F;rc.local<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>exit 0</code> 之前添加：</p><pre class="line-numbers language-none"><code class="language-none">iptables-restore &lt; &#x2F;etc&#x2F;iptables.ipv4.nat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>保存退出</strong>（<code>CTRL + X</code> → <code>Y</code> → <code>Enter</code>）。</p><hr><p><strong>📌 10. 重新启动系统</strong></p><pre class="line-numbers language-none"><code class="language-none">sudo reboot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><strong>📌 11. 测试 AP 热点</strong></p><ol><li><p><strong>用手机&#x2F;电脑搜索 WiFi</strong></p><ul><li>WiFi 名称：<code>OrangePi_AP</code></li><li>密码：<code>12345678</code></li></ul></li><li><p><strong>连接 WiFi，检查 IP</strong></p><ul><li>手机应该获取到 <code>192.168.4.x</code> 的 IP 地址</li></ul></li><li><p><strong>如果有 eth0 连接，测试能否访问互联网</strong></p><pre class="line-numbers language-none"><code class="language-none">ping -c 4 8.8.8.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果能 ping 通，说明热点设备可以上网。</p></li></ol><p>sudo create_ap –no-virt -m nat wlan0 end0 Orangepi 123456789</p>]]></content>
      
      
      
        <tags>
            
            <tag> Orange Pi </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fusion360</title>
      <link href="/2025/03/29/127-fusion360/"/>
      <url>/2025/03/29/127-fusion360/</url>
      
        <content type="html"><![CDATA[<h2 id="fusion360"><a href="#fusion360" class="headerlink" title="fusion360"></a>fusion360</h2><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="草图"><a href="#草图" class="headerlink" title="草图"></a>草图</h3><h3 id="推拉"><a href="#推拉" class="headerlink" title="推拉"></a>推拉</h3><h3 id="零部件"><a href="#零部件" class="headerlink" title="零部件"></a>零部件</h3><p>联动</p><h3 id="电池后盖"><a href="#电池后盖" class="headerlink" title="电池后盖"></a>电池后盖</h3><p><img src="C:\Users\VIBTEK\AppData\Roaming\Typora\typora-user-images\1741330770720.png" alt="1741330770720"></p><p><strong>如何做上窄下款的圆柱</strong></p><p><strong>使用“放样（Loft）”工具</strong></p><ol><li><strong>创建底部圆</strong>：</li><li><strong>创建顶部圆</strong>：<ul><li>选择 <strong>“构造（Construct）”→“偏移平面（Offset Plane）”</strong>。</li><li>选择第一个草图的平面，输入<strong>偏移值</strong>（即圆柱高度）。</li><li>在新的平面上<strong>创建一个较小的圆</strong>（作为顶部）。</li><li><strong>完成草图</strong>。</li></ul></li><li><strong>放样（Loft）成型</strong>：<ul><li>选择 <strong>“创建（Create）”→“放样（Loft）”</strong>。</li><li>选择底部圆和顶部圆作为<strong>截面</strong>。</li><li>确保两者平滑连接，点击 <strong>“确定”</strong> 生成圆台。</li></ul></li></ol><h3 id="导入草图"><a href="#导入草图" class="headerlink" title="导入草图"></a>导入草图</h3><h3 id="复制草图"><a href="#复制草图" class="headerlink" title="复制草图"></a>复制草图</h3><h3 id="复制实体"><a href="#复制实体" class="headerlink" title="复制实体"></a>复制实体</h3><h2 id="导入PCB"><a href="#导入PCB" class="headerlink" title="导入PCB"></a>导入PCB</h2><p>嘉立创专业版导出step格式的3d文件，删除不用的组件，节省资源，新建刚性组，全选后，新建零部件，将全部组件移入</p><h1 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h1><p>创建草图，按<code>p</code>选中实体,投影，一般做外壳时非常好用，可以投影type-c口什么的</p><h1 id="圆柱体上放草图"><a href="#圆柱体上放草图" class="headerlink" title="圆柱体上放草图"></a>圆柱体上放草图</h1><p>[<a href="https://www.reddit.com/r/Fusion360/comments/dj1seh/help_how_to_add_diagonal_support_to_a_plate_atop/?tl=zh-hans">求助] 如何给一个圆柱体上的板子添加斜向支撑？ : r&#x2F;Fusion360</a></p><p><a href="https://www.autodesk.com.cn/support/technical/article/caas/sfdcarticles/sfdcarticles/CHS/How-to-orient-a-plane-over-holes-on-a-cylinder-in-Fusion-360.html">如何在Fusion 360中将平面定向到圆柱体上的孔上</a></p><p><a href="https://www.bilibili.com/video/BV1NV2BYrEY7/?spm_id_from=333.337.search-card.all.click&vd_source=e33ad22b3d91cb180bef532ce5877b2e">Fusion360画PCB外壳分享_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32_MQTT_OTA</title>
      <link href="/2025/03/28/126-micradar/"/>
      <url>/2025/03/28/126-micradar/</url>
      
        <content type="html"><![CDATA[<h2 id="毫米波雷达数据帧解析"><a href="#毫米波雷达数据帧解析" class="headerlink" title="毫米波雷达数据帧解析"></a>毫米波雷达数据帧解析</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><img src="/2025/03/28/126-micradar/1743662058597.png" class="" width="1743662058597"><img src="/2025/03/28/126-micradar/1743661922308.png" class="" width="1743661922308"><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>关闭睡眠监测</p><blockquote><p>53 59 84 00 00 01 00 31 54 43</p></blockquote><h3 id="✅-求和："><a href="#✅-求和：" class="headerlink" title="✅ 求和："></a>✅ 求和：</h3><pre class="line-numbers language-none"><code class="language-none">0x53 + 0x59 + 0x84 + 0x00 + 0x00 + 0x01 + 0x00&#x3D; 83   + 89   + 132  + 0    + 0    + 1    + 0&#x3D; 305<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>→ 305 &#x3D; <strong>0x131</strong></p><p>我们只取 <strong>低8位</strong>（即 <code>0x31</code>）</p><blockquote><p>5359 84 00 0001 00 sum 5443</p></blockquote><h2 id="📋-所有功能关闭对应指令一览表（标准格式）"><a href="#📋-所有功能关闭对应指令一览表（标准格式）" class="headerlink" title="📋 所有功能关闭对应指令一览表（标准格式）"></a>📋 所有功能关闭对应指令一览表（标准格式）</h2><table><thead><tr><th>功能</th><th>控制字</th><th>完整关闭指令</th><th>校验和计算（十进制）</th></tr></thead><tbody><tr><td><strong>睡眠监测</strong></td><td><code>0x84</code></td><td><code>53 59 84 00 00 01 00 31 54 43</code> ✅</td><td>0x53+0x59+0x84+0x00+0x00+0x01+0x00 &#x3D; <strong>305 → 0x131 → 0x31</strong></td></tr><tr><td><strong>心率监测</strong></td><td><code>0x85</code></td><td><code>53 59 85 00 00 01 00 32 54 43</code> ✅</td><td>0x53+0x59+0x85+… &#x3D; <strong>306 → 0x132 → 0x32</strong></td></tr><tr><td><strong>呼吸检测</strong></td><td><code>0x81</code></td><td><code>53 59 81 00 00 01 00 2E 54 43</code> ✅</td><td>0x53+0x59+0x81+… &#x3D; <strong>302 → 0x12E → 0x2E</strong></td></tr><tr><td><strong>存在检测</strong></td><td><code>0x80</code></td><td><code>53 59 80 00 00 01 00 2D 54 43</code> ✅</td><td>0x</td></tr></tbody></table><h2 id="✅-功能关闭指令表"><a href="#✅-功能关闭指令表" class="headerlink" title="✅ 功能关闭指令表"></a>✅ 功能关闭指令表</h2><table><thead><tr><th>功能模块</th><th>控制字</th><th>命令字</th><th>数据</th><th>校验和计算（示例）</th><th>完整指令帧</th></tr></thead><tbody><tr><td>存在检测</td><td><code>0x80</code></td><td><code>0x00</code></td><td><code>0x00</code></td><td><code>0x2D</code></td><td><code>53 59 80 00 00 01 00 2D 54 43</code></td></tr><tr><td>睡眠监测</td><td><code>0x84</code></td><td><code>0x00</code></td><td><code>0x00</code></td><td><code>0x31</code></td><td><code>53 59 84 00 00 01 00 31 54 43</code></td></tr><tr><td>心率检测</td><td><code>0x85</code></td><td><code>0x00</code></td><td><code>0x00</code></td><td><code>0x32</code></td><td><code>53 59 85 00 00 01 00 32 54 43</code></td></tr><tr><td>呼吸检测</td><td><code>0x81</code></td><td><code>0x00</code></td><td><code>0x00</code></td><td><code>0x2E</code></td><td><code>53 59 81 00 00 01 00 2E 54 43</code></td></tr></tbody></table><hr><h2 id="✅-功能开启指令表"><a href="#✅-功能开启指令表" class="headerlink" title="✅ 功能开启指令表"></a>✅ 功能开启指令表</h2><table><thead><tr><th>功能模块</th><th>控制字</th><th>命令字</th><th>数据</th><th>校验和计算（示例）</th><th>完整指令帧</th></tr></thead><tbody><tr><td>存在检测</td><td><code>0x80</code></td><td><code>0x00</code></td><td><code>0x01</code></td><td><code>0x2E</code></td><td><code>53 59 80 00 00 01 01 2E 54 43</code></td></tr><tr><td>睡眠监测</td><td><code>0x84</code></td><td><code>0x00</code></td><td><code>0x01</code></td><td><code>0x32</code></td><td><code>53 59 84 00 00 01 01 32 54 43</code></td></tr><tr><td>心率检测</td><td><code>0x85</code></td><td><code>0x00</code></td><td><code>0x01</code></td><td><code>0x33</code></td><td><code>53 59 85 00 00 01 01 33 54 43</code></td></tr><tr><td>呼吸检测</td><td><code>0x81</code></td><td><code>0x00</code></td><td><code>0x01</code></td><td><code>0x2F</code></td><td><code>53 59 81 00 00 01 01 2F 54 43</code></td></tr></tbody></table><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 固定帧定义 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;const uint8_t disablePresence[] &#x3D; &#123;0x53, 0x59, 0x80, 0x00, 0x00, 0x01, 0x00, 0x2D, 0x54, 0x43&#125;;const uint8_t disableSleep[]    &#x3D; &#123;0x53, 0x59, 0x84, 0x00, 0x00, 0x01, 0x00, 0x31, 0x54, 0x43&#125;;const uint8_t disableHeart[]    &#x3D; &#123;0x53, 0x59, 0x85, 0x00, 0x00, 0x01, 0x00, 0x32, 0x54, 0x43&#125;;const uint8_t disableBreath[]   &#x3D; &#123;0x53, 0x59, 0x81, 0x00, 0x00, 0x01, 0x00, 0x2E, 0x54, 0x43&#125;;const uint8_t enablePresence[]  &#x3D; &#123;0x53, 0x59, 0x80, 0x00, 0x00, 0x01, 0x01, 0x2E, 0x54, 0x43&#125;;const uint8_t enableSleep[]     &#x3D; &#123;0x53, 0x59, 0x84, 0x00, 0x00, 0x01, 0x01, 0x32, 0x54, 0x43&#125;;const uint8_t enableHeart[]     &#x3D; &#123;0x53, 0x59, 0x85, 0x00, 0x00, 0x01, 0x01, 0x33, 0x54, 0x43&#125;;const uint8_t enableBreath[]    &#x3D; &#123;0x53, 0x59, 0x81, 0x00, 0x00, 0x01, 0x01, 0x2F, 0x54, 0x43&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出现的问题</p><p>vscode的串口监视器，需要<strong>重新开关</strong>才会刷新状态，其他串口监视器不用</p><p>重新上电也好用，我还以为刷新状态需要重新上电呢</p><h3 id="✅-控制功能的-MQTT-指令（JSON-格式）"><a href="#✅-控制功能的-MQTT-指令（JSON-格式）" class="headerlink" title="✅ 控制功能的 MQTT 指令（JSON 格式）"></a>✅ 控制功能的 MQTT 指令（JSON 格式）</h3><table><thead><tr><th>功能</th><th>开启指令</th><th>关闭指令</th></tr></thead><tbody><tr><td>睡眠监测</td><td><code>&#123; &quot;command&quot;: &quot;sleep&quot;, &quot;action&quot;: &quot;enable&quot; &#125;</code></td><td><code>&#123; &quot;command&quot;: &quot;sleep&quot;, &quot;action&quot;: &quot;disable&quot; &#125;</code></td></tr><tr><td>心率监测</td><td><code>&#123; &quot;command&quot;: &quot;heart&quot;, &quot;action&quot;: &quot;enable&quot; &#125;</code></td><td><code>&#123; &quot;command&quot;: &quot;heart&quot;, &quot;action&quot;: &quot;disable&quot; &#125;</code></td></tr><tr><td>呼吸监测</td><td><code>&#123; &quot;command&quot;: &quot;breath&quot;, &quot;action&quot;: &quot;enable&quot; &#125;</code></td><td><code>&#123; &quot;command&quot;: &quot;breath&quot;, &quot;action&quot;: &quot;disable&quot; &#125;</code></td></tr><tr><td>存在检测</td><td><code>&#123; &quot;command&quot;: &quot;presence&quot;, &quot;action&quot;: &quot;enable&quot; &#125;</code></td><td><code>&#123; &quot;command&quot;: &quot;presence&quot;, &quot;action&quot;: &quot;disable&quot; &#125;</code></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>{ “command”: “ota”, </p><p>“url”: “<a href="http://192.168.71.92:8080/firmware.bin">http://192.168.71.92:8080/firmware.bin</a>“</p><p>}</p><p><em>&#x2F;&#x2F; TSL2591光强传感器</em></p><p>{</p><p>​    “command”: “tsl2591”,</p><p>​    “action”: “enable”</p><p>}</p><p>{</p><p>​    “command”: “tsl2591”,</p><p>​    “action”: “disable”</p><p>}</p><p><em>&#x2F;&#x2F; MQ3酒精传感器</em></p><p>{</p><p>​    “command”: “mq3”,</p><p>​    “action”: “enable”</p><p>}</p><p>{</p><p>​    “command”: “mq3”,</p><p>​    “action”: “disable”</p><p>}</p><p><em>&#x2F;&#x2F; 睡眠模式</em></p><p>{</p><p>​    “command”: “sleep”,</p><p>​    “action”: “enable”</p><p>}</p><p>{</p><p>​    “command”: “sleep”,</p><p>​    “action”: “disable”</p><p>}</p><p><em>&#x2F;&#x2F; 心跳检测</em></p><p>{</p><p>​    “command”: “heart”,</p><p>​    “action”: “enable”</p><p>}</p><p>{</p><p>​    “command”: “heart”,</p><p>​    “action”: “disable”</p><p>}</p><p><em>&#x2F;&#x2F; 呼吸检测</em></p><p>{</p><p>​    “command”: “breath”,</p><p>​    “action”: “enable”</p><p>}</p><p>{</p><p>​    “command”: “breath”,</p><p>​    “action”: “disable”</p><p>}</p><p><em>&#x2F;&#x2F; 存在检测</em></p><p>{</p><p>​    “command”: “presence”,</p><p>​    “action”: “enable”</p><p>}</p><p>{</p><p>​    “command”: “presence”,</p><p>​    “action”: “disable”</p><p>}</p><p>{</p><p>​    “command”: “alarm”,</p><p>​    “action”: “enable”</p><p>}</p><p>{</p><p>​    “command”: “alarm”,</p><p>​    “action”: “disable”</p><p>}</p><p>{</p><p>​    “command”: “alarm”,</p><p>​    “action”: “stop”</p><p>}</p><p>{</p><p>​    “command”: “alarm”,</p><p>​    “action”: “clear”</p><p>}</p><p>{</p><p>​    “command”: “ota”,</p><p>​    “url”: “<a href="http://your-update-url/firmware.bin">http://your-update-url/firmware.bin</a>“</p><p>}</p><p><em>&#x2F;&#x2F; BLE配网控制</em></p><p>{</p><p>​    “command”: “ble”,</p><p>​    “action”: “enable”</p><p>}</p><p>{</p><p>​    “command”: “ble”,</p><p>​    “action”: “disable”</p><p>}</p>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32系统板</title>
      <link href="/2025/03/26/124-esp32-xi-tong-ban/"/>
      <url>/2025/03/26/124-esp32-xi-tong-ban/</url>
      
        <content type="html"><![CDATA[<h3 id="ESP32核心部分电路"><a href="#ESP32核心部分电路" class="headerlink" title="ESP32核心部分电路"></a>ESP32核心部分电路</h3><p>这个设计的核心作用是<strong>稳定电压、滤波高频噪声、提供瞬时电流补偿</strong>。（去耦）</p><img src="/2025/03/26/124-esp32-xi-tong-ban/1742883409569.png" class="" width="1742883409569"><table><thead><tr><th><strong>信号名称</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><strong>ESP_3V3</strong></td><td>3.3V 电源，通常来自 <strong>外部 LDO（低压差稳压器）</strong>，用于<strong>给整个 ESP32 供电</strong>。</td></tr><tr><td><strong>VDD3V3</strong></td><td>3.3V 电源，可能是 <strong>ESP32 内部 LDO 输出的 3.3V</strong>，供给内部电路。</td></tr></tbody></table><p> <strong>⚡ 关键对比</strong></p><table><thead><tr><th><strong>功能</strong></th><th><strong>ESP32-S3 模块（WROOM&#x2F;WROVER）</strong></th><th><strong>Arduino Nano ESP32</strong></th></tr></thead><tbody><tr><td><strong>USB 直连功能</strong></td><td>❌ <strong>不支持（部分版本）</strong>，需要外部 UART 转 USB 芯片</td><td>✅ <strong>支持原生 USB</strong>，无需额外芯片</td></tr><tr><td><strong>串口调试</strong></td><td>需要 <strong>CH340&#x2F;CP2102</strong> 连接 TX&#x2F;RX</td><td>USB 直接作为 <strong>CDC 虚拟串口</strong></td></tr><tr><td><strong>烧录方式</strong></td><td>通过 UART（需要 USB 转串口）</td><td>直接通过 USB-C 端口烧录</td></tr><tr><td><strong>USB-OTG</strong></td><td>仅部分支持</td><td><strong>完全支持（GPIO19, GPIO20）</strong></td></tr></tbody></table><h3 id="TYPE-C电路"><a href="#TYPE-C电路" class="headerlink" title="TYPE-C电路"></a>TYPE-C电路</h3><h3 id="USB-to-UART电路"><a href="#USB-to-UART电路" class="headerlink" title="USB to UART电路"></a>USB to UART电路</h3><p> ✅ 为了扩展更多 USB 功能，实际使用的两颗芯片是：</p><ol><li><strong>CH343P</strong>：典型的 <strong>USB 转串口（USB to UART）芯片</strong></li><li><strong>CH334F</strong>：一颗 <strong>多口 USB HUB 控制芯片</strong></li></ol><h3 id="1-CH343P-USB-转-UART"><a href="#1-CH343P-USB-转-UART" class="headerlink" title="1. CH343P - USB 转 UART"></a>1. <strong>CH343P - USB 转 UART</strong></h3><ul><li>接在 <strong>ESP32-S3 的 UART0（TXD0 &#x2F; RXD0）</strong> 上</li><li>作用：<ul><li>提供 <strong>固件烧录</strong></li><li>提供 <strong>串口日志输出（serial log）</strong></li><li>配合 DTR&#x2F;RTS 控制 IO0&#x2F;EN，实现 <strong>自动下载（Auto Download）</strong></li></ul></li><li>属于开发板中最基础的调试功能。</li></ul><hr><h3 id="2-CH334F-USB-HUB-芯片"><a href="#2-CH334F-USB-HUB-芯片" class="headerlink" title="2. CH334F - USB HUB 芯片"></a>2. <strong>CH334F - USB HUB 芯片</strong></h3><ul><li>是一颗 <strong>4口 USB Hub 控制器</strong>。</li><li>作用是：<ul><li>将主控 USB 总线 <strong>一分多</strong>，扩展出多个 USB 接口</li><li>其中一个端口连接 <strong>CH343P（USB转串口）</strong></li><li>其余端口可供：<ul><li>其他外设（比如 USB HID、U盘、摄像头）</li><li>甚至接入 ESP32-S3 自身的 <strong>USB OTG接口</strong></li></ul></li></ul></li></ul><h3 id="FDC6333C"><a href="#FDC6333C" class="headerlink" title="FDC6333C"></a>FDC6333C</h3><p> 🔸 Q1：P沟MOSFET，主控3.3V输出通断</p><ul><li><strong>输入：3.3V</strong></li><li><strong>输出：3V3_OP</strong></li><li><strong>控制端 G1（通过 R3 下拉）</strong><ul><li>控制条件是：<ul><li>若 G1 &#x3D; 0V → MOSFET 导通 → 输出 3.3V</li><li>若 G1 ≈ 3.3V → MOSFET 关断 → 输出断开</li></ul></li></ul></li><li><strong>用途</strong>：当你想控制是否把板上的 3.3V 电压输出到其他模块（比如外设），可以控制这个开关。</li></ul><p>🔸 Q2：PMOS，用于 VBUS 控制</p><ul><li>VBUS 来自 USB</li><li>G2 通过 R5 拉高（100k）</li><li>R4 是限流电阻（100R）</li><li>G2 控制 Q2 的导通<ul><li>如果 G2 拉低（比如被芯片拉低），则 VBUS 可以导通</li><li>如果保持拉高，则 MOSFET 关断，VBUS 不会输出</li></ul></li><li><strong>用途猜测</strong>：<ul><li>起到 <strong>VBUS 电源隔离 &#x2F; 控制作用</strong></li><li>或者保护电路，在 USB 插入时由 MCU 控制是否导通 VBUS，防止反插损坏</li></ul></li></ul><h3 id="复位电路"><a href="#复位电路" class="headerlink" title="复位电路"></a>复位电路</h3><h3 id="自动下载电路"><a href="#自动下载电路" class="headerlink" title="自动下载电路"></a>自动下载电路</h3><h3 id="USB-TO-UART"><a href="#USB-TO-UART" class="headerlink" title="USB TO UART"></a>USB TO UART</h3><p>✅ 常见的 USB 转 UART 芯片对比</p><table><thead><tr><th>芯片型号</th><th>厂商</th><th>最大波特率</th><th>驱动支持</th><th>供电电压</th><th>说明</th></tr></thead><tbody><tr><td><strong>CP2102N</strong></td><td>Silicon Labs</td><td>3 Mbps</td><td>Windows &#x2F; macOS &#x2F; Linux</td><td>3.3V &#x2F; 5V</td><td>稳定、广泛使用，体积小，功耗低</td></tr><tr><td><strong>CH340G</strong></td><td>WCH（南京沁恒）</td><td>2 Mbps</td><td>Windows &#x2F; macOS &#x2F; Linux</td><td>5V（默认），支持3.3V</td><td>便宜，兼容性还行</td></tr><tr><td><strong>FT232RL</strong></td><td>FTDI</td><td>3 Mbps</td><td>非常强（驱动成熟）</td><td>3.3V &#x2F; 5V 可选</td><td>稳定、高品质，但贵</td></tr><tr><td><strong>PL2303</strong></td><td>Prolific</td><td>1 Mbps</td><td>Windows &#x2F; Linux（部分新版驱动不稳定）</td><td>3.3V &#x2F; 5V</td><td>较老，驱动有兼容问题</td></tr><tr><td><strong>CP2104</strong></td><td>Silicon Labs</td><td>1 Mbps</td><td>多平台支持</td><td>3.3V &#x2F; 5V</td><td>CP2102系列的变种，低功耗小封装</td></tr></tbody></table><hr><p>✅ 简单说说为什么不能直接用 USB 的 <strong>D+ &#x2F; D-</strong> 连到 UART 的 <strong>TX &#x2F; RX</strong></p><p>这问题非常关键，很多人初学时会误以为 USB 是“串口”，就直接连了——其实这样会烧芯片，原因如下：</p><hr><p>❌ <strong>USB 和 UART 是完全不同的通信协议和电气标准</strong></p><table><thead><tr><th>特性</th><th>USB（D+ &#x2F; D-）</th><th>UART（TX &#x2F; RX）</th></tr></thead><tbody><tr><td>物理信号</td><td>差分信号（一对线）</td><td>单端信号（各一根）</td></tr><tr><td>协议复杂度</td><td>高（有握手、地址、包头、CRC等）</td><td>低（起始位+数据+校验位）</td></tr><tr><td>驱动需求</td><td>需要USB主机控制器</td><td>可直接点对点通信</td></tr><tr><td>电平标准</td><td>USB 2.0 是 3.3V 差分信号</td><td>通常为TTL电平（3.3V 或 5V）</td></tr></tbody></table><hr><p>🎯 简单比喻理解：</p><ul><li><strong>USB</strong> 像是高速公路，有专门的“收费站”（协议控制器），车辆（数据包）必须按规矩走，还得有“入口”设备（主机）。</li><li><strong>UART</strong> 像是村里的小路，你说一句我回一句，简单直接，谁都能上。</li></ul><p>你拿 <strong>USB D+&#x2F;D- 去接 UART TX&#x2F;RX</strong>，就像拿两个插头对着接，<strong>信号根本不一样，不但通信不了，还可能烧掉IO口或者芯片内部ESD电路</strong>。✅ 总结一句话</p><blockquote><p><strong>不能直接连 D+&#x2F;D- 到 TX&#x2F;RX，是因为它们用的不是一种“语言”和“电平方式”，而且 USB 需要专用控制器，UART 不行。</strong></p></blockquote><h3 id="C3与S3对比"><a href="#C3与S3对比" class="headerlink" title="C3与S3对比"></a>C3与S3对比</h3><p>🔧 一、芯片对比：ESP32-C3 vs ESP32-S3</p><table><thead><tr><th>项目</th><th><strong>ESP32-C3</strong></th><th><strong>ESP32-S3</strong></th></tr></thead><tbody><tr><td>CPU 架构</td><td>单核 RISC-V @160MHz</td><td>双核 Xtensa LX7 @240MHz</td></tr><tr><td>RAM</td><td>~400KB SRAM</td><td>~512KB SRAM</td></tr><tr><td>PSRAM 支持</td><td>❌ 无原生支持</td><td>✅ 支持外挂 PSRAM</td></tr><tr><td>Wi-Fi</td><td>✅ 2.4GHz b&#x2F;g&#x2F;n</td><td>✅ 2.4GHz b&#x2F;g&#x2F;n</td></tr><tr><td>BLE</td><td>✅ BLE 5.0, Long Range</td><td>✅ BLE 5.0, LE Audio</td></tr><tr><td>GPIO 数量</td><td>22</td><td>44</td></tr><tr><td>USB 接口</td><td>✅ USB Device</td><td>✅ USB OTG（Host + Device）</td></tr><tr><td>LCD &#x2F; 摄像头支持</td><td>❌ 无</td><td>✅ 支持 LCD、CAM 接口</td></tr><tr><td>安全特性</td><td>AES, RNG, Secure Boot, Flash加密</td><td>更多安全特性 + AI加速器</td></tr><tr><td>封装尺寸</td><td>QFN 5x5 mm</td><td>QFN 7x7 mm</td></tr></tbody></table><hr><p>📦 二、模组对比：ESP32-C3-WROOM-02 vs ESP32-S3-WROOM-1</p><table><thead><tr><th>项目</th><th><strong>ESP32-C3-WROOM-02</strong></th><th><strong>ESP32-S3-WROOM-1&#x2F;1U</strong></th></tr></thead><tbody><tr><td>核心芯片</td><td>ESP32-C3</td><td>ESP32-S3</td></tr><tr><td>Flash</td><td>4MB &#x2F; 8MB</td><td>4MB &#x2F; 8MB &#x2F; 16MB</td></tr><tr><td>PSRAM</td><td>❌ 无</td><td>✅ 可选 2MB &#x2F; 8MB</td></tr><tr><td>GPIO 暴露数量</td><td>15–22 个视封装而定</td><td>高达 42 个视封装而定</td></tr><tr><td>模组尺寸</td><td>18 × 20 mm</td><td>18 × 20.5 mm</td></tr><tr><td>天线类型</td><td>PCB 天线 &#x2F; 外接 IPEX</td><td>PCB 天线 &#x2F; 外接 IPEX</td></tr><tr><td>工作温度范围</td><td>-40°C ~ +85°C</td><td>-40°C ~ +105°C</td></tr><tr><td>认证</td><td>CE, FCC, SRRC 等</td><td>CE, FCC, SRRC 等</td></tr></tbody></table><h3 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h3><ol><li><strong>LC 滤波器</strong></li></ol><ul><li><p>因为它的核心是一个 <strong>电感（L）+ 一堆电容（C）</strong></p></li><li><p>是最常用的电源滤波结构之一</p></li><li><p>简单说就是：</p><blockquote><p>“LC Power Filter” 或 “LC 滤波网络”</p></blockquote></li></ul><hr><ol start="2"><li><strong>π（π型）滤波器 &#x2F; Pi Filter</strong></li></ol><ul><li><p>因为它长得像希腊字母 π（Pi）：</p><pre class="line-numbers language-none"><code class="language-none">lua复制编辑  C ---|      |+V ---L---+----&gt; 输出      |   |     ---  C      GND<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>就是 “<strong>电容 - 电感 - 电容</strong>” 的组合结构</p></li><li><p>特点是滤波带宽广、高低频都能压得住</p></li></ul><hr><ol start="3"><li><strong>电源去耦滤波器 &#x2F; Power Decoupling Filter</strong></li></ol><ul><li>强调它用于给电源去耦、稳压的作用</li><li>常见于 MCU、Wi-Fi、射频类芯片前级电源净化</li></ul><p> 📐 二、电容封装区别（0805 vs 1206）</p><table><thead><tr><th>项目</th><th><strong>0805</strong></th><th><strong>1206</strong></th></tr></thead><tbody><tr><td>可承受电压</td><td>一般 ≤ 25V</td><td>可达 50V（看具体型号）</td></tr><tr><td>最大容量（X7R）</td><td>常用值 ≤ 22μF</td><td>可支持更大（如 47μF）</td></tr><tr><td>纹波电流能力</td><td>中等</td><td>更好，更稳定</td></tr><tr><td>PCB 占空间</td><td>小，适合紧凑</td><td>略大，适合主供电路径滤波</td></tr></tbody></table><p>✅ <strong>总结：</strong></p><blockquote><p>如果你需要更大电容值、更稳定的供电，<strong>选 1206 更稳；</strong><br> 如果你空间小、滤波不是很关键，<strong>选 0805 更省面积。</strong></p></blockquote><hr><p>🌀 三、电感封装区别（0805 vs 1206）</p><table><thead><tr><th>项目</th><th><strong>0805</strong></th><th><strong>1206</strong></th></tr></thead><tbody><tr><td>电感量可选范围</td><td>多，但电流低（<del>0.3</del>0.6A）</td><td>电流承载更高（<del>1</del>2A）</td></tr><tr><td>DCR 阻抗</td><td>较高，压降大</td><td>较低，更适合电源主路径使用</td></tr><tr><td>EMI 抗性</td><td>较弱（多数非屏蔽）</td><td>可选屏蔽型，抗干扰更强</td></tr><tr><td>易焊性</td><td>更小，手焊困难</td><td>更好焊，适合手工和贴片机兼容</td></tr></tbody></table><h2 id="ESP32-C3"><a href="#ESP32-C3" class="headerlink" title="ESP32_C3"></a>ESP32_C3</h2><p>不加</p><h3 id="B5819W-肖特基二极管"><a href="#B5819W-肖特基二极管" class="headerlink" title="B5819W 肖特基二极管"></a><strong>B5819W 肖特基二极管</strong></h3><p>实现防反灌电压</p><h2 id="测试点"><a href="#测试点" class="headerlink" title="测试点"></a>测试点</h2><p>电流测试点</p>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32驱动多传感器</title>
      <link href="/2025/03/21/122-esp32-s3-chuan-gan-qi/"/>
      <url>/2025/03/21/122-esp32-s3-chuan-gan-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="TEMT6000"><a href="#TEMT6000" class="headerlink" title="TEMT6000"></a>TEMT6000</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>1.ADC读数从0增加到3400然后又递减到0<code>GPIO4</code></p><blockquote></blockquote><ol start="2"><li></li></ol><h3 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h3><p>ESP32-S3 <strong>所有可用的 ADC 引脚</strong>（模拟输入引脚）：</p><p><strong>📌 ADC1 (12-bit, 0-3.3V)</strong></p><table><thead><tr><th>通道编号</th><th>GPIO</th></tr></thead><tbody><tr><td>ADC1_CH0</td><td>GPIO1</td></tr><tr><td>ADC1_CH1</td><td>GPIO2</td></tr><tr><td>ADC1_CH2</td><td>GPIO3</td></tr><tr><td>ADC1_CH3</td><td>GPIO4</td></tr><tr><td>ADC1_CH4</td><td>GPIO5</td></tr><tr><td>ADC1_CH5</td><td>GPIO6</td></tr><tr><td>ADC1_CH6</td><td>GPIO7</td></tr><tr><td>ADC1_CH7</td><td>GPIO8</td></tr><tr><td>ADC1_CH8</td><td>GPIO9</td></tr><tr><td>ADC1_CH9</td><td>GPIO10</td></tr></tbody></table><hr><p> <strong>📌 ADC2 (12-bit, 0-3.3V, 受 WiFi 影响)</strong></p><table><thead><tr><th>通道编号</th><th>GPIO</th></tr></thead><tbody><tr><td>ADC2_CH0</td><td>GPIO11</td></tr><tr><td>ADC2_CH1</td><td>GPIO12</td></tr><tr><td>ADC2_CH2</td><td>GPIO13</td></tr><tr><td>ADC2_CH3</td><td>GPIO14</td></tr><tr><td>ADC2_CH4</td><td>GPIO15</td></tr><tr><td>ADC2_CH5</td><td>GPIO16</td></tr><tr><td>ADC2_CH6</td><td>GPIO17</td></tr><tr><td>ADC2_CH7</td><td>GPIO18</td></tr><tr><td>ADC2_CH8</td><td>GPIO19</td></tr><tr><td>ADC2_CH9</td><td>GPIO20</td></tr></tbody></table><hr><p> <strong>⚠️ 注意事项</strong></p><ol><li><strong>ADC1 可正常使用</strong>，适用于大部分情况。</li><li><strong>ADC2 受 WiFi 影响</strong>，如果 WiFi 使能，ADC2 可能无法正常工作。</li><li><strong>ESP32-S3 没有 DAC</strong>（无法作为模拟输出）。</li><li><strong>ESP32-S3 ADC 默认 12-bit（0-4095）</strong>，但可以配置 9-bit, 10-bit, 11-bit。</li><li><strong>analogReadResolution(bits)</strong> 设置分辨率，<strong>analogSetAttenuation(ADC_11db)</strong> 设置输入范围（最大 3.3V）。</li></ol><p>💡 <strong>推荐使用 ADC1（GPIO1-GPIO10），避免 ADC2 受 WiFi 干扰！</strong> 🚀</p><h3 id="RGB灯"><a href="#RGB灯" class="headerlink" title="RGB灯"></a>RGB灯</h3><p>不知道为啥pwm驱动才有用，普通驱动没反应，要不<del>设置个pwm值吧，可能亮度太低没看到</del>，无效，只有渐变可行</p><p><strong>肯定是哪里出了问题，因为arduino nano esp32出场自带的程序可以正常闪灯啊</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define RED_PIN 45#define GREEN_PIN 0#define BLUE_PIN 46&#x2F;&#x2F; 定义 LEDC PWM 频道#define LEDC_CHANNEL_RED   0#define LEDC_CHANNEL_GREEN 1#define LEDC_CHANNEL_BLUE  2#define PWM_FREQ 5000  &#x2F;&#x2F; PWM 频率#define PWM_RESOLUTION 8  &#x2F;&#x2F; 8位分辨率（0-255）void setup() &#123;  &#x2F;&#x2F; 配置 PWM 频道  ledcSetup(LEDC_CHANNEL_RED, PWM_FREQ, PWM_RESOLUTION);  ledcSetup(LEDC_CHANNEL_GREEN, PWM_FREQ, PWM_RESOLUTION);  ledcSetup(LEDC_CHANNEL_BLUE, PWM_FREQ, PWM_RESOLUTION);  &#x2F;&#x2F; 绑定通道到 GPIO 引脚  ledcAttachPin(RED_PIN, LEDC_CHANNEL_RED);  ledcAttachPin(GREEN_PIN, LEDC_CHANNEL_GREEN);  ledcAttachPin(BLUE_PIN, LEDC_CHANNEL_BLUE);&#125;void loop() &#123;  int val;  &#x2F;&#x2F; 颜色渐变 - 先递减  for (val &#x3D; 255; val &gt; 0; val--) &#123;    ledcWrite(LEDC_CHANNEL_RED, val);    ledcWrite(LEDC_CHANNEL_GREEN, 255 - val);    ledcWrite(LEDC_CHANNEL_BLUE, 128 - val);    delay(1);  &#125;  &#x2F;&#x2F; 颜色渐变 - 再递增  for (val &#x3D; 0; val &lt; 255; val++) &#123;    ledcWrite(LEDC_CHANNEL_RED, val);    ledcWrite(LEDC_CHANNEL_GREEN, 255 - val);    ledcWrite(LEDC_CHANNEL_BLUE, 128 - val);    delay(1);  &#125;  Serial.println(val, DEC);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>烧录完后会出现usb串口失效，可能是影响到的GPIO0</p><p>SCK灯也不亮不到为啥</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define YELLOW_PIN 48void setup() &#123;  pinMode(YELLOW_PIN, OUTPUT);  digitalWrite(YELLOW_PIN, HIGH);  &#x2F;&#x2F; 初始状态：LED 熄灭&#125;void loop() &#123;  digitalWrite(YELLOW_PIN, HIGH);   &#x2F;&#x2F; 蓝色灭  delay(1000);  digitalWrite(YELLOW_PIN, LOW);  &#x2F;&#x2F; 绿色亮  delay(1000);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="红外传感器"><a href="#红外传感器" class="headerlink" title="红外传感器"></a>红外传感器</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>红外对管一个发送红外光一个接收反射的光（红外LED+光敏二极管接收器）</p><p>可用于避障，循迹，颜色识别</p><p><strong>光学原理</strong></p><ul><li><p>颜色是物体对可见光中不同波长的反射或吸收结果。</p></li><li><p>白光 &#x3D; 所有可见光的混合（红橙黄绿蓝靛紫）。</p></li></ul><table><thead><tr><th>物体颜色</th><th>反射光波长</th><th>吸收光波长</th></tr></thead><tbody><tr><td>红色物体</td><td>红光</td><td>其他光</td></tr><tr><td>黑色物体</td><td>吸收全部</td><td>无反射</td></tr><tr><td>白色物体</td><td>反射全部</td><td>几乎无吸收</td></tr><tr><td>绿色物体</td><td>反射绿光</td><td>吸收其他</td></tr></tbody></table><h3 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h3><p>不知道为啥，低电平检测不到</p>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32串口通信</title>
      <link href="/2025/03/16/123-esp32-uart/"/>
      <url>/2025/03/16/123-esp32-uart/</url>
      
        <content type="html"><![CDATA[<h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><ul><li><p>USB OTG</p><blockquote><p>就是除电脑外的设备可以直接通过usb进行数据传输</p><p><a href="https://baike.baidu.com/item/OTG/2649844?fromModule=lemma_inlink">OTG</a>设备就是使我们的“EX(扩展设备)”既能充当HOST，亦能充当SLAVE。</p></blockquote></li></ul><h2 id="ESP32-Nano串口通信"><a href="#ESP32-Nano串口通信" class="headerlink" title="ESP32 Nano串口通信"></a>ESP32 Nano串口通信</h2><p><strong>环境</strong></p><ul><li>Arduino IDE</li><li>Arduino nano esp32</li></ul><h3 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h3><img src="/2025/03/16/123-esp32-uart/1743651190192.png" class="" width="1743651190192"><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>1.复位后乱码，只是复位之后发送的数据乱码,esp32开发板都有</p><p>2.USB串口失效</p><p>原因：</p><blockquote><p>IDE选错开发板型号导致开发板固件坏掉</p></blockquote><p>解决方案：</p><blockquote><p>使用刷机软件，重刷固件</p><img src="/2025/03/16/123-esp32-uart/1741758528187.png" class="" width="1741758528187"><img src="/2025/03/16/123-esp32-uart/f63410f72e82647dd2f27496dc898bb.png" class="" title="f63410f72e82647dd2f27496dc898bb"></blockquote><p>注意：</p><ol><li>固件地址</li><li>短接Boot1与GND(RGB为绿色)</li><li>如果设备管理器出现Arduino DFU的问题就是没有驱动，需要重装</li><li><img src="/2025/03/16/123-esp32-uart/1741758751899.png" class="" width="1741758751899"></li></ol><p>5.uart1串口透传失效</p><p>  uart0可以，原因未知</p><p>6.如果烧录时出现nodfu，可重新烧录固件，然后重新上电扫描串口</p><h3 id="串口占用"><a href="#串口占用" class="headerlink" title="串口占用"></a>串口占用</h3><ul><li><p>正常情况usb串口是否占用uart0(ESP32-S3)?</p><blockquote><p>不占用</p></blockquote></li><li></li></ul><h3 id="串口透传"><a href="#串口透传" class="headerlink" title="串口透传"></a>串口透传</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;Arduino.h&gt;void setup() &#123;  &#x2F;&#x2F; 初始化 UART0，波特率为 115200（注意这里是和目标模块一致的波特率）  Serial0.begin(115200);   Serial.begin(115200); &#x2F;&#x2F; 主串口，用于打印输出到串口监视器  Serial0.println(&quot;UART0 Loopback Test Started&quot;);  delay(1000);&#125;void loop() &#123;  &#x2F;&#x2F; 向模块发送数据  Serial0.print(&quot;111&quot;);  &#x2F;&#x2F; 接收 Serial0 的数据，并打印到主串口  while (Serial0.available()) &#123;    uint8_t receivedByte &#x3D; Serial0.read();  &#x2F;&#x2F; 读取收到的字节    Serial.print(&quot;Received: 0x&quot;);    if (receivedByte &lt; 0x10) Serial.print(&quot;0&quot;); &#x2F;&#x2F; 补零对齐    Serial.println(receivedByte, HEX);         &#x2F;&#x2F; 十六进制输出  &#125;  delay(1000);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，我总是容易失败，就是使用其他串口的时候，需要研究一下esp32的串口到底是怎么配置的</p><h2 id="ESP32-C3"><a href="#ESP32-C3" class="headerlink" title="ESP32 C3"></a>ESP32 C3</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>1.没有usb to uart芯片的情况下，usb串口可以下载但是不可以打印</p><blockquote><p>因为usb-cdc（Communication Device Class），一种通讯协议类，模拟串口</p></blockquote><p>platformio.ini中添加</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">build_flags &#x3D;   -DARDUINO_USB_MODE&#x3D;1  -DARDUINO_USB_CDC_ON_BOOT&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Arduino ide开启usb cdc on boot</p><h2 id="ESP32-S3"><a href="#ESP32-S3" class="headerlink" title="ESP32 S3"></a>ESP32 S3</h2><p>1.串口打印需要更改串口号</p>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32_S3_WIFI</title>
      <link href="/2025/03/12/121-esp32-s3-wifi/"/>
      <url>/2025/03/12/121-esp32-s3-wifi/</url>
      
        <content type="html"><![CDATA[<h2 id="📌-核心函数一览"><a href="#📌-核心函数一览" class="headerlink" title="📌 核心函数一览"></a>📌 核心函数一览</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>WiFi.begin(ssid, password)</code></td><td>连接到指定 WiFi 热点</td></tr><tr><td><code>WiFi.status()</code></td><td>返回当前 WiFi 状态（如已连接、失败等）</td></tr><tr><td><code>WiFi.localIP()</code></td><td>获取当前连接 WiFi 后分配的 IP 地址</td></tr><tr><td><code>WiFi.disconnect()</code></td><td>断开当前 WiFi</td></tr><tr><td><code>WiFi.SSID()</code></td><td>获取当前连接的 WiFi 名称</td></tr><tr><td><code>WiFi.RSSI()</code></td><td>获取当前 WiFi 信号强度</td></tr><tr><td><code>WiFi.macAddress()</code></td><td>获取 MAC 地址</td></tr><tr><td><code>WiFi.scanNetworks()</code></td><td>扫描周围 WiFi 热点</td></tr><tr><td><code>WiFi.mode(WIFI_STA)</code></td><td>设置为“客户端模式”</td></tr><tr><td><code>WiFi.mode(WIFI_AP)</code></td><td>设置为“热点模式”</td></tr><tr><td><code>WiFi.mode(WIFI_AP_STA)</code></td><td>同时作为热点和客户端（混合）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32_S3_BLE学习记录</title>
      <link href="/2025/03/10/119-esp32-ble/"/>
      <url>/2025/03/10/119-esp32-ble/</url>
      
        <content type="html"><![CDATA[<h3 id="BLE-是什么？"><a href="#BLE-是什么？" class="headerlink" title="BLE 是什么？"></a>BLE 是什么？</h3><p>BLE（Bluetooth Low Energy）是一种低功耗、短距离的通信协议，用于设备间小数据传输，非常适合传感器、穿戴设备、手机通信等场景。</p><h3 id="BLE-基础架构"><a href="#BLE-基础架构" class="headerlink" title="BLE 基础架构"></a>BLE 基础架构</h3><p>ESP32 做 BLE Server（外设）时，通常有以下几个重要概念：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>Server（服务端）</strong></td><td>ESP32 作为 BLE 外设</td></tr><tr><td><strong>Service（服务）</strong></td><td>类似一个功能模块（例如心率服务）</td></tr><tr><td><strong>Characteristic（特征值）</strong></td><td>一个数据单元，支持读&#x2F;写&#x2F;通知</td></tr><tr><td><strong>UUID</strong></td><td>用于标识 Service 和 Characteristic</td></tr></tbody></table><h3 id="环境安装配置"><a href="#环境安装配置" class="headerlink" title="环境安装配置"></a>环境安装配置</h3><ul><li>VScode+Platform</li></ul><p> ✅ 1. <code>BLEServer *pServer = BLEDevice::createServer();</code></p><ul><li><code>BLEServer *</code>：意思是 <code>pServer</code> 是一个 <strong>指针</strong>，它指向一个 BLE 服务器对象。</li><li><code>BLEDevice::createServer()</code>：这是 <strong>类 BLEDevice</strong> 中的一个 <strong>静态函数</strong>，它会新建一个服务器并返回。</li></ul><blockquote><p>📦 类似于：你打电话叫了个外卖服务员回来，给他起了个名字 <code>pServer</code>。</p></blockquote><hr><p> ✅ 2. <code>pService-&gt;start();</code></p><ul><li><code>pService</code> 是之前你通过 <code>pServer-&gt;createService(...)</code> 得到的服务对象。</li><li><code>.start()</code> 就是告诉这个服务：<strong>开始广播、准备接收连接！</strong></li></ul><blockquote><p>📦 类似于：你已经设置好了服务员该做什么，现在告诉他 “开始工作”。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">BLEServer* pServer &#x3D; BLEDevice::createServer();     &#x2F;&#x2F; 创建 BLE 服务器BLEService* pService &#x3D; pServer-&gt;createService(&quot;xxxx&quot;); &#x2F;&#x2F; 创建一个服务pService-&gt;start();                                  &#x2F;&#x2F; 启动这个服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>C++ 符号</th><th>含义</th></tr></thead><tbody><tr><td><code>*</code></td><td>指针（代表一个对象地址）</td></tr><tr><td><code>-&gt;</code></td><td>通过指针访问对象的成员</td></tr><tr><td><code>.</code></td><td>普通对象访问成员</td></tr></tbody></table><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>1.好的，不支持nano，<code>nano</code>只有<code>arduino ide</code>和<code>micropython</code>支持哦，喜提重刷固件</p><blockquote><p>支持，搜索nano esp32</p></blockquote><ol start="2"><li></li></ol><p>第一个可以连接<code>serial bluetooth</code>，第二个不可以</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">BLEDevice::init(&quot;ESP32-S3-BLE&quot;);pServer &#x3D; BLEDevice::createServer();BLEService* pService &#x3D; pServer-&gt;createService(BLEUUID((uint16_t)0xFFE0));pCharacteristic &#x3D; pService-&gt;createCharacteristic(                    BLEUUID((uint16_t)0xFFE1),                    BLECharacteristic::PROPERTY_READ |                     BLECharacteristic::PROPERTY_WRITE |                     BLECharacteristic::PROPERTY_NOTIFY);pCharacteristic-&gt;addDescriptor(new BLE2902());pService-&gt;start();BLEAdvertising* pAdvertising &#x3D; BLEDevice::getAdvertising();pAdvertising-&gt;addServiceUUID(BLEUUID((uint16_t)0xFFE0));pAdvertising-&gt;start();Serial.println(&quot;✅ BLE 初始化完成，等待连接...&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">BLEDevice::init(&quot;ESP32-BLE-Demo&quot;);BLEServer *pServer &#x3D; BLEDevice::createServer();BLEService *pService &#x3D; pServer-&gt;createService(&quot;12345678-1234-5678-1234-56789abcdef0&quot;);pCharacteristic &#x3D; pService-&gt;createCharacteristic(  &quot;abcdefab-1234-5678-1234-56789abcdef0&quot;,  BLECharacteristic::PROPERTY_READ |  BLECharacteristic::PROPERTY_WRITE |  BLECharacteristic::PROPERTY_NOTIFY);pCharacteristic-&gt;setValue(&quot;Hello BLE!&quot;);pCharacteristic-&gt;addDescriptor(new BLE2902());  &#x2F;&#x2F; 启用 notifypService-&gt;start();BLEAdvertising *pAdvertising &#x3D; BLEDevice::getAdvertising();pAdvertising-&gt;addServiceUUID(&quot;12345678-1234-5678-1234-56789abcdef0&quot;);pAdvertising-&gt;start();Serial.println(&quot;📡 等待 BLE 连接...&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原因：</strong></p><p>很多手机 App 默认只扫描常见 BLE 串口服务 UUID（如 0xFFE0）</p><p> 🔍 小结对比</p><table><thead><tr><th>比较项</th><th>第一段（能连）</th><th>第二段（不能连）</th></tr></thead><tbody><tr><td>UUID 类型</td><td>16位（标准串口服务）</td><td>128位（自定义）</td></tr><tr><td>兼容性</td><td>高</td><td>低</td></tr><tr><td>App 支持</td><td>nRF &#x2F; Serial Terminal 可用</td><td>nRF 支持，自定义 App 才能用</td></tr><tr><td>推荐用法</td><td>开发阶段串口调试</td><td>特定项目中自定义服务</td></tr></tbody></table><p>🔷 <code>BLEUUID</code> 是什么？</p><p><code>BLEUUID</code> 是 <strong>一个类</strong>，用来表示 <strong>UUID（通用唯一识别码）</strong>，用于标识 BLE 的：</p><ul><li>服务（Service）</li><li>特征值（Characteristic）</li><li>描述符（Descriptor）</li></ul><p>BLE 中一切都是基于 UUID 来识别的。S</p><hr><p>🔶 <code>0xFFE0</code> 是什么？</p><ul><li><code>0xFFE0</code> 是一个 <strong>16 位的 UUID</strong></li><li>它常被用于类似串口服务（BLE UART）的自定义协议（如 Nordic 的 UART 或 HM-10 模块）</li></ul><p>例如：</p><ul><li><code>FFE0</code>：服务 UUID（Service UUID）</li><li><code>FFE1</code>：特征值 UUID（Characteristic UUID）</li></ul><p>这是一种 <strong>简化写法</strong>，完整 UUID 是 128 位，系统内部会自动扩展它：</p><pre class="line-numbers language-none"><code class="language-none">复制编辑0x0000FFE0-0000-1000-8000-00805F9B34FB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>⚠️注意</p><p>轻易不要东GPIO0，另外出现ESP32频繁自启的情况，可以使用固件烧录工具擦除后重新烧录固件</p><h2 id="ESP32-BLE广播收发-advertise"><a href="#ESP32-BLE广播收发-advertise" class="headerlink" title="ESP32_BLE广播收发(advertise)"></a>ESP32_BLE广播收发(advertise)</h2><p><strong>✅ 常见的 BLE 广播 Type 类型</strong></p><table><thead><tr><th><strong>Type (Hex)</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th><th><strong>解析</strong></th></tr></thead><tbody><tr><td><code>0x01</code></td><td>设备 Flags（标志位）</td><td><code>0x06</code></td><td><strong>BLE 设备类型</strong></td></tr><tr><td><code>0x02</code></td><td>16-bit Service UUID（部分）</td><td><code>0x0A 18</code></td><td><strong>GATT 服务 UUID</strong></td></tr><tr><td><code>0x03</code></td><td>16-bit Service UUID（完整）</td><td><code>0x0A 18</code></td><td><strong>完整 UUID</strong></td></tr><tr><td><code>0x07</code></td><td>128-bit Service UUID</td><td><code>0xFB 34 9B 5F 80 00 00 80 00 10 00 00 00 00 00 00 00</code></td><td><strong>自定义服务 UUID</strong></td></tr><tr><td><code>0x08</code></td><td>短设备名称（Short Local Name）</td><td><code>0x45 53 50 33</code></td><td><strong>“ESP3”</strong></td></tr><tr><td><code>0x09</code></td><td>完整设备名称（Complete Local Name）</td><td><code>0x45 53 50 33 32 5F 57 49 46 49</code></td><td><strong>“ESP32_WIFI”</strong></td></tr><tr><td><code>0x0A</code></td><td>发射功率（Tx Power Level）</td><td><code>0x09</code></td><td><strong>+9 dBm</strong></td></tr><tr><td><code>0x12</code></td><td>设备厂商数据（Manufacturer Data）</td><td><code>0xDE AD BE EF 12 34 56 78</code></td><td><strong>HEX 数据</strong></td></tr><tr><td><code>0xFF</code></td><td>厂商数据（Manufacturer Data）</td><td>✅ <strong>可自定义</strong></td><td>设备私有数据</td></tr></tbody></table><h3 id="nRF广播"><a href="#nRF广播" class="headerlink" title="nRF广播"></a>nRF广播</h3><p> <strong>📌 BLEAdvertising（广播） vs. GATT（连接）</strong></p><p><strong>BLE（蓝牙低功耗）有两种主要通信方式：</strong></p><ol><li><strong>BLEAdvertising（广播）</strong> → <strong>ESP32 发送广播数据，无需连接</strong></li><li><strong>GATT（通用属性协议）</strong> → <strong>ESP32 作为服务器，支持客户端连接并交互数据</strong></li><li>BLEAdvertising（广播）**</li></ol><p>🔹 <strong>示例代码</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">BLEDevice::init(&quot;ESP32_Broadcaster&quot;);BLEAdvertising *pAdvertising &#x3D; BLEDevice::getAdvertising();pAdvertising-&gt;setAdvertisementData(advertisementData);pAdvertising-&gt;start();**<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>🔹超长数据的广播</p><p>** 方案 1：使用 Scan Response 发送额外数据**</p><p><strong>原理</strong>：</p><ul><li><strong>广播包（Advertising Data）</strong> 发送前 <strong>部分数据（如 SSID）</strong></li><li><strong>扫描响应包（Scan Response）</strong> 发送 <strong>剩余数据（如密码）</strong></li><li><strong>nRF Connect 或 ESP32 扫描端可同时获取这两个数据包</strong></li></ul><p> <strong>📌 Scannable 模式（可扫描模式）</strong></p><p>**Scannable（可扫描）**模式是一种 <strong>BLE 广播模式</strong>，允许接收端设备请求额外的信息。通常用于 <strong>发送超出广播包长度的数据</strong>。</p><p><strong>NRF配置</strong></p><p>✅scannable</p><ol start="2"><li>GATT（连接模式)**</li></ol><p>🔹 <strong>示例代码</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">BLEServer *pServer &#x3D; BLEDevice::createServer();BLEService *pService &#x3D; pServer-&gt;createService(SERVICE_UUID);BLECharacteristic *pCharacteristic &#x3D; pService-&gt;createCharacteristic(    CHARACTERISTIC_UUID,    BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE);pService-&gt;start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>🔹 <strong>📲 手机用 nRF Connect 连接 ESP32 并读写数据</strong></p><hr><p> 🚀 3. 主要区别</p><table><thead><tr><th><strong>对比项</strong></th><th><strong>BLEAdvertising（广播）</strong></th><th><strong>GATT（连接模式）</strong></th></tr></thead><tbody><tr><td><strong>连接需求</strong></td><td>❌ 无需连接（所有设备可接收）</td><td>✅ 需要设备连接</td></tr><tr><td><strong>数据大小</strong></td><td>⚠️ 限制 31 字节（BLE 4.2）<mark>超过会不广播</mark>，255 字节（BLE 5.0）</td><td>✅ 可发送大数据（分包方式）</td></tr><tr><td><strong>数据传输</strong></td><td>📡 只能发送，不能接收</td><td>🔄 双向通信（读&#x2F;写&#x2F;通知）</td></tr><tr><td><strong>私密性</strong></td><td>❌ 公开广播，所有设备都能接收</td><td>✅ 仅连接设备可读写</td></tr><tr><td><strong>使用场景</strong></td><td>广告、iBeacon、简单数据广播</td><td>设备控制、传感器数据、BLE 串口</td></tr></tbody></table><h3 id="ESP32轮流广播"><a href="#ESP32轮流广播" class="headerlink" title="ESP32轮流广播"></a>ESP32轮流广播</h3><p><strong>Demo</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;BLEDevice.h&gt;#include &lt;BLEUtils.h&gt;#include &lt;BLEAdvertising.h&gt;BLEAdvertising* pAdvertising;int toggle &#x3D; 0;const char* ssid &#x3D; &quot;VIBTEK-2.4G&quot;;const char* password &#x3D; &quot;vibrantech@1305-1&quot;;void broadcastData(uint16_t companyID, const char* payload) &#123;    std::string mData;    mData +&#x3D; (char)(companyID &amp; 0xFF);         &#x2F;&#x2F; 低位    mData +&#x3D; (char)((companyID &gt;&gt; 8) &amp; 0xFF);  &#x2F;&#x2F; 高位    mData +&#x3D; payload;    BLEAdvertisementData adData;    adData.setManufacturerData(mData);    pAdvertising-&gt;setAdvertisementData(adData);    pAdvertising-&gt;start();&#125;void setup() &#123;    Serial.begin(115200);    BLEDevice::init(&quot;ESP32_BLE_Sender&quot;);    pAdvertising &#x3D; BLEDevice::getAdvertising();&#125;void loop() &#123;    if (toggle &#x3D;&#x3D; 0) &#123;        Serial.println(&quot;📡 广播 SSID&quot;);        broadcastData(0x1234, ssid);    &#125; else &#123;        Serial.println(&quot;📡 广播密码&quot;);        broadcastData(0x2345, password);    &#125;    toggle &#x3D; 1 - toggle;  &#x2F;&#x2F; 切换    delay(2000);          &#x2F;&#x2F; 每 2 秒轮流广播一次&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;BLEDevice.h&gt;#include &lt;BLEScan.h&gt;#include &lt;WiFi.h&gt;#include &lt;Preferences.h&gt;#define BUTTON_PIN 6  &#x2F;&#x2F; 连接按键的 GPIO 引脚#define SCAN_TIME 5  #define SSID_COMPANY_ID 0x1234  #define PASS_COMPANY_ID 0x2345  const int ledPin &#x3D; 13;    &#x2F;&#x2F; the number of the LED pinBLEScan *pBLEScan;Preferences preferences;String receivedSSID &#x3D; &quot;&quot;;String receivedPassword &#x3D; &quot;&quot;;bool wifiConnected &#x3D; false; &#x2F;&#x2F; 记录 WiFi 连接状态&#x2F;&#x2F; 清除 WiFi 配置void clearWiFiConfig() &#123;    Serial.println(&quot;❌ 按键触发！正在删除 WiFi 配置信息...&quot;);    preferences.begin(&quot;wifi-config&quot;, false);    preferences.clear(); &#x2F;&#x2F; **删除整个 WiFi 存储**    preferences.putString(&quot;ssid&quot;, &quot;&quot;); &#x2F;&#x2F; 确保 WiFi 信息被覆盖    preferences.putString(&quot;password&quot;, &quot;&quot;);    preferences.end();    WiFi.disconnect(true, true); &#x2F;&#x2F; **彻底断开 WiFi 并清除缓存**    Serial.println(&quot;✅ WiFi 配置已删除，ESP32 将重新启动！&quot;);    delay(2000);    ESP.restart();  &#x2F;&#x2F; **重启 ESP32**&#125;void connectToWiFi(String ssid, String password) &#123;    Serial.printf(&quot;\n📡 连接 WiFi...\n🔹 SSID: %s\n🔹 密码: %s\n&quot;, ssid.c_str(), password.c_str());    WiFi.begin(ssid.c_str(), password.c_str());    int timeout &#x3D; 10;    while (WiFi.status() !&#x3D; WL_CONNECTED &amp;&amp; timeout-- &gt; 0) &#123;        delay(1000);        Serial.print(&quot;.&quot;);    &#125;    if (WiFi.status() &#x3D;&#x3D; WL_CONNECTED) &#123;        Serial.println(&quot;\n✅ WiFi 连接成功！&quot;);        Serial.print(&quot;🔹 IP 地址: &quot;);        Serial.println(WiFi.localIP());                preferences.begin(&quot;wifi-config&quot;, false);        preferences.putString(&quot;ssid&quot;, ssid);        preferences.putString(&quot;password&quot;, password);        preferences.end();        Serial.println(&quot;✅ WiFi 信息已存储！&quot;);        wifiConnected &#x3D; true; &#x2F;&#x2F; 标记 WiFi 连接成功    &#125; else &#123;        Serial.println(&quot;\n❌ WiFi 连接失败！&quot;);    &#125;&#125;class MyAdvertisedDeviceCallbacks : public BLEAdvertisedDeviceCallbacks &#123;    void onResult(BLEAdvertisedDevice advertisedDevice) &#123;        if (wifiConnected) return; &#x2F;&#x2F; WiFi 连接成功后，停止解析 BLE 数据        if (advertisedDevice.haveManufacturerData()) &#123;            String manufacturerData &#x3D; advertisedDevice.getManufacturerData();            if (manufacturerData.length() &lt; 2) return;            uint16_t companyID &#x3D; (manufacturerData[1] &lt;&lt; 8) | manufacturerData[0]; &#x2F;&#x2F;合成16位            String receivedData &#x3D; manufacturerData.substring(2);&#x2F;&#x2F;从索引2开始            if (companyID &#x3D;&#x3D; SSID_COMPANY_ID) &#123;                receivedSSID &#x3D; receivedData;                Serial.printf(&quot;\n 发现 SSID 广播: %s\n&quot;, receivedSSID.c_str());            &#125;             else if (companyID &#x3D;&#x3D; PASS_COMPANY_ID) &#123;                receivedPassword &#x3D; receivedData;                Serial.printf(&quot;\n 发现密码广播: %s\n&quot;, receivedPassword.c_str());            &#125;            if (receivedSSID.length() &gt; 0 &amp;&amp; receivedPassword.length() &gt; 0) &#123;                connectToWiFi(receivedSSID, receivedPassword);                receivedSSID &#x3D; &quot;&quot;;                receivedPassword &#x3D; &quot;&quot;;            &#125;        &#125;    &#125;&#125;;void setup() &#123;    Serial.begin(115200);    Serial.println(&quot; 开始扫描 BLE 广播数据...&quot;);    &#x2F;&#x2F; pinMode(BUTTON_PIN, INPUT_PULLUP); &#x2F;&#x2F; 设置按键为上拉模式    pinMode(ledPin, OUTPUT);    preferences.begin(&quot;wifi-config&quot;, true);    String storedSSID &#x3D; preferences.getString(&quot;ssid&quot;, &quot;&quot;);    String storedPassword &#x3D; preferences.getString(&quot;password&quot;, &quot;&quot;);    preferences.end();    if (storedSSID.length() &gt; 0 &amp;&amp; storedPassword.length() &gt; 0) &#123;        Serial.println(&quot; 发现存储的 WiFi 配置，尝试连接...&quot;);        connectToWiFi(storedSSID, storedPassword);    &#125; else &#123;        Serial.println(&quot; 未找到 WiFi 配置，等待 BLE 配置...&quot;);    &#125;    if (!wifiConnected) &#123;        BLEDevice::init(&quot;ESP32_BLE_Receiver&quot;);        pBLEScan &#x3D; BLEDevice::getScan();        pBLEScan-&gt;setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks());        pBLEScan-&gt;setActiveScan(true);    &#125;&#125;void loop() &#123;    if (!wifiConnected) &#123;        Serial.println(&quot;\n 重新扫描 BLE 广播数据...&quot;);        pBLEScan-&gt;start(SCAN_TIME, false);        digitalWrite(ledPin, HIGH);        delay(2000);        digitalWrite(ledPin, LOW);        delay(1000);        digitalWrite(ledPin, HIGH);        delay(2000);    &#125; else &#123;        Serial.println(&quot;\n WiFi 已连接，停止 BLE 扫描&quot;);        digitalWrite(ledPin, HIGH);        delay(10000); &#x2F;&#x2F; 避免过快打印    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32 IIC开发</title>
      <link href="/2025/03/10/120-esp32-iic/"/>
      <url>/2025/03/10/120-esp32-iic/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>1.多个iic地址，只有第一个初始化会起作用</p><h4 id="1️⃣-I2C-地址冲突或线路不通"><a href="#1️⃣-I2C-地址冲突或线路不通" class="headerlink" title="1️⃣ I2C 地址冲突或线路不通"></a>1️⃣ <strong>I2C 地址冲突或线路不通</strong></h4><ul><li>APDS-9930 默认 I2C 地址是 <code>0x39</code>。</li><li>如果多个 I2C 设备（如 TSL2591）使用不同的 I2C 引脚（你现在是分别 <code>Wire.begin(8, 9)</code> 和 <code>Wire.begin(10, 11)</code>），那么 <strong>只有一个 Wire 对象在起作用</strong>，后初始化的会覆盖前面的。</li></ul><p>✅ <strong>解决方法：</strong> 使用多个 I2C 设备时，应创建多个 <code>TwoWire</code> 对象（即多个 I2C 总线）：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">TwoWire Wire_TSL &#x3D; TwoWire(0);TwoWire Wire_APDS &#x3D; TwoWire(1);Wire_TSL.begin(TSL2591_SDA, TSL2591_SCL);Wire_APDS.begin(APDS9930_SDA, APDS9930_SCL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>并告诉 apds.begin() 用哪个 I2C 对象（如果库支持），否则你只能用一个总线！<br>然后这个库需要手动配置传感器的iic库，获取地址，读取数据什么的</p><h2 id="🧩-常见格式符号说明"><a href="#🧩-常见格式符号说明" class="headerlink" title="🧩 常见格式符号说明"></a>🧩 常见格式符号说明</h2><table><thead><tr><th>格式符</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>%d</code></td><td>int</td><td><strong>有符号十进制整数</strong>（e.g., <code>123</code>，<code>-42</code>）</td></tr><tr><td><code>%u</code></td><td>unsigned int</td><td><strong>无符号十进制整数</strong>（不能是负数）</td></tr><tr><td><code>%x</code> &#x2F; <code>%X</code></td><td>unsigned int</td><td><strong>无符号十六进制</strong>（小写 &#x2F; 大写字母）</td></tr><tr><td><code>%f</code></td><td>float &#x2F; double</td><td><strong>浮点数</strong>，默认保留 6 位小数</td></tr><tr><td><code>%0.2f</code></td><td>float &#x2F; double</td><td><strong>浮点数，保留两位小数</strong></td></tr><tr><td><code>%c</code></td><td>char</td><td>单个字符</td></tr><tr><td><code>%s</code></td><td>char*</td><td>字符串（C 风格字符串）</td></tr><tr><td><code>%%</code></td><td>—</td><td>输出 <code>%</code> 字符本身</td></tr></tbody></table><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ol><li></li></ol><pre class="line-numbers language-none"><code class="language-none">💡 TSL2591: ���?O lux📟 APDS9930: 20💡 TSL2591: ���?O lux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>🛑 <strong>问题点：</strong><br>你传入的是 <code>String</code> 类型（<code>tsl_lux</code>），但 <code>printf()</code> 只接受 <em><em>C 风格字符串（char</em>）</em>*，不能直接接受 Arduino 的 <code>String</code> 类型，会导致输出乱码（例如 <code>���?O</code>）。</p><h3 id="✅-正确写法-1（用-Serial-print）："><a href="#✅-正确写法-1（用-Serial-print）：" class="headerlink" title="✅ 正确写法 1（用 Serial.print）："></a>✅ 正确写法 1（用 <code>Serial.print</code>）：</h3><pre class="line-numbers language-none"><code class="language-none">cpp复制编辑Serial.print(&quot;💡 &quot;);Serial.print(tsl_lux);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="✅-正确写法-2（转换为-c-str-）："><a href="#✅-正确写法-2（转换为-c-str-）：" class="headerlink" title="✅ 正确写法 2（转换为 c_str()）："></a>✅ 正确写法 2（转换为 c_str()）：</h3><pre class="line-numbers language-none"><code class="language-none">cpp复制编辑Serial.printf(&quot;💡 TSL2591:\n%s&quot;, tsl_lux.c_str());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 <code>String.c_str()</code> 返回的是底层的 <code>const char*</code>，这样才能被 <code>printf()</code> 正确识别。</p><p>2.<strong>android 蓝牙ble 133,Android 关于蓝牙BLE引发Gatt133的问题</strong></p><p><a href="https://huaweicloud.csdn.net/64e5c64c4165333c3076a8b0.html">android 蓝牙ble 133</a></p><p>3.<strong>传感器初始化失败</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">if (!tsl.begin()) &#123;  Serial.println(&quot;❌ 初始化失败&quot;);  while (1);  &#x2F;&#x2F; 👉 死循环：程序卡死，永远不再往下执行&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>while(1)</code>会导致两个问题</p><ul><li>当该传感器未连接时，程序卡死，蓝牙无法连接</li></ul>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LoRa</title>
      <link href="/2025/03/10/131-lora/"/>
      <url>/2025/03/10/131-lora/</url>
      
        <content type="html"><![CDATA[<h2 id="LoRa"><a href="#LoRa" class="headerlink" title="LoRa"></a>LoRa</h2><p>什么是LoRa？</p><p>LoRa是创建<strong>长距离通信连接的物理层无线调制技术</strong>，属于<strong>线性调制扩频技术</strong>(Chirp Spread Spectrum，CSS)的一种，也叫<strong>宽带线性调频技术</strong>(Chirp Modulation)。这种调制技术可以实现在不同频率上发送<strong>长距离和低功耗</strong>的信号。通过调整发送功率和传输速率，使LoRa设备可以适应不同的应用场景和需求。</p><p>LoRa属于低功耗广域物联网LPWAN，LPWAN是英文Low Power Wide Area Network 的缩写，即低功耗广域物联网的意思。<strong>专为远距离、超带宽、低功耗、大量连接、组网灵活</strong>的物联网应用而设计，因此被广泛部署在智慧安防、智能家居和楼宇、智能抄表、智慧农业、工业控制、新能源等多个垂直行业。</p><p>常见的LoRa应用中使用的网络架构包括 <strong>私有协议网络</strong> 和 <strong>LoRaWAN网络</strong>。</p><h3 id="Lora配置"><a href="#Lora配置" class="headerlink" title="Lora配置"></a>Lora配置</h3><p>类似于串口配置</p><p>AT指令配置，指令结尾要加\r\n</p><h3 id="Lora网关配置"><a href="#Lora网关配置" class="headerlink" title="Lora网关配置"></a>Lora网关配置</h3><ol><li>AP配置&#x2F;串口配置&#x2F;ssh配置</li><li>配置mqtt服务器的IP、端口、用户名、密码、主体qos</li><li>配置lora设备数据上报周期</li><li>网关的频率、信道与 LoRa 模块一致。</li></ol><h3 id="SN"><a href="#SN" class="headerlink" title="SN"></a>SN</h3><p>1.网关后台查看</p><p>2.设备白名单，手动添加</p><p>3.通过mqtt订阅查看</p><p>4.将采集到的 传感器数据和 SN 一并打包，通过 LoRa 发送</p><h2 id="🏷️-2-SN-归属谁？"><a href="#🏷️-2-SN-归属谁？" class="headerlink" title="🏷️ 2. SN 归属谁？"></a>🏷️ <strong>2. SN 归属谁？</strong></h2><ul><li><strong>SN 是 LoRa 终端设备的标识</strong>，而不是传感器的 SN。</li><li>终端设备 &#x3D; <strong>MCU + LoRa 模块 + 传感器</strong></li></ul><h3 id="✅-数据发送流程"><a href="#✅-数据发送流程" class="headerlink" title="✅ 数据发送流程"></a>✅ <strong>数据发送流程</strong></h3><ol><li><p><strong>毫米波雷达</strong> 采集到人体感应、距离、速度等数据。</p></li><li><p><strong>MCU</strong> 读取雷达数据，并读取 <strong>LoRa 设备的 SN</strong>。</p></li><li><p>MCU 将数据和 SN 一起打包，构造成 JSON 格式。</p></li><li><p>通过 <strong>LoRa 模块</strong>发送数据到网关。</p></li><li><p><strong>网关</strong> 将数据透传到 MQTT 服务器或云平台。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;sn&quot;: &quot;SN1234567890&quot;,        &#x2F;&#x2F; LoRa 设备的唯一标识  &quot;sensor&quot;: &quot;mmWave&quot;,  &quot;distance&quot;: 1.5,             &#x2F;&#x2F; 测量到的距离（单位：米）  &quot;speed&quot;: 0.3,                &#x2F;&#x2F; 速度（单位：m&#x2F;s）  &quot;timestamp&quot;: &quot;2025-03-17T12:00:00Z&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><strong>SN（序列号）是由</strong> <strong>ESP32</strong> <strong>或终端设备（lora）主动发送的</strong>，而不是 LoRa 网关自动识别的。</p><p>1.网关不对数据进行处理，识别和处理服务器干，存储到数据库</p><p>2.网关白名单配置，可添加设备的sn（不是所有的网关都支持这个功能）</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://mp.weixin.qq.com/s/Un5qMhjMacTH78gWEX3G7Q">https://mp.weixin.qq.com/s/Un5qMhjMacTH78gWEX3G7Q</a></p>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32的AP模式</title>
      <link href="/2025/03/01/118-esp32-ap-mo-shi/"/>
      <url>/2025/03/01/118-esp32-ap-mo-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>配置界面汉字乱码</p><blockquote><p>charset&#x3D;utf-8</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">const char* html_page &#x3D; R&quot;rawliteral(  &lt;!DOCTYPE HTML&gt;&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;  &lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;ESP32 配网&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;    &lt;h2&gt;ESP32 WiFi 配置&lt;&#x2F;h2&gt;    &lt;form action&#x3D;&quot;&#x2F;save&quot; method&#x3D;&quot;POST&quot;&gt;      WiFi 名称: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;ssid&quot;&gt;&lt;br&gt;      WiFi 密码: &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&gt;&lt;br&gt;&lt;br&gt;      &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;    &lt;&#x2F;form&gt;  &lt;&#x2F;body&gt;  &lt;&#x2F;html&gt;)rawliteral&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lvgl开发</title>
      <link href="/2025/03/01/129-lvgl-kai-fa/"/>
      <url>/2025/03/01/129-lvgl-kai-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>微雪ESP32-S3-Touch-LCD-2.8</li><li>Arduino IDE</li><li>ESP32开发板包</li></ul><h2 id="Lvgl开发"><a href="#Lvgl开发" class="headerlink" title="Lvgl开发"></a>Lvgl开发</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;  创建Beep开关lv_obj_t  * beep_label&#x3D; lv_label_create(panel1);  &#x2F;&#x2F; 创建标签“蜂鸣音”lv_label_set_text(beep_label, &quot;蜂鸣音(Beep)&quot;);  &#x2F;&#x2F; 设置标签文本lv_obj_add_style(beep_label, &amp;style_text_muted, 0);  &#x2F;&#x2F; 为标签应用样式lv_obj_t * Beep &#x3D; lv_switch_create(panel1);  &#x2F;&#x2F; 创建蜂鸣器开关lv_obj_align(Beep, LV_ALIGN_RIGHT_MID, -10, 0);&#x2F;&#x2F; 给开关控件添加事件回调，监听开关状态的变化lv_obj_add_event_cb(Beep, beep_switch_event_cb, LV_EVENT_VALUE_CHANGED, NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取开关状态</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">lv_obj_has_state(switch_obj, LV_STATE_CHECKED);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a><a href="https://lvgl.100ask.net/8.1/layouts/grid.html#overview">Grid布局</a></h3><p>大项目（<code>LV_GRID_CONTENT</code>）或“空闲单元”（FR）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void lv_obj_set_grid_cell(lv_obj_t * obj, lv_grid_align_t h_align, uint16_t col, uint16_t col_span, lv_grid_align_t v_align, uint16_t row, uint16_t row_span);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th align="left">———</th><th>——–</th></tr></thead><tbody><tr><td align="left"><code>LV_GRID_ALIGN_START</code>：对齐到网格单元的开始（左对齐）。</td><td></td></tr><tr><td align="left"><code>LV_GRID_ALIGN_CENTER</code>：居中对齐。</td><td></td></tr><tr><td align="left"><code>LV_GRID_ALIGN_END</code>：对齐到网格单元的结束（右对齐）。</td><td></td></tr><tr><td align="left"><code>LV_GRID_ALIGN_STRETCH</code>：拉伸对象以填充整个网格单元的宽度。</td><td></td></tr><tr><td align="left">col（列位置）(0开始计数)</td><td></td></tr><tr><td align="left">col_span（列跨越）</td><td></td></tr></tbody></table><h3 id="中文字库"><a href="#中文字库" class="headerlink" title="中文字库"></a>中文字库</h3><p><a href="https://lvgl.100ask.net/8.1/tools/fonts-zh-source.html">下载字体</a></p><p>记住名字，输入要转换的汉字</p><p><a href="https://lvgl.io/tools/fontconverter">字体转换器 — LVGL</a></p><p>字体文件配置</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#ifdef LV_LVGL_H_INCLUDE_SIMPLE#include &quot;lvgl.h&quot;#else#include &quot;..&#x2F;..&#x2F;lvgl.h&quot;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加到程序中，并加入</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;中文字体声明LV_FONT_DECLARE(NotoSansCJK-Medium-5);lv_label_set_text(Beep_label, &quot;蜂鸣音&quot;);  &#x2F;&#x2F; 设置标签文本lv_obj_add_style_text_font(Beep_label, &amp;NotoSansCJK-Medium-5, 0);  &#x2F;&#x2F;后加的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;LV_FONT_DECLARE(字体名);LV_FONT_DECLARE(lv_font_gb2312_regular_script_14); &#x2F;&#x2F;样式中设置字体API接口：lv_obj_set_style_text_font();    &#x2F;&#x2F;私有（本地）样式lv_style_set_text_font();        &#x2F;&#x2F;普通（共享）样式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/weixin_49337111/article/details/139175997">教程</a></p><p><strong>字库</strong></p><blockquote><p>设置电量蜂鸣音告警示灯语音播报屏幕亮信号强度检测无人机探器频率图传品牌型号反制建议类型图传震动 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.+-*&#x2F;</p></blockquote><h1 id="Bugs"><a href="#Bugs" class="headerlink" title="Bugs"></a>Bugs</h1><p>三个框不能勾选，否则会导致字符消失</p><img src="/2025/03/01/129-lvgl-kai-fa/1745740295371.png" class="" width="1745740295371"><p> 1.<strong>信号频率有时会显示一个方框</strong></p><ul><li>解析&#x2F;指针的问题</li><li>还是 LVGL 字体&#x2F;渲染</li></ul><p>排查</p><blockquote><p>写死检测界面，固定数值检查是否正常-√，字体问题排除</p></blockquote><p>原因：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 假设 data 里 “F…R” 之间是 &quot;5212&quot;，那么 end_v1 - start_v1 &#x3D;&#x3D; 4char v1[end_v1 - start_v1 + 1]; &#x2F;&#x2F; 这里分配了 5 字节的空间：&#39;5&#39;,&#39;2&#39;,&#39;1&#39;,&#39;2&#39;,&#39;\0&#39;strncpy(v1, start_v1, 4);v1[4] &#x3D; &#39;\0&#39;;&#x2F;&#x2F; 下面这行要把 &quot; MHz&quot;（5 个字节，含终止符 &#39;\0&#39;）全写进去strcat(v1, &quot; MHz&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>越界写入</strong>：<code>v1</code> 长度只有 <code>len(v1)+1</code>，但 <code>&quot; MHz&quot;</code> 还要再写 4 个字节，立刻把栈上的邻近数据打乱，导致后续你给 LVGL 的字符串有时是乱码、方框。</p><p><strong>悬空指针</strong>：<code>v1</code> 是局部数组，<code>DroneDetect()</code> 返回后就被释放，<code>droneSignalFrequency</code> 再去访问，会读到随机内存，也就会出现怪字符</p><p>2.<strong>无法获取按钮状态并更新</strong></p><p>现象是卡死并自动重启</p><blockquote><p>思路是发送AT指令获取状态后更新</p><p>经过注释烧录烧录注释后判定为当调用蓝牙发送at+motor这个指令时，就会自启</p><p>我没想明白，GPT老师指出</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;char* start_v1 &#x3D; strchr(data, &#39;F&#39;) + 1;  if (start_v1 &#x3D;&#x3D; nullptr) return;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 这个return永远无效，因为<code>+1</code></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">void DroneDetect(char* data) &#123;     &#x2F;&#x2F; char* start_v1 &#x3D; strchr(data, &#39;F&#39;) + 1;  &#x2F;&#x2F; if (start_v1 &#x3D;&#x3D; nullptr) return;    char* pF &#x3D; strchr(data, &#39;F&#39;);  if (!pF) return;          &#x2F;&#x2F; 没找到 F，就退出  char* start_v1 &#x3D; pF + 1;  &#x2F;&#x2F; 跳过 &#39;F&#39; 本身，指向数字起始  char* end_v1 &#x3D; strchr(data, &#39;R&#39;);  if (end_v1 &#x3D;&#x3D; nullptr) return;  char v1[end_v1 - start_v1 + 1];  strncpy(v1, start_v1, end_v1 - start_v1);  v1[end_v1 - start_v1] &#x3D; &#39;\0&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.<strong>提取不到数据</strong></p><ol><li><p><strong>使用 strncpy() 确保 pData 是一个 ‘\0’ 结尾的字符串</strong></p><pre class="line-numbers language-none"><code class="language-none">strncpy(buffer, (char*)pData, length);buffer[length] &#x3D; &#39;\0&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>修正 strstr() 搜索的字符串</strong></p><ul><li><p>你的数据是：</p><pre class="line-numbers language-none"><code class="language-none">+PN &#x3D; A1-20-00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>但 <code>strstr(buffer, &quot;+PN=&quot;)</code> <strong>不会匹配</strong>，因为数据中有空格 <code>&quot; &quot;</code>。</p></li><li><p>改成 <code>strstr(buffer, &quot;+PN =&quot;)</code> <strong>确保正确匹配</strong>。</p></li></ul></li><li><p><strong>修正 sscanf() 解析字符串</strong></p><pre class="line-numbers language-none"><code class="language-none">sscanf(pnPtr, &quot;+PN &#x3D; %s&quot;, pnValue);sscanf(snPtr, &quot;+SN &#x3D; %s&quot;, snValue);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>这样 <code>pnValue</code> 和 <code>snValue</code> <strong>只提取实际数据</strong>，不会包含 <code>&quot;+PN =&quot;</code> <strong>这部分字符串</strong>。</li></ul></li><li></li></ol><blockquote><p>Note: This error originates from pySerial. It is likely not a problem with esptool, but with the hardware connection or drivers.</p></blockquote><p>上传速度调慢了，不知道是不是这个原因，也可能是卡死了，需要重烧固件</p><p>5.注释掉背光，程序卡住，进度条为0，屏幕闪烁</p><ul><li><p>第二列老师超出范围</p><blockquote><p>一行一列是00，二列是1不是2</p></blockquote></li><li><p>led按钮宽度不对，原因未知</p><blockquote><p>没有选怎么中心对齐</p></blockquote></li><li><p>宏定义不能用<code>-</code>会被当成剑法操作符，使用下划线代替</p></li><li><p>出现方框多是字体不支持该符号，或者是传入的数据越界</p></li></ul><p>5.不小心点了更新库，于是lvgl自动更新了，重新下载微雪官网旧的库，会报错</p><blockquote><p>⚠️需要先删除然后再移过来，直接移动一些旧的库没有的文件仍然还在，所以才会报某些.h文件找不到</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ESP32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人主页</title>
      <link href="/2025/02/13/117-ge-ren-zhu-ye/"/>
      <url>/2025/02/13/117-ge-ren-zhu-ye/</url>
      
        <content type="html"><![CDATA[<p>想做一个导航页，<del>抄</del>参考这个大佬的<a href="https://zyyo.cc/">Zyyo</a>，缝缝补补</p><h1 id="CSS-常用属性"><a href="#CSS-常用属性" class="headerlink" title="CSS 常用属性"></a>CSS 常用属性</h1><h2 id="1-布局"><a href="#1-布局" class="headerlink" title="1. 布局"></a>1. <strong>布局</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>display</code></td><td>设置元素的显示方式</td><td><code>display: flex;</code></td></tr><tr><td><code>flex</code></td><td>定义 flex 容器内的项目如何分配空间</td><td><code>flex: 1;</code></td></tr><tr><td><code>flex-direction</code></td><td>设置 flex 容器内子元素的排列方向</td><td><code>flex-direction: column;</code></td></tr><tr><td><code>justify-content</code></td><td>控制 flex 项目在主轴上的对齐方式</td><td><code>justify-content: center;</code></td></tr><tr><td><code>align-items</code></td><td>控制 flex 项目在交叉轴上的对齐方式</td><td><code>align-items: flex-start;</code></td></tr><tr><td><code>align-self</code></td><td>控制单个 flex 项目在交叉轴上的对齐方式</td><td><code>align-self: center;</code></td></tr><tr><td><code>grid-template-columns</code></td><td>定义 grid 容器的列宽</td><td><code>grid-template-columns: 1fr 2fr;</code></td></tr><tr><td><code>position</code></td><td>设置元素的定位方式</td><td><code>position: absolute;</code></td></tr><tr><td><code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code></td><td>定位元素的位置</td><td><code>top: 10px; left: 20px;</code></td></tr><tr><td><code>z-index</code></td><td>设置元素的堆叠顺序</td><td><code>z-index: 10;</code></td></tr></tbody></table><h2 id="2-尺寸与边距"><a href="#2-尺寸与边距" class="headerlink" title="2. 尺寸与边距"></a>2. <strong>尺寸与边距</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>width</code></td><td>设置元素的宽度</td><td><code>width: 100px;</code></td></tr><tr><td><code>height</code></td><td>设置元素的高度</td><td><code>height: 200px;</code></td></tr><tr><td><code>min-width</code></td><td>设置元素的最小宽度</td><td><code>min-width: 200px;</code></td></tr><tr><td><code>min-height</code></td><td>设置元素的最小高度</td><td><code>min-height: 100px;</code></td></tr><tr><td><code>max-width</code></td><td>设置元素的最大宽度</td><td><code>max-width: 500px;</code></td></tr><tr><td><code>max-height</code></td><td>设置元素的最大高度</td><td><code>max-height: 500px;</code></td></tr><tr><td><code>margin</code></td><td>设置元素的外边距（上、右、下、左）</td><td><code>margin: 10px 20px 30px 40px;</code></td></tr><tr><td><code>padding</code></td><td>设置元素的内边距（上、右、下、左）</td><td><code>padding: 10px 20px;</code></td></tr><tr><td><code>box-sizing</code></td><td>控制元素的盒子模型（<code>content-box</code>、<code>border-box</code>）</td><td><code>box-sizing: border-box;</code></td></tr></tbody></table><h2 id="3-背景与颜色"><a href="#3-背景与颜色" class="headerlink" title="3. 背景与颜色"></a>3. <strong>背景与颜色</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>background-color</code></td><td>设置元素的背景颜色</td><td><code>background-color: #f0f0f0;</code></td></tr><tr><td><code>background-image</code></td><td>设置元素的背景图片</td><td><code>background-image: url(&#39;image.jpg&#39;);</code></td></tr><tr><td><code>background-position</code></td><td>设置背景图片的位置</td><td><code>background-position: center;</code></td></tr><tr><td><code>background-size</code></td><td>设置背景图片的尺寸（<code>cover</code>、<code>contain</code>）</td><td><code>background-size: cover;</code></td></tr><tr><td><code>background-repeat</code></td><td>设置背景图片是否平铺</td><td><code>background-repeat: no-repeat;</code></td></tr><tr><td><code>color</code></td><td>设置文本的颜色</td><td><code>color: red;</code></td></tr><tr><td><code>opacity</code></td><td>设置元素的透明度</td><td><code>opacity: 0.5;</code></td></tr></tbody></table><h2 id="4-文本"><a href="#4-文本" class="headerlink" title="4. 文本"></a>4. <strong>文本</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>font-size</code></td><td>设置字体大小</td><td><code>font-size: 16px;</code></td></tr><tr><td><code>font-family</code></td><td>设置字体系列</td><td><code>font-family: Arial, sans-serif;</code></td></tr><tr><td><code>font-weight</code></td><td>设置字体的粗细</td><td><code>font-weight: bold;</code></td></tr><tr><td><code>line-height</code></td><td>设置文本的行高</td><td><code>line-height: 1.5;</code></td></tr><tr><td><code>text-align</code></td><td>设置文本的水平对齐方式</td><td><code>text-align: center;</code></td></tr><tr><td><code>text-transform</code></td><td>控制文本的大小写</td><td><code>text-transform: uppercase;</code></td></tr><tr><td><code>letter-spacing</code></td><td>设置字符间距</td><td><code>letter-spacing: 1px;</code></td></tr><tr><td><code>word-spacing</code></td><td>设置单词间距</td><td><code>word-spacing: 2px;</code></td></tr><tr><td><code>text-decoration</code></td><td>设置文本的修饰</td><td><code>text-decoration: underline;</code></td></tr><tr><td><code>white-space</code></td><td>设置如何处理空白符</td><td><code>white-space: nowrap;</code></td></tr><tr><td><code>text-shadow</code></td><td>给文本添加阴影效果</td><td><code>text-shadow: 2px 2px 5px gray;</code></td></tr></tbody></table><h2 id="5-边框"><a href="#5-边框" class="headerlink" title="5. 边框"></a>5. <strong>边框</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>border</code></td><td>设置边框样式（<code>border-width</code>, <code>border-style</code>, <code>border-color</code>）</td><td><code>border: 2px solid red;</code></td></tr><tr><td><code>border-radius</code></td><td>设置元素的圆角</td><td><code>border-radius: 10px;</code></td></tr><tr><td><code>border-top</code></td><td>设置上边框</td><td><code>border-top: 3px solid blue;</code></td></tr><tr><td><code>border-right</code></td><td>设置右边框</td><td><code>border-right: 2px dashed green;</code></td></tr><tr><td><code>border-bottom</code></td><td>设置下边框</td><td><code>border-bottom: 1px dotted black;</code></td></tr><tr><td><code>border-left</code></td><td>设置左边框</td><td><code>border-left: 5px solid purple;</code></td></tr></tbody></table><h2 id="6-盒子模型"><a href="#6-盒子模型" class="headerlink" title="6. 盒子模型"></a>6. <strong>盒子模型</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>box-shadow</code></td><td>给元素添加阴影</td><td><code>box-shadow: 10px 10px 5px gray;</code></td></tr><tr><td><code>outline</code></td><td>设置元素的轮廓线（不影响布局）</td><td><code>outline: 2px solid red;</code></td></tr><tr><td><code>outline-offset</code></td><td>设置轮廓的偏移量</td><td><code>outline-offset: 5px;</code></td></tr><tr><td><code>resize</code></td><td>控制元素是否可调整大小</td><td><code>resize: both;</code></td></tr></tbody></table><h2 id="7-过渡与动画"><a href="#7-过渡与动画" class="headerlink" title="7. 过渡与动画"></a>7. <strong>过渡与动画</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>transition</code></td><td>设置元素的过渡效果</td><td><code>transition: all 0.3s ease;</code></td></tr><tr><td><code>transition-duration</code></td><td>设置过渡的持续时间</td><td><code>transition-duration: 0.5s;</code></td></tr><tr><td><code>transition-timing-function</code></td><td>设置过渡的时间函数（<code>ease</code>, <code>linear</code> 等）</td><td><code>transition-timing-function: ease-in;</code></td></tr><tr><td><code>animation</code></td><td>设置元素的动画效果</td><td><code>animation: spin 2s infinite;</code></td></tr><tr><td><code>keyframes</code></td><td>定义动画的关键帧</td><td><code>@keyframes spin &#123; 0% &#123; transform: rotate(0); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125;</code></td></tr></tbody></table><h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. <strong>其他</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>visibility</code></td><td>控制元素的可见性</td><td><code>visibility: hidden;</code></td></tr><tr><td><code>cursor</code></td><td>设置鼠标光标的样式</td><td><code>cursor: pointer;</code></td></tr><tr><td><code>filter</code></td><td>应用视觉效果（如模糊、亮度等）</td><td><code>filter: blur(5px);</code></td></tr><tr><td><code>clip-path</code></td><td>定义元素的剪裁路径</td><td><code>clip-path: circle(50%);</code></td></tr><tr><td><code>object-fit</code></td><td>设置嵌入元素的适应方式</td><td><code>object-fit: cover;</code></td></tr></tbody></table><h2 id="9-响应式设计"><a href="#9-响应式设计" class="headerlink" title="9. 响应式设计"></a>9. <strong>响应式设计</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>@media</code></td><td>使用媒体查询进行响应式设计</td><td><code>@media (max-width: 768px) &#123; /* CSS */ &#125;</code></td></tr><tr><td><code>min-width</code></td><td>在媒体查询中设置最小宽度</td><td><code>@media (min-width: 600px) &#123; /* CSS */ &#125;</code></td></tr><tr><td><code>max-width</code></td><td>在媒体查询中设置最大宽度</td><td><code>@media (max-width: 1200px) &#123; /* CSS */ &#125;</code></td></tr></tbody></table><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这个表格涵盖了常用的 CSS 属性，包括布局、尺寸、文本、背景、边框、动画等方面。你可以根据需要查找和使用这些属性来设计和调整网页的样式。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>本应该出右侧的，出现在了下侧</p><blockquote><p>容器使用flex，父容器中设置flex的垂直排列，改为横向排列<code>flex-direction: row;</code></p></blockquote></li><li><p>让头像居中</p><blockquote><p>text-align: center;</p></blockquote></li><li><p>调整左右侧宽度的时候，出现滚动条，且右侧无法调节</p></li></ol><blockquote><ul><li><p>在 <code>position: relative</code> 的情况下，<code>left</code> 仅仅是 <strong>相对于它原本的位置移动</strong>，并不会真正改变布局。</p></li><li><p><code>right</code> 在 <code>relative</code> 下不会影响 <code>left</code>，只有当 <code>position: absolute</code> 或 <code>fixed</code> 时，<code>right</code> 才会真正起作用。</p></li><li><p><strong><code>left: 200px;</code> 导致 <code>.main</code> 向右偏移，但宽度不变</strong>，所以它可能溢出了视口（浏览器可视区域）。</p></li><li><p><strong><code>flex</code> 默认让子元素按原始宽度排列</strong>，如果 <code>.main</code> 里的子元素宽度超出了 <code>.main</code> 的 <code>width</code>，就会导致溢出，触发水平滚动条。</p></li><li><p><strong>没有使用 <code>overflow: hidden;</code></strong>：默认情况下，超出容器的内容不会自动隐藏，而是会触发滚动条。</p></li></ul></blockquote><p>1. </p><blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>油猴脚本</title>
      <link href="/2024/09/10/116-bai-du-wang-pan-lian-jie-tiao-zhuan/"/>
      <url>/2024/09/10/116-bai-du-wang-pan-lian-jie-tiao-zhuan/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器脚本"><a href="#浏览器脚本" class="headerlink" title="浏览器脚本"></a>浏览器脚本</h2><ol><li><strong>JavaScript 脚本</strong>：<ul><li><strong>执行环境</strong>：通常嵌入在网页中，通过 <code>&lt;script&gt;</code> 标签加载，或者在浏览器的控制台中运行。</li><li><strong>目的</strong>：实现页面功能、处理用户交互、操作 DOM（文档对象模型）等。</li></ul></li><li><strong>用户脚本</strong>：<ul><li><strong>执行环境</strong>：由用户脚本管理器（如 Tampermonkey 或 Greasemonkey）注入到网页中。它们运行在用户的浏览器中，可以修改网页的行为和外观。</li><li><strong>目的</strong>：用户定制网页的功能，添加额外的功能或修复网页上的问题。</li></ul></li></ol><h3 id="document-addEventListener"><a href="#document-addEventListener" class="headerlink" title="document.addEventListener"></a><code>document.addEventListener</code></h3><p><code>document.addEventListener</code> 是 JavaScript 的标准方法，用于在指定的事件发生时执行指定的函数。这是 DOM API 的一部分，允许你在网页上监听和处理用户交互或其他事件。</p><p>用法示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 代码在文档完全加载后运行</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'页面加载完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Node.js 环境</strong></p><p>如果你在 Node.js 环境中运行 JavaScript 代码，<code>document</code> 对象是不存在的，因为 Node.js 是一个服务器端的 JavaScript 环境，没有浏览器提供的 DOM API。</p><p><strong>解决方法</strong>：</p><ul><li>如果你需要在 Node.js 中处理网页内容，考虑使用类似 <code>jsdom</code> 的库来模拟浏览器环境。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">javascript复制代码<span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token constant">JSDOM</span> <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'jsdom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> dom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSDOM</span><span class="token punctuation">(</span><span class="token string">'&lt;html>&lt;body>&lt;h1>Hello world&lt;/h1>&lt;/body>&lt;/html>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> document <span class="token operator">=</span> dom<span class="token punctuation">.</span>window<span class="token punctuation">.</span>document<span class="token punctuation">;</span><span class="token comment">// 现在你可以使用 document 对象</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>textContent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: Hello world</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>已失效</strong></p><h2 id="自动登录实例"><a href="#自动登录实例" class="headerlink" title="自动登录实例"></a>自动登录实例</h2><p>稀土掘金</p><ul><li>速度太快会跳验证码</li><li>需要过拖图验证码</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token string">'use strict'</span><span class="token punctuation">;</span>    <span class="token comment">//alert('HelloWorld')</span>    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".login-button"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> time<span class="token operator">=</span><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".clickable"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'[name="mobile"]'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token operator">=</span><span class="token string">'13304272398'</span>    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'[name="loginPassword"]'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token operator">=</span><span class="token string">'522411Wjq.'</span>    <span class="token comment">//document.querySelector('[class="btn btn-login"]').click()</span>    <span class="token keyword">let</span> submitButton <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.btn.btn-login'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 检查提交按钮是否存在，并点击提交</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>submitButton<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                submitButton<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 点击登录按钮</span>                <span class="token function">clearInterval</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 清除定时器</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入似乎并没有延时，仍会跳转验证1</p><h3 id="V1-1"><a href="#V1-1" class="headerlink" title="V1.1"></a>V1.1</h3><ul><li>会来回切换登录</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token string">'use strict'</span><span class="token punctuation">;</span>    <span class="token comment">// 点击登录按钮</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> loginButton <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".login-button"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loginButton<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            loginButton<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token function">getRandomDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 模拟点击验证码按钮，并填写手机号和密码</span>    <span class="token keyword">let</span> time <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> secretcheckButton <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".clickable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> mobileField <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'[name="mobile"]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> passwordField <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'[name="loginPassword"]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> submitButton <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.btn.btn-login'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果验证码按钮存在，开始后续操作</span>        <span class="token comment">//if (secretcheckButton) &#123;</span>            <span class="token comment">// 点击验证码按钮</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                secretcheckButton<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token function">getRandomDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>mobileField<span class="token operator">&amp;&amp;</span>passwordField<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 输入手机号</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                mobileField<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">'13304272398'</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token function">getRandomDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 输入密码</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                passwordField<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">'522411Wjq.'</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token function">getRandomDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 检查提交按钮是否存在，并点击提交</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>submitButton<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                    submitButton<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 点击登录按钮</span>                    <span class="token function">clearInterval</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 清除定时器</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token function">getRandomDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 随机延迟函数，返回 500ms 到 3500ms 之间的随机值</span>    <span class="token keyword">function</span> <span class="token function">getRandomDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">3000</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="丐版"><a href="#丐版" class="headerlink" title="丐版"></a>丐版</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// ==UserScript==</span><span class="token comment">// @name         百度网盘提取码助手（终极版 v2.5）</span><span class="token comment">// @namespace    https://yourdomain.dev</span><span class="token comment">// @version      2.5</span><span class="token comment">// @description  选中链接+码→跳转 #pwd→轮询填码→美观提示（已支持 share/init?surl &amp; SPA）</span><span class="token comment">// @match        *://*/*</span><span class="token comment">// @match        *://pan.baidu.com/*</span><span class="token comment">// @grant        none</span><span class="token comment">// @run-at       document-end</span><span class="token comment">// ==/UserScript==</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token string">'use strict'</span><span class="token punctuation">;</span>  <span class="token comment">// —— 正则 ——</span>  <span class="token keyword">const</span> <span class="token constant">SHARE_RE</span> <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">https?:\/\/pan\.baidu\.com\/s\/([A-Za-z0-9\-_]+)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token constant">CODE_RE</span>  <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?:提取码|密码)[:：]?\s*([A-Za-z0-9]&#123;4&#125;)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token constant">HASH_RE</span>  <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[#&amp;]pwd=([A-Za-z0-9]&#123;4&#125;)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>  <span class="token comment">// —— 浮层提示 ——</span>  <span class="token keyword">function</span> <span class="token function">showTip</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> d <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    d<span class="token punctuation">.</span>textContent <span class="token operator">=</span> msg<span class="token punctuation">;</span>    Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>style<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">position</span><span class="token operator">:</span>   <span class="token string">'fixed'</span><span class="token punctuation">,</span>      <span class="token literal-property property">top</span><span class="token operator">:</span>        <span class="token string">'20px'</span><span class="token punctuation">,</span>      <span class="token literal-property property">right</span><span class="token operator">:</span>      <span class="token string">'20px'</span><span class="token punctuation">,</span>      <span class="token literal-property property">padding</span><span class="token operator">:</span>    <span class="token string">'10px 15px'</span><span class="token punctuation">,</span>      <span class="token literal-property property">background</span><span class="token operator">:</span> <span class="token string">'rgba(0,0,0,0.75) !important'</span><span class="token punctuation">,</span>      <span class="token literal-property property">color</span><span class="token operator">:</span>      <span class="token string">'#fff'</span><span class="token punctuation">,</span>      <span class="token literal-property property">fontSize</span><span class="token operator">:</span>   <span class="token string">'14px'</span><span class="token punctuation">,</span>      <span class="token literal-property property">borderRadius</span><span class="token operator">:</span><span class="token string">'6px'</span><span class="token punctuation">,</span>      <span class="token literal-property property">boxShadow</span><span class="token operator">:</span>  <span class="token string">'0 4px 12px rgba(0,0,0,0.3)'</span><span class="token punctuation">,</span>      <span class="token literal-property property">zIndex</span><span class="token operator">:</span>     <span class="token string">'2147483647'</span><span class="token punctuation">,</span>      <span class="token literal-property property">opacity</span><span class="token operator">:</span>    <span class="token string">'1'</span><span class="token punctuation">,</span>      <span class="token literal-property property">transition</span><span class="token operator">:</span> <span class="token string">'opacity 0.4s'</span><span class="token punctuation">,</span>      <span class="token literal-property property">pointerEvents</span><span class="token operator">:</span><span class="token string">'none'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> d<span class="token punctuation">.</span>style<span class="token punctuation">.</span>opacity <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> d<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// —— 1. 非 pan.baidu.com 页面：选中跳转+Hash ——</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">pan\.baidu\.com</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>hostname<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mouseup'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> txt <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">getSelection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> sm <span class="token operator">=</span> txt<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token constant">SHARE_RE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sm<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> shareId <span class="token operator">=</span> sm<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> cm <span class="token operator">=</span> txt<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token constant">CODE_RE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">showTip</span><span class="token punctuation">(</span><span class="token string">'✅ 检测到百度网盘链接'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>cm<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> pwd <span class="token operator">=</span> cm<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">链接：\nhttps://pan.baidu.com/s/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>shareId<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">\n提取码：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>pwd<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">\n\n跳转并自动填码？</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">https://pan.baidu.com/s/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>shareId<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">#pwd=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>pwd<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token string">'_blank'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">链接：\nhttps://pan.baidu.com/s/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>shareId<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">\n无提取码，是否跳转？</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">https://pan.baidu.com/s/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>shareId<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token string">'_blank'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// —— 2. pan.baidu.com 页面：从 Hash 读码并自动填 ——</span>  <span class="token keyword">const</span> hm <span class="token operator">=</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token constant">HASH_RE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hm<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> code <span class="token operator">=</span> hm<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">showTip</span><span class="token punctuation">(</span><span class="token string">'检测到提取码：'</span> <span class="token operator">+</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// —— 3. 轮询尝试填写 ——</span>  <span class="token keyword">let</span> attempts <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> maxAttempts <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    attempts<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 输入框</span>    <span class="token keyword">const</span> inp <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>      <span class="token string">'#accessCode, .pickpw input, input.QKKaIE, input[placeholder*="提取码"]'</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 按钮</span>    <span class="token keyword">const</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#submitBtn, .submit-btn-text'</span><span class="token punctuation">)</span>             <span class="token operator">||</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button, a, div'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                     <span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">el</span> <span class="token operator">=></span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">提取文件|提交</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>innerText<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inp <span class="token operator">&amp;&amp;</span> btn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      inp<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      inp<span class="token punctuation">.</span>value <span class="token operator">=</span> code<span class="token punctuation">;</span>      inp<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">bubbles</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      btn<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">showTip</span><span class="token punctuation">(</span><span class="token string">'✅ 已自动填写并提交'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>attempts <span class="token operator">>=</span> maxAttempts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">showTip</span><span class="token punctuation">(</span><span class="token string">'⚠️ 未能自动填码，请手动输入'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h3><p>美化弹窗</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// ==UserScript==</span><span class="token comment">// @name         百度网盘链接助手</span><span class="token comment">// @namespace    http://tampermonkey.net/</span><span class="token comment">// @version      2.0</span><span class="token comment">// @description  自动识别百度网盘链接并填写提取码</span><span class="token comment">// @author       Assistant</span><span class="token comment">// @match        *://*/*</span><span class="token comment">// @grant        none</span><span class="token comment">// @run-at       document-end</span><span class="token comment">// ==/UserScript==</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token string">'use strict'</span><span class="token punctuation">;</span>    <span class="token comment">// 注入样式</span>    <span class="token keyword">function</span> <span class="token function">injectStyles</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'baidu-helper-styles'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> style <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'style'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        style<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'baidu-helper-styles'</span><span class="token punctuation">;</span>        style<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">            .baidu-helper-overlay &#123;                position: fixed;                top: 0;                left: 0;                width: 100%;                height: 100%;                background: rgba(0, 0, 0, 0.6);                backdrop-filter: blur(4px);                z-index: 999999;                opacity: 0;                animation: fadeIn 0.2s forwards;            &#125;            .baidu-helper-dialog &#123;                position: fixed;                top: 50%;                left: 50%;                transform: translate(-50%, -50%) scale(0.9);                background: #fff;                border-radius: 16px;                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);                z-index: 1000000;                min-width: 380px;                max-width: 90vw;                animation: dialogShow 0.3s ease-out forwards;                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;            &#125;            .baidu-helper-header &#123;                display: flex;                align-items: center;                padding: 24px 24px 16px;                border-bottom: 1px solid #f0f0f0;            &#125;            .baidu-helper-icon &#123;                width: 32px;                height: 32px;                background: linear-gradient(135deg, #2196F3, #1976D2);                border-radius: 8px;                display: flex;                align-items: center;                justify-content: center;                margin-right: 12px;                flex-shrink: 0;            &#125;            .baidu-helper-title &#123;                font-size: 18px;                font-weight: 600;                color: #1a1a1a;                margin: 0;            &#125;            .baidu-helper-content &#123;                padding: 20px 24px;            &#125;            .baidu-helper-link-item &#123;                background: #f8f9fa;                border: 1px solid #e9ecef;                border-radius: 10px;                padding: 16px;                margin-bottom: 12px;                font-size: 14px;                line-height: 1.5;            &#125;            .baidu-helper-link-item:last-child &#123;                margin-bottom: 0;            &#125;            .baidu-helper-label &#123;                font-weight: 600;                color: #495057;                margin-bottom: 4px;            &#125;            .baidu-helper-text &#123;                color: #6c757d;                word-break: break-all;                font-family: 'Consolas', 'Monaco', monospace;                background: #fff;                padding: 8px 12px;                border-radius: 6px;                border: 1px solid #dee2e6;            &#125;            .baidu-helper-actions &#123;                display: flex;                gap: 12px;                padding: 16px 24px 24px;                justify-content: flex-end;            &#125;            .baidu-helper-btn &#123;                padding: 12px 24px;                border: none;                border-radius: 8px;                font-weight: 500;                cursor: pointer;                transition: all 0.2s ease;                font-size: 14px;                min-width: 80px;            &#125;            .baidu-helper-btn:hover &#123;                transform: translateY(-1px);                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);            &#125;            .baidu-helper-btn-primary &#123;                background: linear-gradient(135deg, #2196F3, #1976D2);                color: white;            &#125;            .baidu-helper-btn-secondary &#123;                background: #f8f9fa;                color: #6c757d;                border: 1px solid #dee2e6;            &#125;            @keyframes fadeIn &#123;                to &#123; opacity: 1; &#125;            &#125;            @keyframes dialogShow &#123;                to &#123;                    opacity: 1;                    transform: translate(-50%, -50%) scale(1);                &#125;            &#125;            @media (max-width: 480px) &#123;                .baidu-helper-dialog &#123;                    min-width: 320px;                    margin: 20px;                &#125;            &#125;        </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>        document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>style<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 提取百度网盘链接信息</span>    <span class="token keyword">function</span> <span class="token function">extractBaiduLinks</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 更宽松的链接匹配</span>        <span class="token keyword">const</span> linkRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">https?:\/\/pan\.baidu\.com\/s\/[a-zA-Z0-9_\-]+(\?pwd=[a-zA-Z0-9]&#123;4&#125;)?</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">;</span>        <span class="token keyword">const</span> links <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>text<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>linkRegex<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>links<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> linkMatch <span class="token keyword">of</span> links<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> fullLink <span class="token operator">=</span> linkMatch<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> <span class="token punctuation">[</span>baseUrl<span class="token punctuation">,</span> pwdParam<span class="token punctuation">]</span> <span class="token operator">=</span> fullLink<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'?pwd='</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">let</span> extractCode <span class="token operator">=</span> pwdParam <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token comment">// 如果链接中没有提取码，尝试从周围文本中查找</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>extractCode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 查找链接附近的提取码</span>                <span class="token keyword">const</span> linkIndex <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>fullLink<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">const</span> contextStart <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> linkIndex <span class="token operator">-</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">const</span> contextEnd <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span>length<span class="token punctuation">,</span> linkIndex <span class="token operator">+</span> fullLink<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">const</span> context <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>contextStart<span class="token punctuation">,</span> contextEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">const</span> codePatterns <span class="token operator">=</span> <span class="token punctuation">[</span>                    <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?:提取码|密码|验证码|码|pwd|password)[:：\s]*([a-zA-Z0-9]&#123;4&#125;)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">,</span>                    <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\b([a-zA-Z0-9]&#123;4&#125;)\b</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>                <span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> pattern <span class="token keyword">of</span> codePatterns<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">const</span> matches <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>context<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> match <span class="token keyword">of</span> matches<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">const</span> code <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token comment">// 验证提取码格式（4位字母数字组合）</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[a-zA-Z0-9]&#123;4&#125;$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> code <span class="token operator">!==</span> fullLink<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            extractCode <span class="token operator">=</span> code<span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>extractCode<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            results<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token literal-property property">link</span><span class="token operator">:</span> baseUrl<span class="token punctuation">,</span>                <span class="token literal-property property">extractCode</span><span class="token operator">:</span> extractCode<span class="token punctuation">,</span>                <span class="token literal-property property">fullLink</span><span class="token operator">:</span> fullLink            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> results<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> results <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 显示弹窗</span>    <span class="token keyword">function</span> <span class="token function">showDialog</span><span class="token punctuation">(</span><span class="token parameter">linkInfos</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 移除现有弹窗</span>        <span class="token keyword">const</span> existingOverlay <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.baidu-helper-overlay'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>existingOverlay<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            existingOverlay<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">injectStyles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建遮罩层</span>        <span class="token keyword">const</span> overlay <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        overlay<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">'baidu-helper-overlay'</span><span class="token punctuation">;</span>        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>overlay<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建弹窗</span>        <span class="token keyword">const</span> dialog <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dialog<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">'baidu-helper-dialog'</span><span class="token punctuation">;</span>        <span class="token comment">// 头部</span>        <span class="token keyword">const</span> header <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        header<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">'baidu-helper-header'</span><span class="token punctuation">;</span>        header<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">            &lt;div class="baidu-helper-icon">                &lt;svg width="16" height="16" viewBox="0 0 24 24" fill="white">                    &lt;path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>                &lt;/svg>            &lt;/div>            &lt;h3 class="baidu-helper-title">✨ 发现百度网盘链接&lt;/h3>        </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>        <span class="token comment">// 内容</span>        <span class="token keyword">const</span> content <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        content<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">'baidu-helper-content'</span><span class="token punctuation">;</span>        linkInfos<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">info<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> item <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            item<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">'baidu-helper-link-item'</span><span class="token punctuation">;</span>            <span class="token keyword">let</span> itemHTML <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">                &lt;div class="baidu-helper-label">🔗 链接 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">:&lt;/div>                &lt;div class="baidu-helper-text"></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>info<span class="token punctuation">.</span>link<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">&lt;/div>            </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>info<span class="token punctuation">.</span>extractCode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                itemHTML <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">                    &lt;div class="baidu-helper-label" style="margin-top: 12px;">🔑 提取码:&lt;/div>                    &lt;div class="baidu-helper-text"></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>info<span class="token punctuation">.</span>extractCode<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">&lt;/div>                </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            item<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> itemHTML<span class="token punctuation">;</span>            content<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 按钮</span>        <span class="token keyword">const</span> actions <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        actions<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">'baidu-helper-actions'</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> cancelBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cancelBtn<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">'baidu-helper-btn baidu-helper-btn-secondary'</span><span class="token punctuation">;</span>        cancelBtn<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">'取消'</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> confirmBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        confirmBtn<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">'baidu-helper-btn baidu-helper-btn-primary'</span><span class="token punctuation">;</span>        confirmBtn<span class="token punctuation">.</span>textContent <span class="token operator">=</span> linkInfos<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">?</span>            <span class="token punctuation">(</span>linkInfos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>extractCode <span class="token operator">?</span> <span class="token string">'🚀跳转并填写提取码'</span> <span class="token operator">:</span> <span class="token string">'🚀跳转到链接'</span><span class="token punctuation">)</span> <span class="token operator">:</span>            <span class="token string">'🚀打开所有链接'</span><span class="token punctuation">;</span>        actions<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>cancelBtn<span class="token punctuation">)</span><span class="token punctuation">;</span>        actions<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>confirmBtn<span class="token punctuation">)</span><span class="token punctuation">;</span>        dialog<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>        dialog<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>        dialog<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>actions<span class="token punctuation">)</span><span class="token punctuation">;</span>        overlay<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>dialog<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 事件处理</span>        <span class="token keyword">const</span> <span class="token function-variable function">closeDialog</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> overlay<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cancelBtn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> closeDialog<span class="token punctuation">;</span>        overlay<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>target <span class="token operator">===</span> overlay<span class="token punctuation">)</span> <span class="token function">closeDialog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        confirmBtn<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            linkInfos<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">info</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>info<span class="token punctuation">.</span>extractCode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'baiduAutoFillCode_'</span> <span class="token operator">+</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> info<span class="token punctuation">.</span>extractCode<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">const</span> targetUrl <span class="token operator">=</span> info<span class="token punctuation">.</span>link <span class="token operator">+</span> <span class="token string">'?pwd='</span> <span class="token operator">+</span> info<span class="token punctuation">.</span>extractCode<span class="token punctuation">;</span>                    window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>targetUrl<span class="token punctuation">,</span> <span class="token string">'_blank'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span>link<span class="token punctuation">,</span> <span class="token string">'_blank'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">closeDialog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token comment">// ESC键关闭</span>        <span class="token keyword">const</span> <span class="token function-variable function">handleKeydown</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">===</span> <span class="token string">'Escape'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">closeDialog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                document<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'keydown'</span><span class="token punctuation">,</span> handleKeydown<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'keydown'</span><span class="token punctuation">,</span> handleKeydown<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 文本选择监听</span>    <span class="token keyword">function</span> <span class="token function">handleTextSelection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> selectionTimeout<span class="token punctuation">;</span>        document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mouseup'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token function">clearTimeout</span><span class="token punctuation">(</span>selectionTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>            selectionTimeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">const</span> selection <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">getSelection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">const</span> selectedText <span class="token operator">=</span> selection<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>selectedText<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'百度网盘助手: 检测选中文本:'</span><span class="token punctuation">,</span> selectedText<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">const</span> linkInfos <span class="token operator">=</span> <span class="token function">extractBaiduLinks</span><span class="token punctuation">(</span>selectedText<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>linkInfos<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'百度网盘助手: 发现链接:'</span><span class="token punctuation">,</span> linkInfos<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">showDialog</span><span class="token punctuation">(</span>linkInfos<span class="token punctuation">)</span><span class="token punctuation">;</span>                    selection<span class="token punctuation">.</span><span class="token function">removeAllRanges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清除选择</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 自动填写提取码</span>    <span class="token keyword">function</span> <span class="token function">autoFillExtractCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 查找sessionStorage中的提取码</span>        <span class="token keyword">const</span> codes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sessionStorage<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> key <span class="token operator">=</span> sessionStorage<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'baiduAutoFillCode_'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                codes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                    <span class="token literal-property property">key</span><span class="token operator">:</span> key<span class="token punctuation">,</span>                    <span class="token literal-property property">code</span><span class="token operator">:</span> sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>codes<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'百度网盘助手: 找到提取码'</span><span class="token punctuation">,</span> codes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 常见的输入框选择器</span>        <span class="token keyword">const</span> inputSelectors <span class="token operator">=</span> <span class="token punctuation">[</span>            <span class="token string">'input[placeholder*="提取码"]'</span><span class="token punctuation">,</span>            <span class="token string">'input[placeholder*="访问码"]'</span><span class="token punctuation">,</span>            <span class="token string">'input#accessCode'</span><span class="token punctuation">,</span>            <span class="token string">'input.vcode'</span><span class="token punctuation">,</span>            <span class="token string">'input[name*="code"]'</span><span class="token punctuation">,</span>            <span class="token string">'.pickpw input'</span><span class="token punctuation">,</span>            <span class="token string">'.access-code input'</span>        <span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 常见的按钮选择器</span>        <span class="token keyword">const</span> buttonSelectors <span class="token operator">=</span> <span class="token punctuation">[</span>            <span class="token string">'button[type="submit"]'</span><span class="token punctuation">,</span>            <span class="token string">'.g-button'</span><span class="token punctuation">,</span>            <span class="token string">'.pickpw button'</span><span class="token punctuation">,</span>            <span class="token string">'button:contains("提取")'</span><span class="token punctuation">,</span>            <span class="token string">'button:contains("确定")'</span>        <span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> inputFound <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> selector <span class="token keyword">of</span> inputSelectors<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> input <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>input <span class="token operator">&amp;&amp;</span> input<span class="token punctuation">.</span>offsetParent <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 确保元素可见</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'百度网盘助手: 找到输入框'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 使用第一个提取码</span>                <span class="token keyword">const</span> codeInfo <span class="token operator">=</span> codes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                input<span class="token punctuation">.</span>value <span class="token operator">=</span> codeInfo<span class="token punctuation">.</span>code<span class="token punctuation">;</span>                input<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 触发事件</span>                <span class="token punctuation">[</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token string">'change'</span><span class="token punctuation">,</span> <span class="token string">'keyup'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">eventType</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                    input<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">bubbles</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 查找并点击按钮</span>                <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> btnSelector <span class="token keyword">of</span> buttonSelectors<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">const</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>btnSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>button <span class="token operator">&amp;&amp;</span> button<span class="token punctuation">.</span>offsetParent <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>                            <span class="token punctuation">(</span>button<span class="token punctuation">.</span>textContent<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">'提取'</span><span class="token punctuation">)</span> <span class="token operator">||</span>                             button<span class="token punctuation">.</span>textContent<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">'确定'</span><span class="token punctuation">)</span> <span class="token operator">||</span>                             button<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'submit'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'百度网盘助手: 点击按钮'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            button<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token comment">// 清除使用过的提取码</span>                    sessionStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span>codeInfo<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                inputFound <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inputFound<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'百度网盘助手: 未找到输入框，稍后重试'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 主逻辑</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>location<span class="token punctuation">.</span>hostname<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">'pan.baidu.com'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 在百度网盘页面自动填写提取码</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'百度网盘助手: 百度网盘页面，启动自动填写'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 页面加载完成后尝试填写</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token string">'loading'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span> autoFillExtractCode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span>autoFillExtractCode<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 监听DOM变化</span>        <span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span>autoFillExtractCode<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>            <span class="token literal-property property">childList</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            <span class="token literal-property property">subtree</span><span class="token operator">:</span> <span class="token boolean">true</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 在其他页面监听文本选择</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'百度网盘助手: 普通页面，启动链接检测'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">handleTextSelection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>与python脚本不同，python是发起请求，js可以调库点击，一个是模拟浏览器发请求，一个是让浏览器发请求</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learn.scriptcat.org/%E6%B2%B9%E7%8C%B4%E6%95%99%E7%A8%8B/%E5%85%A5%E9%97%A8%E7%AF%87/%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B9%8B%E6%A8%A1%E6%8B%9F%E7%82%B9%E5%87%BB%E5%92%8C%E8%A1%A8%E5%8D%95%E5%A1%AB%E5%86%99/">脚本自动化之模拟点击和表单填写 | 油猴开发指南 (scriptcat.org)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实时汇率API更新</title>
      <link href="/2024/07/28/115-shi-shi-hui-lu-api-wan-shan/"/>
      <url>/2024/07/28/115-shi-shi-hui-lu-api-wan-shan/</url>
      
        <content type="html"><![CDATA[<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ul><li>用户调用一次API，则爬取一次源站，浪费资源</li><li>不能并发</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>新的源站 <a href="https://www.msn.cn/zh-cn/money/watchlist?id=auzy5r&tab=Recent">1 BMD &#x3D; 7.2502 CNY (msn.cn)</a></li><li>数据库</li></ul><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>每三个小时获取一次数据，存储到数据库中，用户直接从数据库中获取。 </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>需要js发起请求，批量获取</p><p>暂时完善不了，先鸽子</p><h3 id="需要的参数"><a href="#需要的参数" class="headerlink" title="需要的参数"></a>需要的参数</h3><p>获取id，似乎不是生成的</p><p><strong>url</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">base_url &#x3D; &quot;https:&#x2F;&#x2F;assets.msn.cn&#x2F;service&#x2F;Finance&#x2F;IdMap&quot;   url &#x3D; &#39;https:&#x2F;&#x2F;assets.msn.cn&#x2F;service&#x2F;Finance&#x2F;Charts&#39;   base_url &#x3D; &quot;https:&#x2F;&#x2F;assets.msn.cn&#x2F;service&#x2F;Finance&#x2F;Quotes&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2024/07/28/115-shi-shi-hui-lu-api-wan-shan/image-20240730181641735.png" class="" title="image-20240730181641735"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requests# 基本 URLbase_url &#x3D; &quot;https:&#x2F;&#x2F;assets.msn.cn&#x2F;service&#x2F;Finance&#x2F;IdMap&quot;# 参数params &#x3D; &#123;    &quot;apikey&quot;: &quot;0QfOX3Vn51YCzitbLaRkTTBadtWpgTN8NZLW0C1SEM&quot;,    &quot;activityId&quot;: &quot;0FA1F737-A1E8-4A29-A842-180324023DF7&quot;,#变化    &quot;ocid&quot;: &quot;finance-utils-peregrine&quot;,    &quot;cm&quot;: &quot;zh-cn&quot;,    &quot;it&quot;: &quot;edgeid&quot;,    &quot;scn&quot;: &quot;APP_ANON&quot;,    &quot;MStarIds&quot;: &quot;PKRCNY&quot;#变化ARSCNY&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">base_url &#x3D; &quot;https:&#x2F;&#x2F;assets.msn.cn&#x2F;service&#x2F;Finance&#x2F;Quotes&quot;# 参数params &#x3D; &#123;    &quot;apikey&quot;: &quot;0QfOX3Vn51YCzitbLaRkTTBadtWpgTN8NZLW0C1SEM&quot;,    &quot;activityId&quot;: &quot;0FA1F737-A1E8-4A29-A842-180324023DF7&quot;,    &quot;ocid&quot;: &quot;finance-utils-peregrine&quot;,    &quot;cm&quot;: &quot;zh-cn&quot;,    &quot;it&quot;: &quot;edgeid&quot;,    &quot;scn&quot;: &quot;APP_ANON&quot;,    &quot;ids&quot;: &quot;auxj9c&quot;,  ## 如何获取    &quot;wrapodata&quot;: &quot;false&quot;&#125;# 发起请求response &#x3D; requests.get(base_url, params&#x3D;params)# 检查响应状态并获取数据if response.status_code &#x3D;&#x3D; 200:    data &#x3D; response.json()    print(data)else:    print(f&quot;请求失败，状态码：&#123;response.status_code&#125;&quot;)if isinstance(data, list) and len(data) &gt; 0 and &#39;price&#39; in data[0]:    price &#x3D; data[0][&#39;price&#39;]    Currency &#x3D; data[0][&#39;fromCurrency&#39;]    print(f&quot;&#123;Currency&#125;: &#123;price&#125;&quot;)else:    print(&quot;响应数据格式不正确或不包含&#39;price&#39;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最后完成"><a href="#最后完成" class="headerlink" title="最后完成"></a>最后完成</h2><p>选择原来的网站,但是是一次一次发起请求获取后存储,每个请求间隔3s,每两个小时获取一次,ps常用货币</p><ul><li>mongo库</li><li>redis是使用内存快速响应的库</li><li>连接，插入，更新，删除</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymongoimport time# 连接MongoDBclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)# 创建数据库和集合db &#x3D; client[&quot;test_db&quot;]collection &#x3D; db[&quot;test_collection&quot;]# 准备数据data &#x3D; [&#123;&quot;name&quot;: chr(97 + i), &quot;value&quot;: i + 1&#125; for i in range(10)]print(&quot;初始数据: &quot;, data)# 插入数据collection.insert_many(data)print(&quot;数据已插入&quot;)# 等待30秒time.sleep(5)# 更新数据，将name与value对调for item in data:    collection.update_one(&#123;&quot;name&quot;: item[&quot;name&quot;]&#125;, &#123;&quot;$set&quot;: &#123;&quot;name&quot;: item[&quot;value&quot;], &quot;value&quot;: item[&quot;name&quot;]&#125;&#125;)# 验证更新updated_data &#x3D; list(collection.find(&#123;&#125;))print(&quot;更新后的数据: &quot;, updated_data)# 清理数据库# collection.drop()# client.drop_database(&quot;test_db&quot;)client.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>感觉程序没有被调用</p><p>不是，是被限制访问了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data &#x3D; [    &#123;&quot;currency&quot;: COMMON_ABBREVIATIONS[i], &quot;value&quot;: get_exchange_rate(COMMON_ABBREVIATIONS[i])&#125;    for i in range(len(COMMON_ABBREVIATIONS))]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网页监控</title>
      <link href="/2024/07/28/113-wang-ye-jian-kong/"/>
      <url>/2024/07/28/113-wang-ye-jian-kong/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>定时抓取</li><li>内容保存与对比(哈希值)</li><li>邮箱或者微信通知</li></ul><h2 id="定时抓取"><a href="#定时抓取" class="headerlink" title="定时抓取"></a>定时抓取</h2><ul><li>抓取后应该比较标题和内容(容易出现相同标题的文章)，所以选择比较文章链接</li><li><em>更新</em></li><li><em>内容更改</em>(所以是不是应该爬取整片的内容做成哈希值进行比对，那就要比较所有文章的哈希值，这样不是很必要）</li></ul><h2 id="内容保存"><a href="#内容保存" class="headerlink" title="内容保存"></a>内容保存</h2><p>保存哈希值</p><h2 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h2><ul><li>使用搭建好的微信推送api</li><li>邮件</li><li>短信</li></ul><h3 id="推送格式"><a href="#推送格式" class="headerlink" title="推送格式"></a>推送格式</h3><blockquote><p>类别：blog更新</p><p>标题：</p><p>链接：</p><p>时间</p></blockquote><h2 id="搭建项目环境"><a href="#搭建项目环境" class="headerlink" title="搭建项目环境"></a>搭建项目环境</h2><h3 id="使用-venv-模块创建虚拟环境"><a href="#使用-venv-模块创建虚拟环境" class="headerlink" title="使用 venv 模块创建虚拟环境"></a>使用 <code>venv</code> 模块创建虚拟环境</h3><h4 id="步骤一：安装-venv"><a href="#步骤一：安装-venv" class="headerlink" title="步骤一：安装 venv"></a>步骤一：安装 <code>venv</code></h4><p>通常Python 3已经自带 <code>venv</code> 模块，如果没有，可以通过以下命令安装：</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install python3-venv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="步骤二：创建虚拟环境"><a href="#步骤二：创建虚拟环境" class="headerlink" title="步骤二：创建虚拟环境"></a>步骤二：创建虚拟环境</h4><ol><li><p><strong>进入你的项目目录</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;path&#x2F;to&#x2F;your&#x2F;project#我的项目目录在optcd opt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>创建虚拟环境</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 -m venv venv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将在你的项目目录中创建一个名为 <code>venv</code> 的文件夹，包含虚拟环境。</p></li></ol><h4 id="步骤三：激活虚拟环境"><a href="#步骤三：激活虚拟环境" class="headerlink" title="步骤三：激活虚拟环境"></a>步骤三：激活虚拟环境</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source venv&#x2F;bin&#x2F;activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>激活后，你的命令行提示符会发生变化，显示虚拟环境的名称，例如 <code>(venv)</code>。</p><h4 id="步骤四：安装所需的Python包"><a href="#步骤四：安装所需的Python包" class="headerlink" title="步骤四：安装所需的Python包"></a>步骤四：安装所需的Python包</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="步骤五：退出虚拟环境"><a href="#步骤五：退出虚拟环境" class="headerlink" title="步骤五：退出虚拟环境"></a>步骤五：退出虚拟环境</h4><p>完成工作后，你可以通过以下命令退出虚拟环境：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="重建虚拟环境"><a href="#重建虚拟环境" class="headerlink" title="重建虚拟环境"></a>重建虚拟环境</h2><p><strong>删除虚拟环境</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm -rf &#x2F;opt&#x2F;venv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>重新创建虚拟环境</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 -m venv &#x2F;opt&#x2F;env<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>激活虚拟环境</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source &#x2F;opt&#x2F;venv&#x2F;bin&#x2F;activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>系统中已经安装了 Python 3.9.2，但没有 <code>python</code> 命令的别名。使用<code>符号链接</code>，将 <code>python3</code> 命令创建一个别名为 <code>python</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;pythonpython3 --versionpython --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="符号链接-快捷方式"><a href="#符号链接-快捷方式" class="headerlink" title="符号链接(快捷方式)"></a>符号链接(快捷方式)</h3><ol><li><strong>可见性</strong>：符号链接文件可以通过 <code>ls -l</code> 命令看到链接关系。</li><li><strong>目标文件删除</strong>：如果目标文件被删除，符号链接将指向一个无效的位置，成为“悬挂”链接。</li></ol><h3 id="创建符号链接"><a href="#创建符号链接" class="headerlink" title="创建符号链接"></a>创建符号链接</h3><p>使用 <code>ln -s</code> 命令可以创建符号链接：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ln -s [目标文件或目录] [符号链接名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ln -s &#x2F;usr&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="删除符号链接"><a href="#删除符号链接" class="headerlink" title="删除符号链接"></a>删除符号链接</h3><p>删除符号链接时只需要删除链接文件本身，不会影响目标文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm &#x2F;usr&#x2F;bin&#x2F;python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令只删除符号链接 <code>link_to_file.txt</code>，不影响 <code>original_file.txt</code>。</p><h2 id="招生信息监测"><a href="#招生信息监测" class="headerlink" title="招生信息监测"></a>招生信息监测</h2><p><a href="https://gs.dlut.edu.cn/yjszs/zcwj1.htm">大连理工大学研究生院（新） (dlut.edu.cn)</a></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">/html/body/div[2]/div[2]/div[2]/div/ul/li[1]/a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="http://yz.neu.edu.cn/sszs/list.htm">东北大学硕士公告 (neu.edu.cn)</a></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">//*[@id="wp_news_w6"]/ul/li[1]/div[1]/span[2]/a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网站迁移</title>
      <link href="/2024/07/28/114-wang-zhan-qian-yi/"/>
      <url>/2024/07/28/114-wang-zhan-qian-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="导出项目包"><a href="#导出项目包" class="headerlink" title="导出项目包"></a>导出项目包</h2><p>为了只输出当前 Python 项目中实际使用到的库的 requirements 文件，<code>pipreqs</code> 会根据项目中的导入语句自动生成 <code>requirements.txt</code> 文件，仅包含项目实际使用到的库。</p><ol><li>安装 pipreqs</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install pipreqs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">pip freeze &gt; requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>使用 pipreqs</li></ol><p>导航到你的项目目录，并运行以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pipreqs &#x2F;path&#x2F;to&#x2F;your&#x2F;project<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你的项目位于当前目录，可以使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pipreqs .pipreqs . --encoding&#x3D;utf-8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">pip install -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要关闭代理</p><h2 id="批量删除包"><a href="#批量删除包" class="headerlink" title="批量删除包"></a>批量删除包</h2><h3 id="方法-1：使用-pip-freeze-和-xargs"><a href="#方法-1：使用-pip-freeze-和-xargs" class="headerlink" title="方法 1：使用 pip freeze 和 xargs"></a>方法 1：使用 pip freeze 和 xargs</h3><ol><li><p><strong>列出所有已安装的包并保存到文件中：</strong></p><pre class="line-numbers language-none"><code class="language-none">pip freeze &gt; requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>编辑 requirements.txt 文件（可选）：</strong> 如果你想要保留某些包，可以手动编辑 <code>requirements.txt</code> 文件，删除那些你不想卸载的包。</p></li><li><p><strong>批量删除包：</strong> 使用 <code>xargs</code> 命令从 <code>requirements.txt</code> 文件中读取包名并删除它们</p><pre class="line-numbers language-none"><code class="language-none">cat requirements.txt | xargs pip uninstall -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微信消息推送</title>
      <link href="/2024/07/20/112-wei-xin-xiao-xi-tui-song/"/>
      <url>/2024/07/20/112-wei-xin-xiao-xi-tui-song/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>一个企业微信</li><li>企业微信里面建立一个<code>应用</code></li><li>记录应用的<code>agentid</code>与<code>secret</code></li></ul><h2 id="获取access-token"><a href="#获取access-token" class="headerlink" title="获取access_token"></a><a href="https://developer.work.weixin.qq.com/document/path/91039">获取access_token</a></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">url &#x3D; f&quot;https:&#x2F;&#x2F;qyapi.weixin.qq.com&#x2F;cgi-bin&#x2F;gettoken?corpid&#x3D;&#123;corp_id&#125;&amp;corpsecret&#x3D;&#123;corp_secret&#125;&quot;response &#x3D; requests.get(url)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>7200秒更新一次，所以获取后可以缓存一下</p><h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><ol><li>每个成员都有唯一的<code>userid</code>，即所谓“账号”。在管理后台-&gt;“通讯录”-&gt;点进某个成员的详情页</li></ol><img src="/2024/07/20/112-wei-xin-xiao-xi-tui-song/image-20240728123528837.png" class="" title="image-20240728123528837"><ol start="2"><li><p>在管理后台-&gt;“应用管理”-&gt;“应用”，点进某个应用，即可看到<code>agentid</code>。</p></li><li><p>在管理后台-&gt;“应用管理”-&gt;“应用”-&gt;“自建”，点进某个应用，即可看到<code>secret</code></p></li></ol><img src="/2024/07/20/112-wei-xin-xiao-xi-tui-song/image-20240728123643793.png" class="" title="image-20240728123643793"><ol start="4"><li><p>“我的企业”－“企业信息”下查看“<code>企业ID</code>”</p></li><li><p>每个部门都有唯一的部门id，在管理后台-&gt;“通讯录”-&gt;“组织架构”-&gt;点击某个部门右边的小圆点可以看到，从1开始。</p></li></ol><img src="/2024/07/20/112-wei-xin-xiao-xi-tui-song/image-20240728123757440.png" class="" title="image-20240728123757440"><ol start="6"><li>每个标签都有唯一的<code>标签id</code>，在管理后台-&gt;“通讯录”-&gt;“标签”，选中某个标签，在右上角会有“标签详情”按钮，</li></ol><img src="/2024/07/20/112-wei-xin-xiao-xi-tui-song/image-20240728124149544.png" class="" title="image-20240728124149544"><img src="/2024/07/20/112-wei-xin-xiao-xi-tui-song/image-20240728124117234.png" class="" title="image-20240728124117234"><h2 id="设置ip白名单"><a href="#设置ip白名单" class="headerlink" title="设置ip白名单"></a>设置ip白名单</h2><ul><li>进入具体应用下，搭建网站，放入校验文件</li><li>验证可信域名</li><li>设置ip白名单</li></ul><img src="/2024/07/20/112-wei-xin-xiao-xi-tui-song/image-20240728124515817.png" class="" title="image-20240728124515817"><h3 id="搭建校验网站"><a href="#搭建校验网站" class="headerlink" title="搭建校验网站"></a>搭建校验网站</h3><p>用flask开启端口，然后nginx映射域名到这个端口。</p><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 80;    server_name wx.destroy.cool;    root &#x2F;var&#x2F;www&#x2F;weixin;        # 提供静态文件(校验文件)    location &#x2F;WW_verify_b2PoGgNZ2RLswi2p.txt &#123;        alias &#x2F;var&#x2F;www&#x2F;weixin&#x2F;WW_verify_b2PoGgNZ2RLswi2p.txt;    &#125;        location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;127.0.0.1:5001;  # 指向现有的Flask应用        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置软连接(所有的nginx配置都需要，这是nginx的配置方式)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;weixin.conf &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>问题</strong></p><p>nginx配置没问题，另一个api依然好用，ip访问没问题，域名出了问题。</p><p>破案了，域名打错了。</p><ul><li><p><a href="http://wx.destory.cool/wechat">wx.destory.cool&#x2F;wechat</a></p></li><li><p><a href="http://wx.destroy.cool/wechat">wx.destroy.cool</a>是正确的</p></li></ul><h2 id="搭建微信通知Api"><a href="#搭建微信通知Api" class="headerlink" title="搭建微信通知Api"></a>搭建微信通知Api</h2><ol><li><p>使用应用id与密钥获取access_access_token(缓存两小时)</p></li><li><p>使用token构建url，构建userid等请求参数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">payload &#x3D; &#123;    &quot;touser&quot;: to_user,  # 接收消息的成员ID列表，多个用 &#39;|&#39; 分隔    &quot;msgtype&quot;: &quot;text&quot;,    &quot;agentid&quot;: agent_id,    &quot;text&quot;: &#123;        &quot;content&quot;: f&quot;&#123;title&#125;\n&#123;content&#125;&quot;    &#125;,    &quot;safe&quot;: 0&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>缓存库与限流器的使用</p></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">from flask import Flask, request, jsonifyimport requestsimport jsonimport requests_cachefrom flask_limiter import Limiter, RateLimitExceededfrom flask_limiter.util import get_remote_addressapp &#x3D; Flask(__name__)# 配置缓存，设置缓存有效期为1小时requests_cache.install_cache(&#39;wechat_cache&#39;, expire_after&#x3D;3600)# 配置速率限制limiter &#x3D; Limiter(    get_remote_address,    app&#x3D;app,    default_limits&#x3D;[&quot;200 per day&quot;, &quot;20 per minute&quot;])def get_access_token(corp_id, corp_secret):    &quot;&quot;&quot;获取token&quot;&quot;&quot;    url &#x3D; f&quot;https:&#x2F;&#x2F;qyapi.weixin.qq.com&#x2F;cgi-bin&#x2F;gettoken?corpid&#x3D;&#123;corp_id&#125;&amp;corpsecret&#x3D;&#123;corp_secret&#125;&quot;    response &#x3D; requests.get(url)    data &#x3D; response.json()    if data[&#39;errcode&#39;] &#x3D;&#x3D; 0:        return data[&#39;access_token&#39;]    else:        raise Exception(f&quot;获取access_token失败: &#123;data[&#39;errmsg&#39;]&#125;&quot;)@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;])@limiter.limit(&quot;3 per 5 seconds&quot;, error_message&#x3D;&quot;您的请求频率过高，请稍后再试。&quot;)  # 添加速率限制def send():    corp_id &#x3D; &quot;xxxxxxxxx&quot;  # 替换为你的企业ID    corp_secret &#x3D; &quot;xxxxxxxxx&quot;  # 替换为你的应用Secret    agent_id &#x3D; &quot;xxxxxxxxx&quot;  # 替换为你的应用AgentId    to_user &#x3D; &quot;xxxxxxxxx|xxxxxxxxx&quot;  # 替换为接收者的UserID，多个用 &#39;|&#39; 分隔    title &#x3D; request.args.get(&#39;title&#39;)    content &#x3D; request.args.get(&#39;content&#39;)    if not title or not content:        return jsonify(&#123;&quot;error&quot;: &quot;title 和 content 参数是必须的&quot;&#125;), 400    try:        # 从缓存中获取access_token        access_token &#x3D; get_access_token(corp_id, corp_secret)    except Exception as e:        return jsonify(&#123;&quot;error&quot;: f&quot;获取access_token时发生错误: &#123;str(e)&#125;&quot;&#125;), 500    try:        response &#x3D; send_message(access_token, agent_id, to_user, title, content)    except Exception as e:        return jsonify(&#123;&quot;error&quot;: f&quot;发送消息时发生错误: &#123;str(e)&#125;&quot;&#125;), 500    # return jsonify(response)    return &quot;ok&quot;def send_message(access_token, agent_id, to_user, title, content):    &quot;&quot;&quot;消息发送&quot;&quot;&quot;    url &#x3D; f&quot;https:&#x2F;&#x2F;qyapi.weixin.qq.com&#x2F;cgi-bin&#x2F;message&#x2F;send?access_token&#x3D;&#123;access_token&#125;&quot;    payload &#x3D; &#123;        &quot;touser&quot;: to_user,  # 接收消息的成员ID列表，多个用 &#39;|&#39; 分隔        &quot;msgtype&quot;: &quot;text&quot;,        &quot;agentid&quot;: agent_id,        &quot;text&quot;: &#123;            &quot;content&quot;: f&quot;&#123;title&#125;\n&#123;content&#125;&quot;        &#125;,        &quot;safe&quot;: 0    &#125;    headers &#x3D; &#123;        &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;    &#125;    response &#x3D; requests.post(url, headers&#x3D;headers, data&#x3D;json.dumps(payload))    response_data &#x3D; response.json()    if response_data[&#39;errcode&#39;] !&#x3D; 0:        raise Exception(f&quot;发送消息失败: &#123;response_data[&#39;errmsg&#39;]&#125;&quot;)    return response_dataif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    app.run(host&#x3D;&#39;0.0.0.0&#39;, port&#x3D;5001, debug&#x3D;False)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Api测试</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http:&#x2F;&#x2F;localhost:5000&#x2F;?title&#x3D;呜呼&amp;content&#x3D;啊哈<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="微信同步"><a href="#微信同步" class="headerlink" title="微信同步"></a>微信同步</h2><p>企业微信的通知消息不会同步到微信怎么办</p><p>在<strong>web管理后台-我的企业-微信插件</strong>中，可获取“邀请关注微信插件”的二维码。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://developer.work.weixin.qq.com/document/path/90665#14953">企业微信开发者文档</a></p><p><a href="https://work.weixin.qq.com/wework_admin/frame#apps/modApiApp/5629501444574894">企业微信 (qq.com)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TG消息转发机器人</title>
      <link href="/2024/07/14/111-tg-xiao-xi-zhuan-fa-ji-qi-ren/"/>
      <url>/2024/07/14/111-tg-xiao-xi-zhuan-fa-ji-qi-ren/</url>
      
        <content type="html"><![CDATA[<h2 id="通过CF-Workers"><a href="#通过CF-Workers" class="headerlink" title="通过CF Workers"></a>通过CF Workers</h2><p>但是不好使不知道为什么</p><blockquote><p>可能是某个步骤出现问题，删除重复一遍就好了</p></blockquote><p>重弄了一个就好了[Bot](<a href="https://t.me/KittyTech_bot">Telegram: Contact @KittyTech_bot</a>)</p><p><a href="https://www.nodeseek.com/post-31988-1">酒神识别骗子BOT部署教程 (nodeseek.com)</a></p><h2 id="LivegramBot"><a href="#LivegramBot" class="headerlink" title="LivegramBot"></a>LivegramBot</h2><ul><li>@<a href="https://t.me/botfather">BotFather</a></li><li>@<a href="https://t.me/LivegramBot">LivegramBot</a></li></ul><p>通过<em>BotFather</em>创建bot，并获取<em>token</em>，发送给<em>LivegramBot</em>，&#x2F;start后就可以了，不好的地方是我回复的信息回再显示一遍</p><p>如何回复信息</p><blockquote><p>选中然后Reply</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NRF24L01无线通信模块</title>
      <link href="/2024/05/30/110-nrf24l01-wu-xian-tong-xin-mo-kuai/"/>
      <url>/2024/05/30/110-nrf24l01-wu-xian-tong-xin-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h2 id="SPI通信协议"><a href="#SPI通信协议" class="headerlink" title="SPI通信协议"></a>SPI通信协议</h2><p>同步:同步通信要求接收端时钟频率和发送端时钟频率一致，发送端发送连续的比特流；没有数据发送的时候,发送空字符,数据帧之间不能有间隙</p><p>异步:可以间隔任意时间发送数据,由于开始位和停止位,所以传输效率较低</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>蓝牙模块</title>
      <link href="/2024/04/18/109-lan-ya-mo-kuai/"/>
      <url>/2024/04/18/109-lan-ya-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h2 id="HC-05"><a href="#HC-05" class="headerlink" title="HC-05"></a>HC-05</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>接<code>USB TO TTL</code></p><p>进入命令响应工作模式有两种方法：</p><ul><li>未配对情况下，模块上电就是AT模式，波特率为模块本身的波特率，默认：9600，发送一次AT指令时需要置高一次PIO11；</li><li>配对后调试，PIO11 置高电平后，再给模块上电，此时模块进入AT 模式，波特率固定为：38400，可以直接发送AT指令。</li></ul><p>发送<code>AT</code>,响应OK,然后<code>AT+UART:115200,0,0</code>设置波特率为115200,0停止位，0校验位</p><h3 id="AT指令"><a href="#AT指令" class="headerlink" title="AT指令"></a>AT指令</h3><p>比如我要查看模块的版本：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">串口发送：AT+VERSION?\r\n模块回应：+VERSION:2.0-20100601<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">AT+NAME &#x3D; xlg 设置蓝牙名称为xlgAT+ROLE&#x3D;0     蓝牙模式为从模式 AT+ROLE&#x3D;1 蓝牙模式为主模式AT+CMODE&#x3D;0    蓝牙连接模式为任意地址连接模式AT+PSWD&#x3D;1234  蓝牙配对密码为1234AT+UART&#x3D;9600，0，0 蓝牙通信串口波特率为9600，停止位1位，无校验位AT+RMAAD           清空配对列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AT+NAME?：获得设备名称，这个AT指令有很大可能性是没有返回的，因为我也看到了很多的例子……，但是其他的指令都是没有问题的，直接设置设备名称就行了；</p><p>不常用指令</p><pre class="line-numbers language-none"><code class="language-none">2.AT+RESET:HC-05复位3. AT+VERSION?：获取HC-05的软件版本号，只能获取，不能修改。4. AT+ORGL:恢复出厂默认设置，当把模块设置乱了，使用此命令进行恢复默认值。5. AT+ADDR?：获取HC-05的蓝牙地址码，只能获取，不能修改。6. AT+NAME？:获取HC-05的名字,AT+NAME&#x3D;xlg，修改模块的名字为xlg，具体名字自行修改。7. AT+CLASS?：设置查询设备的类型，尽量不要去修改此参数。默认是1F00。8. AT+IAC?：查询设置查询访问码，默认是9E8B33，尽量不要去修改此参数。9. AT+PSWD？:查询设置配对密码,AT+PSWD&#x3D;”0000”,密码要有双引号,密码是四位数字.10. AT+UART：AT+UART？是查询当前模块的波特率，AT+UART&#x3D;波特率,0,0。11. AT+CMODE：AT+CMODE？是查询当前连接模式。AT+CMODE&#x3D;0，1，2(0——指定蓝牙地址连接模式（指定蓝牙地址由绑定指令设置）1——任意蓝牙地址连接模式（不受绑定指令设置地址的约束）2——回环角色（Slave-Loop）默认连接模式：0)。12. AT+BIND:AT+BIND?查询当前绑定地址,AT+BIND&#x3D;NAP，UAP，LAP(用逗号隔开)。13. AT+RMADD:从蓝牙配对列表中删除所有认证设备.14. AT+STATE？:获取蓝牙模块工作状态.15. AT+LINK&#x3D;NAP,UAP,LAP：与远程设备建立连接。17. AT+RNAME？NAP，UAP，LAP:获取远程蓝牙设备名称.18. AT+ADCN?：获取蓝牙配对列表中认证设备数。19. AT+MRAD？获取最近使用过的蓝牙认证设备地址。20. AT+INQM:设置查询模式,AT+INQM&#x3D;1，9，48(1-带RSSI信号强度指示,9-超过9个蓝牙设备响应则终止查询,48-设定超时为48*1.28&#x3D;61.44秒)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HC-06"><a href="#HC-06" class="headerlink" title="HC-06"></a>HC-06</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>蓝牙模块上有一个LED，LED 指示蓝牙连接状态， 闪烁表示没有蓝牙连接，常亮表示蓝牙已连接并打开了端口</p><h3 id="AT指令-1"><a href="#AT指令-1" class="headerlink" title="AT指令"></a>AT指令</h3><blockquote><p>在未建立蓝牙连接时支持通过 AT 指令设置波特率、名称、配对密码， 设置的参数掉电保存</p></blockquote><p>默认的时候波特率为 ：9600<br>配对密码： 1234</p><p>(1)测试通讯<br>发送： AT（返回 OK，一秒左右发一次）<br>返回： OK</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">(1)改蓝牙串口通讯波特率发送： AT+BAUD1返回： +BAUD&#x3D;1此时波特率为 1200发送： AT+BAUD2返回： +BAUD&#x3D;2此时波特率为 2400(2)改蓝牙名称发送： AT+NAMEname返回： OK参数 name：所要设置的当前名称，即蓝牙被搜索到的名称。 20 个字符以内。发送 AT+NAME123返回+NAME&#x3D;123这时蓝牙名称改为 123(3)改蓝牙配对密码发送： AT+PINxxxx返回： +PIN&#x3D;xxxx参数 xxxx：所要设置的配对密码， 4 个字节，此命令可用于从机或主机。从机则是适配器或手机弹出要求输入配对密码窗口时，则手工输入此参数就可以连接从机。主机则是在用主蓝牙模块连数码相机时，数码相机是从机，找到相机的配对密码，再设入主蓝牙模块，则主蓝牙模块就可以自动连接相机。例：发送 AT+PIN8888返回+PIN&#x3D;8888(4)更改模块的主从模式（V1.7 版本以后支持）发送： AT+ROLE&#x3D;1（设置模块为主模式 Master）返回： +ROLE&#x3D;1发送： AT+ROLE&#x3D;0（设置模块为从模式 Slave）返回： +ROLE&#x3D;0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="电脑连接蓝牙模块"><a href="#电脑连接蓝牙模块" class="headerlink" title="电脑连接蓝牙模块"></a>电脑连接蓝牙模块</h2><p><a href="https://so.csdn.net/so/search?q=%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97&spm=1001.2101.3001.7020">蓝牙模块</a>HC05支持SPP协议，使用PC机自带蓝牙（或者蓝牙适配器）与HC05连接后，可在电脑端虚拟出串口，这样上位机软件就可以像操作串口一样与HC05通信。</p><img src="/2024/04/18/109-lan-ya-mo-kuai/image-20240418150252453.png" class="" title="image-20240418150252453"><img src="/2024/04/18/109-lan-ya-mo-kuai/image-20240418150309451.png" class="" title="image-20240418150309451">## <p>串口软件软件连接COM23就可以实现无线串口功能了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://shequ.stmicroelectronics.cn/thread-627049-1-1.html">HC-05蓝牙串口通信模块使用详解（手机蓝牙控制STM32单片机） (stmicroelectronics.cn)</a></p><p><a href="https://blog.csdn.net/lisgsheng/article/details/131690150?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-131690150-blog-121734788.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-131690150-blog-121734788.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=4">HC05模块与笔记本蓝牙连接_hc-05 电脑-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Python的上位机平台</title>
      <link href="/2024/04/11/108-ji-yu-python-de-shang-wei-ji-ping-tai/"/>
      <url>/2024/04/11/108-ji-yu-python-de-shang-wei-ji-ping-tai/</url>
      
        <content type="html"><![CDATA[<h1 id="上位机"><a href="#上位机" class="headerlink" title="上位机"></a>上位机</h1><h2 id="PYQT5"><a href="#PYQT5" class="headerlink" title="PYQT5"></a>PYQT5</h2><p><a href="https://pythonspot.com/pyqt5/">PyQT5 - Python 教程 (pythonspot.com)</a></p><h2 id="tkinter"><a href="#tkinter" class="headerlink" title="tkinter"></a>tkinter</h2><p>我的建议是先用tkinter实现功能, 美观就再说吧, 节省时间要紧, 凡事有个轻重缓急</p><p>Error running ‘QtDisigner’: Cannot start process, the working directory ‘E:\400_Pycharm\000_Project\program’ does not exis</p><blockquote><p>mkdir “E:\400_Pycharm\000_Project\program”</p></blockquote><img src="/2024/04/11/108-ji-yu-python-de-shang-wei-ji-ping-tai/image-20240413072346514.png" class="" title="image-20240413072346514"><img src="/2024/04/11/108-ji-yu-python-de-shang-wei-ji-ping-tai/image-20240413072418715.png" class="" title="image-20240413072418715"><h2 id="窗口自适应"><a href="#窗口自适应" class="headerlink" title="窗口自适应"></a>窗口自适应</h2><p>选了grid格式就无法改变按钮的形状大小了</p><p>从小到大, 最后设置主窗口的布局格式, 这样就能实现窗口自适应了</p><h3 id="1-设置按钮大小和样式"><a href="#1-设置按钮大小和样式" class="headerlink" title="1. 设置按钮大小和样式"></a>1. 设置按钮大小和样式</h3><p>如果你想在Qt Designer中设置按钮的最小或最大尺寸，或者应用CSS样式，可以按照以下步骤操作：</p><ul><li><strong>打开Qt Designer</strong> 并加载你的<code>.ui</code>文件。</li><li><strong>选择按钮</strong>：在设计视图中，点击你想要修改的按钮。</li><li>设置属性<ul><li>在右侧的<strong>属性编辑器</strong>中，找到<code>minimumSize</code>和<code>maximumSize</code>属性，输入你希望的尺寸值。</li><li>要设置样式（CSS），找到<code>styleSheet</code>属性，点击其右侧的小按钮（…），这将打开一个编辑器窗口，在其中你可以输入CSS样式。</li></ul></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>窗口闪退</p><p>某些地方报错,使用try except优化</p></li><li><p>接收多条</p><p>定时器间隔太长, 读取模式为行读取</p><p>间隔太长容易接收两份数据显示</p></li><li><p>不能接受中文</p><blockquote><p>可能是因为解码使用utf_8的格式, 换成GBK格式</p><p>**data &#x3D; self.serial.read_all().decode(‘gbk’).strip() **</p><h3 id="常见的编码格式"><a href="#常见的编码格式" class="headerlink" title="常见的编码格式"></a><strong>常见的编码格式</strong></h3><ul><li><strong>UTF-8</strong>：是一种广泛使用的可变长度字符编码系统，它能表示任何现存的字符，是网络上的标准。</li><li><strong>GBK</strong>：是用于简化字中文的扩展编码，比GB2312覆盖更多的中文字符。</li><li><strong>GB2312</strong>：是较早的简体中文字符集标准，包含6763个汉字。</li><li><strong>GB18030</strong>：是中国的现行国家标准，它兼容GBK和GB2312，支持从单字节的ASCII到四字节的复杂字符。</li></ul></blockquote></li><li><p>异常处理很重要</p><blockquote><p>当出现程序自动停止但是没有报错时,可以通过是指异常处理找到报错</p></blockquote></li></ol><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>这种调库的写法, 像是在看说明书</p><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><p>图标</p><img src="/2024/04/11/108-ji-yu-python-de-shang-wei-ji-ping-tai/image-20240604222739540.png" class="" title="image-20240604222739540"><p>按钮风格</p><img src="/2024/04/11/108-ji-yu-python-de-shang-wei-ji-ping-tai/image-20240604222757132.png" class="" title="image-20240604222757132"><p>样式表用CSS改变形状</p><p><strong>限制最小值</strong></p><h2 id="widget"><a href="#widget" class="headerlink" title="widget"></a>widget</h2><p>容器布局</p><h2 id="按钮按下和弹"><a href="#按钮按下和弹" class="headerlink" title="按钮按下和弹"></a>按钮按下和弹</h2><p>在 PyQt 的样式表中，伪状态选择器用于定义控件在特定状态下的外观。以下是一些常用的伪状态选择器：</p><ul><li><code>QPushButton:hover</code>：定义鼠标悬停在按钮上时的外观。</li><li><code>QPushButton:pressed</code>：定义按钮被按下时的外观。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 在这里可以添加信号槽连接和其他初始化代码       self.apply_styles()       self.pushButton_start.clicked.connect(self.handle_start_button)       self.pushButton_a.clicked.connect(self.handle_button_a)       self.pushButton_b.clicked.connect(self.handle_button_b)       self.pushButton_forward.clicked.connect(self.handle_forward_button)       self.pushButton_backward.clicked.connect(self.handle_backward_button)       self.pushButton_left.clicked.connect(self.handle_left_button)       self.pushButton_right.clicked.connect(self.handle_right_button)       self.pushButton_stop.clicked.connect(self.handle_stop_button)   def apply_styles(self):       # 设置按钮样式表，添加按压效果       button_style &#x3D; &quot;&quot;&quot;       QPushButton &#123;           border: 1px solid black;           border-radius: 10px;           background-color: #82A6FF;           min-width: 80px;           min-height: 40px;           font: bold 14px;           color: white;       &#125;       # 按压在后面才能生效         QPushButton:hover &#123;           background-color: #9BBFFF;       &#125;       QPushButton:pressed &#123;           background-color:#000000;       &#125;       &quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>布局约束了按钮的大小，如何解决</p><p><strong>暂时未验证</strong></p><ol><li><strong>取消网格布局</strong>：<ul><li>使用垂直和水平布局来排列按钮，确保按钮和图标大小一致，并使布局整洁。</li></ul></li><li><strong>调整按钮和图标的大小</strong>：<ul><li>在 <code>setup_button</code> 方法中，设置按钮的大小策略为 <code>QtWidgets.QSizePolicy.Expanding</code>，并设置按钮和图标的最小和最大尺寸，使它们完全重合。</li></ul></li><li><strong>使用垂直和水平布局排列按钮</strong>：<ul><li>将上方向按钮和下方向按钮放在垂直布局中，并将左右方向按钮和停止按钮放在水平布局中，确保布局整齐。</li></ul></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">self.pushButton_start.clicked.connect(self.open_serial_port) 这行代码的功能是将 self.pushButton_start 按钮的点击事件与 self.open_serial_port 方法连接起来。也就是说，当用户点击 self.pushButton_start 按钮时，会自动调用 self.open_serial_port 方法。详细讲解：self.pushButton_start:self.pushButton_start 是一个 QPushButton 对象，表示用户界面中的一个按钮。clicked 信号:在 PyQt 中，每个按钮（QPushButton）都有许多信号，其中一个最常用的信号是 clicked。当用户点击按钮时，这个信号会被触发。connect 方法:connect 方法用于将信号与槽（slot）连接起来。槽是一个可以被调用的函数或方法，当信号触发时，槽会被调用。在这种情况下，connect 方法将 clicked 信号与 self.open_serial_port 方法连接。self.open_serial_port 方法:self.open_serial_port 是在类中定义的一个方法。这个方法的作用是打开选定的串口。工作流程：当用户点击 self.pushButton_start 按钮时，self.pushButton_start 对象会发出 clicked 信号。由于 clicked 信号已经通过 connect 方法与 self.open_serial_port 方法连接，因此 self.open_serial_port 方法会被自动调用。self.open_serial_port 方法会执行相关代码，尝试打开用户在 comboBox 中选择的串口，并进行初始化设置。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="由小到大"><a href="#由小到大" class="headerlink" title="由小到大"></a>由小到大</h2><p>思维导图及时写，定期复习所学</p><p>温故而知新</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">UI界面设计程序如下：from PyQt5 import QtWidgets             #导入模块     from THREE import Ui_MainWindow  Class MainApp(QtWidgets.QMainWindow, Ui_MainWindow):​    def __init__(self):  ​    #  这是类的初始化方法，当创建 MainApp 类的实例时会自动调用该方法。​    # self 是对类实例自身的引用，用于访问实例的属性和方法。  super(MainApp, self).__init__()​    # 调用了父类（QtWidgets.QMainWindow 和 Ui_MainWindow）的初始化方法。​    # super() 函数用于调用父类的方法，确保父类中的初始化代码在子类中也能正确执行。通过调用父类的初始化方法，MainApp 类继承了 QtWidgets.QMainWindow 和 Ui_MainWindow 类的所有属性和方法。​    self.setupUi(self)·  调用了 Ui_MainWindow 类中的 setupUi 方法，并传递了当前类的实例 self 作为参数。· setupUi 方法用于设置和初始化用户界面，配置窗口的布局、组件以及信号槽连接。· 通过调用 setupUi 方法，MainApp 类实例会根据 Ui_MainWindow 中定义的布局和组件初始化界面。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="try-except"><a href="#try-except" class="headerlink" title="try except"></a>try except</h2><p>可以防止程序自动退出，不显示报错</p><h2 id="label切换图片模仿led"><a href="#label切换图片模仿led" class="headerlink" title="label切换图片模仿led"></a>label切换图片模仿led</h2><h2 id="思考功能"><a href="#思考功能" class="headerlink" title="思考功能"></a>思考功能</h2><img src="/2024/04/11/108-ji-yu-python-de-shang-wei-ji-ping-tai/image-20240608212622365.png" class="" title="image-20240608212622365"><h2 id="超声波"><a href="#超声波" class="headerlink" title="超声波"></a>超声波</h2><ul><li>Pyinstaller -F py_word.py 打包exe</li><li></li><li>Pyinstaller -F -w py_word.py 不带控制台的打包</li><li></li><li>Pyinstaller -F -w -i chengzi.ico py_word.py 打包指定exe图标打包</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.byhy.net/py/qt/qt_03/">界面设计和布局 - 白月黑羽 (byhy.net)</a></p><h1 id="ONECOM"><a href="#ONECOM" class="headerlink" title="ONECOM"></a>ONECOM</h1><h2 id="PYQT6环境搭建"><a href="#PYQT6环境搭建" class="headerlink" title="PYQT6环境搭建"></a>PYQT6环境搭建</h2><ul><li><p>安装<a href="https://www.python.org/downloads/windows/">python3.11</a></p></li><li><p>pip install PyQt6 pyqt6-tools</p></li><li><p>注意：PyQt6到2025&#x2F;9&#x2F;14只支持到<code>python3.11</code>，使用高版本会遇到各种问题</p><p>（<a href="https://www.bilibili.com/opus/884262852306665529">参考Python3.12环境下PyQt6的安装</a>）</p></li><li><p>创建external tools</p></li></ul><p>布局在缩放时会出现“遮挡”</p><hr><h3 id="第一部分：解决布局“遮挡”而不是“缩放”的问题"><a href="#第一部分：解决布局“遮挡”而不是“缩放”的问题" class="headerlink" title="## 第一部分：解决布局“遮挡”而不是“缩放”的问题"></a>## 第一部分：解决布局“遮挡”而不是“缩放”的问题</h3><p>你描述的“推拉时出现遮挡而不是等比放大缩小”的现象，是 PyQt&#x2F;Qt 布局中一个非常核心且常见的问题。</p><h4 id="问题根源：最小尺寸（minimumSize）与尺寸策略（sizePolicy）的冲突"><a href="#问题根源：最小尺寸（minimumSize）与尺寸策略（sizePolicy）的冲突" class="headerlink" title="问题根源：最小尺寸（minimumSize）与尺寸策略（sizePolicy）的冲突"></a><strong>问题根源：最小尺寸（minimumSize）与尺寸策略（sizePolicy）的冲突</strong></h4><p>当你在缩小窗口时，布局管理器会尝试按比例缩小它内部的每一个控件。但每个控件都有一个“尊严”——它有一个<strong>最小尺寸（<code>minimumSize</code>）</strong>，它告诉布局管理器：“你不能把我变得比这个尺寸更小了！”</p><p>当窗口被缩得太小，布局管理器分配给某个控件的空间，已经小于该控件所允许的最小尺寸时，冲突就发生了。布局管理器别无选择，只能开始<strong>裁剪</strong>或<strong>重叠</strong>控件，这就是你看到的“遮挡”现象。</p><p>####控制尺寸的关键属性</p><p>为了彻底理解并解决这个问题，你需要了解 Qt Designer 中控制尺寸的几个关键属性。当你选中任何一个控件时，都可以在右侧的属性编辑器中找到它们：</p><ol><li><p><strong><code>sizePolicy</code> (尺寸策略)</strong> - <strong>最重要的属性</strong> 这是控件的“行为宣言”，它告诉布局管理器，当有额外空间或空间不足时，它该如何表现。它分为水平（Horizontal）和垂直（Vertical）策略。</p><ul><li><p><strong><code>Fixed</code></strong>：尺寸固定，等于 <code>sizeHint</code>（建议尺寸），既不能拉伸也不能压缩。</p></li><li><p><strong><code>Minimum</code></strong>：可以被拉伸，但不能被压缩得比 <code>sizeHint</code> 更小。</p></li><li><p><strong><code>Maximum</code></strong>：可以被压缩，但不能被拉伸得比 <code>sizeHint</code> 更大。</p></li><li><p><strong><code>Preferred</code></strong>：（默认值）可以被拉伸也可以被压缩，但它“希望”保持在 <code>sizeHint</code> 大小。</p></li><li><p><strong><code>Expanding</code></strong>：和 <code>Preferred</code> 类似，但它有强烈的“欲望”去占据所有多余的空间。像文本编辑器、列表视图这类控件默认就是这个策略。</p></li><li><p><code>horizontalStretch</code> &#x2F; <code>verticalStretch</code> (拉伸因子)：我们之前讨论过，用于分配多余空间的<strong>比例</strong>。</p></li></ul></li><li><p><strong><code>minimumSize</code> (最小尺寸)</strong> - <strong>问题的直接原因</strong> 这是一个<strong>硬性限制</strong>。你在这里设置的宽度和高度，是这个控件能被压缩到的绝对下限。<strong>很多“遮挡”问题都是因为这里被无意中设置了一个较大的值。</strong></p></li><li><p><strong><code>maximumSize</code> (最大尺寸)</strong> 与 <code>minimumSize</code> 相反，这是控件能被拉伸到的绝对上限。</p></li><li><p><strong><code>sizeHint</code> (建议尺寸)</strong> 这是控件根据自身内容（比如按钮上的文字长度）计算出的“最理想”的尺寸。<code>sizePolicy</code> 中的很多策略都依赖于这个值。</p></li></ol><h4 id="如何设置以避免遮挡？"><a href="#如何设置以避免遮挡？" class="headerlink" title="如何设置以避免遮挡？"></a><strong>如何设置以避免遮挡？</strong></h4><ol><li><p><strong>检查并重置 <code>minimumSize</code></strong>：</p><ul><li><p>在 Qt Designer 中，选中那个被遮挡的控件（或者它的父容器）。</p></li><li><p>在属性编辑器中找到 <code>minimumSize</code> 属性。</p></li><li><p>检查它的 <code>width</code> 和 <code>height</code> 是否被设置了一个非零的值。<strong>尝试将它们都改回 <code>0</code></strong>。<code>0</code>意味着“没有最小尺寸限制”。</p></li></ul></li><li><p><strong>为整个主窗口设置一个最小尺寸</strong>：</p><ul><li><p>这是一个非常实用且推荐的做法。一个复杂的界面不可能被无限缩小。</p></li><li><p>在 Qt Designer 中，点击主窗口的空白处，然后在属性编辑器中找到 <code>minimumSize</code>。</p></li><li><p>设置一个你认为合理的最小宽度和高度，比如 <code>800</code> x <code>600</code>。这样，用户就无法将窗口缩小到会破坏布局的程度，从根本上避免了“遮挡”问题。</p></li></ul></li><li><p><strong>合理使用 <code>sizePolicy</code></strong>：</p><ul><li><p>确保那些需要灵活缩放的控件（如文本框）的 <code>sizePolicy</code> 设置为 <code>Expanding</code>。</p></li><li><p>确保那些尺寸应该保持紧凑的控件（如按钮）的 <code>sizePolicy</code> 设置为 <code>Preferred</code> 或 <code>Fixed</code>。</p></li></ul></li><li><p><strong>使用 <code>QScrollArea</code> (滚动区域)</strong>：</p><ul><li><p>如果你的右侧功能区内容确实很多，无法在小尺寸下完全显示，最好的解决方案是：</p></li><li><p>在 Qt Designer 中，先拖入一个 <code>QScrollArea</code> 控件。</p></li><li><p>然后把你整个右侧功能区的所有控件都<strong>放进</strong>这个 <code>QScrollArea</code> 中。</p></li><li><p>这样，当窗口缩小时，如果内容显示不下，<code>QScrollArea</code> 会自动出现滚动条，从而保证内部的控件永远不会被“遮挡”。</p></li></ul></li></ol><h3 id="设置窗口比例"><a href="#设置窗口比例" class="headerlink" title="设置窗口比例"></a>设置窗口比例</h3><p>调整 <code>verstretch</code> 因子，让发送区占用更少空间</p><p><strong>注意</strong></p><p>布局不要太多</p>]]></content>
      
      
      
        <tags>
            
            <tag> PyQt6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Max30102模块</title>
      <link href="/2024/04/09/107-max30102-mo-kuai/"/>
      <url>/2024/04/09/107-max30102-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*MAX30102寄存器地址宏定义*&#x2F;#define max30100_WR_address 0xAE#define MAX30102_Device_address max30100_WR_address#define I2C_WR0&#x2F;* 写控制bit *&#x2F;#define I2C_RD1&#x2F;* 读控制bit *&#x2F;#define REG_INTR_STATUS_1 0x00#define REG_INTR_STATUS_2 0x01#define REG_INTR_ENABLE_1 0x02#define REG_INTR_ENABLE_2 0x03#define REG_FIFO_WR_PTR 0x04#define REG_OVF_COUNTER 0x05#define REG_FIFO_RD_PTR 0x06#define REG_FIFO_DATA 0x07#define REG_FIFO_CONFIG 0x08#define REG_MODE_CONFIG 0x09#define REG_SPO2_CONFIG 0x0A#define REG_LED1_PA 0x0C#define REG_LED2_PA 0x0D#define REG_PILOT_PA 0x10#define REG_MULTI_LED_CTRL1 0x11#define REG_MULTI_LED_CTRL2 0x12#define REG_TEMP_INTR 0x1F#define REG_TEMP_FRAC 0x20#define REG_TEMP_CONFIG 0x21#define REG_PROX_INT_THRESH 0x30#define REG_REV_ID 0xFE#define REG_PART_ID 0xFF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="读取寄存器的数据"><a href="#读取寄存器的数据" class="headerlink" title="读取寄存器的数据"></a>读取寄存器的数据</h2><p>读哪个寄存器</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">FIFO_DATA 0x07<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在使用MAX30102的FIFO时，通常不需要你直接操作FIFO读指针（FIFO_RD_PTR）。FIFO读指针的自动递增是MAX30102内部机制的一部分，旨在简化从FIFO中连续读取数据的过程。</p><p>当你从FIFO_DATA寄存器读取数据时，MAX30102内部的FIFO读指针会自动向前移动到下一个位置，准备下一次读取。这意味着每次读取操作后，FIFO_RD_PTR都会自动更新，指向FIFO中的下一个待读取数据，而无需手动干预。</p><p>如果你需要从FIFO的特定位置开始读取数据，或者需要重置FIFO到已知状态，你可以通过写入FIFO读指针、写指针和溢出计数器寄存器来实现。通常，在初始化MAX30102或准备新的数据采集会话之前，会将这些指针寄存器重置为零：</p><p><strong>怎么读</strong></p><blockquote><p>FIFO Data RegisterThe circular FIFO depth is 32 and can hold up to 32 samples of data. The sample size depends on the number of LED channels (a.k.a. channels) configured as active. As each channel signal is stored as a 3-byte data signal, the FIFO width can be 3 bytes or 6 bytes in size.The FIFO_DATA register in the I2C register map points to the next sample to be read from the FIFO. FIFO_RD_PTR points to this sample. Reading FIFO_DATA register, does not automatically increment the I2C register address. Burst reading this register, reads the same address over and over. Each sample is 3 bytes of data per channel (i.e., 3 bytes for RED, 3 bytes for IR, etc.).The FIFO registers (0x04–0x07) can all be written and read, but in practice only the FIFO_RD_PTR register should be written to in operation. The others are automatically incremented or filled with data by the MAX30102. When starting a new SpO2 or heart rate conversion, it is recommended to first clear the FIFO_WR_PTR, OVF_COUNTER, and FIFO_RD_PTR registers to all zeroes (0x00) to ensure the FIFO is empty and in a known state. When reading the MAX30102 registers in one burst-read I2C transaction, the register address pointer typically increments so that the next byte of data sent is from the next register, etc. The exception to this is the FIFO data register, register 0x07. When reading this register, the address pointer does not increment, but the FIFO_RD_PTR does. So the next byte of data sent represents the next byte of data available in the FIFO.Reading from the FIFONormally, reading registers from the I2C interface autoincrements the register address pointer, so that all the registers can be read in a burst read without an I2C start event. In the MAX30102, this holds true for all registers except for the FIFO_DATA register (register 0x07).Reading the FIFO_DATA register does not automatically increment the register address. Burst reading this register reads data from the same address over and over. Each sample comprises multiple bytes of data, so multiple bytes should be read from this register (in the same transaction) to get one full sample.The other exception is 0xFF. Reading more bytes after the 0xFF register does not advance the address pointer back to 0x00, and the data read is not meaningful.FIFO Data StructureThe data FIFO consists of a 32-sample memory bank that can store IR and Red ADC data. Since each sample consists of two channels of data, there are 6 bytes of data for each sample, and therefore 192 total bytes of data can be stored in the FIFO.The FIFO data is left-justified as shown in Table 1; in other words, the MSB bit is always in the bit 17 data position regardless of ADC resolution setting. See Table 2 for a visual presentation of the FIFO data structure  </p></blockquote><img src="/2024/04/09/107-max30102-mo-kuai/image-20240410214224496.png" class="" title="image-20240410214224496"><p><strong>为什么读6次</strong></p><p>因为每个采样有两个数据通道,和六个字节</p><blockquote><p>The data FIFO consists of a 32-sample memory bank that can store IR and Red ADC data. Since each sample consists of <strong>two channels</strong> of data, there are <strong>6 bytes of data for each sample</strong></p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><strong>不是说地址不会自增吗,为什么可以重复读六次</strong></li></ol><blockquote><p>寄存器时地址不会自增，指的是单独对FIFO_DATA寄存器的读取操作不会导致I2C内部寄存器地址的自动递增，这意味着如果你反复发出读取指令，而不重新指定地址，你将会连续读到同一个寄存器的数据。</p></blockquote><blockquote><p>在你提供的代码示例中，通过一次I2C开始信号和设备地址（包含读位）的发送后，连续读取6个字节的数据实际上是在连续读取FIFO_DATA寄存器的当前内容6次。<strong>由于FIFO_RD_PTR（FIFO读指针）会在每次从FIFO_DATA寄存器读取数据后自动递增，所以每次读取操作实际上都会获取到FIFO中的下一个数据样本，即使寄存器地址没有改变</strong>。</p></blockquote><ol start="2"><li><p><strong>不太理解FIFO_RD_PTR与FIFO_DATA的关系</strong></p><p>FIFO读指针的自动递增是MAX30102内部机制的一部分，旨在简化从FIFO中连续读取数据的过程。</p><p>当你从FIFO_DATA寄存器读取数据时，MAX30102内部的FIFO读指针会自动向前移动到下一个位置，准备下一次读取。这意味着每次读取操作后，FIFO_RD_PTR都会自动更新，指向FIFO中的下一个待读取数据，而无需手动干预。</p>   <pre class="line-numbers language-c" data-language="c"><code class="language-c">void MAX30102_IIC_ReadReg(uint8_t slave_ID,uint8_t RegAddress)  &#x2F;&#x2F;读取6个字节&#123;    fifo_red&#x3D;0;    fifo_ir&#x3D;0;uint16_t Data1,Data2,Data3,Data4,Data5,Data6;IIC_Start();&#x2F;&#x2F;I2C起始IIC_SendByte(slave_ID);&#x2F;&#x2F;发送从机地址，读写位为0，表示即将写入IIC_ReceiveAck();&#x2F;&#x2F;接收应答IIC_SendByte(RegAddress);&#x2F;&#x2F;发送寄存器地址IIC_ReceiveAck();&#x2F;&#x2F;接收应答IIC_Start();&#x2F;&#x2F;I2C重复起始IIC_SendByte(slave_ID | 0x01);&#x2F;&#x2F;发送从机地址，读写位为1，表示即将读取IIC_ReceiveAck();&#x2F;&#x2F;接收应答Data1 &#x3D; IIC_ReceiveByte();&#x2F;&#x2F;接收指定寄存器的数据IIC_SendAck(0);&#x2F;&#x2F;发送应答，给从机非应答，终止从机的数据输出Data2 &#x3D; IIC_ReceiveByte();IIC_SendAck(0);Data3 &#x3D; IIC_ReceiveByte();IIC_SendAck(0);Data4 &#x3D; IIC_ReceiveByte();&#x2F;&#x2F;接收指定寄存器的数据IIC_SendAck(0);&#x2F;&#x2F;发送应答，给从机非应答，终止从机的数据输出Data5 &#x3D; IIC_ReceiveByte();IIC_SendAck(0);Data6 &#x3D; IIC_ReceiveByte();IIC_SendAck(1);IIC_Stop();&#x2F;&#x2F;I2C终止    &#x2F;&#x2F;将读取的6个字节数据通过位移操作重组成两个18位的数据，分别代表红光和红外光通Data1 &lt;&lt;&#x3D; 14;        fifo_red+&#x3D;Data1;Data2 &lt;&lt;&#x3D; 6;    fifo_red+&#x3D;Data2;Data3 &gt;&gt;&#x3D; 2;    fifo_red+&#x3D;Data3;Data4 &lt;&lt;&#x3D; 14;    fifo_ir+&#x3D;Data4;Data5 &lt;&lt;&#x3D; 6;    fifo_ir+&#x3D;Data5;Data6 &gt;&gt;&#x3D; 2;    fifo_ir+&#x3D;Data6;if(fifo_ir&lt;&#x3D;10000)&#123;fifo_ir&#x3D;0;&#125;if(fifo_red&lt;&#x3D;10000)&#123;fifo_red&#x3D;0;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>MSB（Most Significant Bit）指的是二进制数字中最高位的位，即权值最大的位。在一个二进制数中，MSB位于最左边。对于一个给定的非负数，MSB对数值的影响最大，因为它代表了最大的权值。</p><ol start="3"><li>**这个移位究竟是怎么个移位</li></ol><ul><li><strong>BYTE 1</strong> 包含了最高有效位，也就是<code>FIFO_DATA[17]</code>和<code>FIFO_DATA[16]</code>。</li><li><strong>BYTE 2</strong> 包含了接下来的位，从<code>FIFO_DATA[15]</code>到<code>FIFO_DATA[8]</code>。</li><li><strong>BYTE 3</strong> 包含了<code>FIFO_DATA[7]</code>到<code>FIFO_DATA[0]</code>，</li></ul><blockquote><p>0000 00aa</p><p>aa00  0000 0000 0000</p><p>bbccddee</p><p>bb ccdd ee00 0000</p><p>kkll mmnn</p><p>00kk llmm nn</p></blockquote><blockquote><p>aa00  0000 0000 0000 00</p><p>​    bb ccdd ee00 0000 00 </p><p>​                  00kk llmm nn</p></blockquote><h2 id="通过公式计算"><a href="#通过公式计算" class="headerlink" title="通过公式计算"></a>通过公式计算</h2><h2 id="心率原理"><a href="#心率原理" class="headerlink" title="心率原理"></a>心率原理</h2><img src="/2024/04/09/107-max30102-mo-kuai/image-20240412082525496.png" class="" title="image-20240412082525496"><img src="/2024/04/09/107-max30102-mo-kuai/image-20240412082501374.png" class="" title="image-20240412082501374"><p>顺势心率可以通过测量连续收缩峰值之间的时间来计算</p><p>注意: 只使用一个LED就可以测量心率,因为只需要交流信号分量</p><h2 id="血氧原理"><a href="#血氧原理" class="headerlink" title="血氧原理"></a>血氧原理</h2><p>1.4 血氧计算(SpO2)</p><p>血氧浓度，是指血中氧饱和血红蛋白相对于总<a href="https://zh.wikipedia.org/wiki/%E8%A1%80%E7%BA%A2%E8%9B%8B%E7%99%BD">血红蛋白</a>（不饱和+饱和）的比例</p><p>血压计算公式也比较简单，这里MAX30102是一路红光，一路红外。只分别算出红光的交流除以红光的直流即: ACred&#x2F;DCred，和红外的交流除以红外的直流分量即：ACired&#x2F;DCired。然后两者再相除得到R。</p><h3 id="咋算"><a href="#咋算" class="headerlink" title="咋算???"></a>咋算???</h3><img src="/2024/04/09/107-max30102-mo-kuai/20201107134420733.png" class="" title="img"><p>得到 R 然后查表即可得到血氧值，也可以通过下面美信拟合的公式计算：</p><p><code>SpO2 = -45.060*R*R + 30.354 *R + 94.845</code></p><p>4、心率识别：<br>delta &#x3D; 图3两个尖峰时间；<br>心率 &#x3D; 1 &#x2F; dalta.</p><p>5、血氧计算<br>R&#x3D;((ir_max+ir_min)(red_max-red_min))&#x2F;((red_max+red_min)(ir_max-ir_min));<br>SpO2&#x3D; ((-45.060)RR + 30.354*R + 94.845).</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>看不懂手册, 中文的也看不懂</p></li><li><p>目前问题是,读出了fifo的数据, 不知道对不对, 不知道咋那么用</p></li><li><p>打算提取例程库直接拿数据试试</p></li><li><p>读取的寄存器的值是什么</p><p><code>红光和红外光的反射值</code></p><blockquote><p>MAX30102脉搏血氧仪和心率传感器包含两个LED，分别发射红光(RED)和红外光(IR)，光线照射进人体组织后一部分被吸收，另一部分反射光被集成的光电传感器捕获、转变为电信号。两种光的电信号都会呈现出具有直流(DC)成分的交流(AC)信号，AC成分的频率就是脉搏频率，使用任何一个电信号就能获得心跳频率。</p><p>血氧浓度(SpO2)的计算需要同时使用两个电信号，估算SpO2</p><img src="/2024/04/09/107-max30102-mo-kuai/image-20240418112027421.png" class="" title="image-20240418112027421"></blockquote></li><li><p>如何将其转换为心率和血氧(也就是算法)</p></li><li><p>不要纠结自己重新做一遍,这样也是有好处的,可以发现自己的问题</p><p>但是最宝贵的是时间,我需要用尽量少的时间尽可能的完成较多的任务</p><p>,明白其原理,移植就可以了</p><p>加油</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_62425199/article/details/136096478?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-136096478-blog-128573054.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-136096478-blog-128573054.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=3">MAX30102寄存器参考</a></p><p><a href="https://blog.csdn.net/u012183892/article/details/109545972?ops_request_misc=%7B%22request_id%22:%22171283555616800227478257%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=171283555616800227478257&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~hot_rank-1-109545972-null-null.nonecase&utm_term=max30102%E5%BF%83%E7%8E%87%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4450">算法参考</a></p><p><a href="https://blog.csdn.net/tutututuo/article/details/115050516">MAX30102学习笔记（下）_max30102与0.96寸oled连接-CSDN博客</a></p><p><a href="https://blog.csdn.net/u012183892/article/details/109545972?ops_request_misc=%7B%22request_id%22:%22171283555616800227478257%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=171283555616800227478257&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~hot_rank-1-109545972-null-null.nonecase&utm_term=max30102%E5%BF%83%E7%8E%87%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4450">MAX30102 血氧调试笔记-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_37385726/article/details/89041710">光电容积脉搏波描记法PPG-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_62425199/article/details/136096478?ops_request_misc=%7B%22request_id%22:%22171341003516800225526011%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=171341003516800225526011&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~times_rank-1-136096478-null-null.nonecase&utm_term=max30102%E4%BC%A0%E6%84%9F%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86&spm=1018.2226.3001.4450">MAX30102脉搏血氧仪和心率传感器（含寄存器介绍）_max30102心率算法详解-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>超声波模块</title>
      <link href="/2024/04/08/106-chao-sheng-bo-mo-kuai/"/>
      <url>/2024/04/08/106-chao-sheng-bo-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><h2 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h2><p>应该需要中断吧</p><p>定时器中断&#x2F;捕获中断</p><p><strong>中断里如何处理</strong></p><blockquote><p>在STM32微控制器中，判断是否发生了捕获事件主要依赖于定时器的状态寄存器（Status Register, SR），具体来说，是通过检查该寄存器中的捕获&#x2F;比较中断标志位。对于不同的通道，这些标志位会有所不同。以定时器3为例，若想知道特定通道（比如通道3）是否发生了捕获事件，你可以检查SR寄存器中相应的CC3IF（Capture&#x2F;Compare 3 Interrupt Flag）位。</p></blockquote><p>读取状态寄存器:</p><blockquote><p>定时器的SR寄存器包含了多个标志位，每个标志位都指示了某种类型的事件是否发生。对于捕获事件，主要关注的是CCxIF位（x代表通道号）。</p></blockquote><p>检查捕获标志位:</p><blockquote><p>每个通道都有一个对应的捕获&#x2F;比较中断标志位。例如，如果你使用的是定时器3的通道3，则需要检查CC3IF位。当捕获事件发生时，硬件会自动将此位设置为1。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">if (TIM3-&gt;SR &amp; TIM_SR_CC3IF) &#123;    &#x2F;&#x2F; 捕获事件发生在通道3&#125;在这段代码中，TIM_SR_CC3IF是一个宏，通常在头文件中定义，指向SR寄存器中相应的位。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>清除捕获标志位:</p><blockquote><p>在STM32中，捕获标志位在读取捕获值后不会自动清零。为了防止误判为新的捕获事件，你需要在处理完捕获事件后手动清除该标志位。<br>通过读取定时器的捕获寄存器（如CCR3）完成，或者直接向SR寄存器写0到对应的标志位。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">TIM3-&gt;SR &amp;&#x3D; ~TIM_SR_CC3IF;  &#x2F;&#x2F; 清除通道3的捕获标志位<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>错误写法</li></ol><p>认为定时器0.1s计数一次,其实不是, 而是0.1s计数10000次</p><pre><code> TIM_TimeBaseInitStructure.TIM_Period = 10000-1;                //自动重装载值 ARR, 72MHz/720=0.1MHz  1/0.1MHz=10us 10us*10000=0.1s计数一次  TIM_TimeBaseInitStructure.TIM_Prescaler = 720-1;               //预分频系数 PSCTimeElapsed = TIM_GetCounter(TIM2);  // 读取计时器值，单位根据定时器配置而定    // 计算距离（单位：厘米）    Distance = TimeElapsed * 0.1*340;  // 假设TimeElapsed的单位为微秒，速度为340m/s</code></pre><ol start="2"><li><p>不够灵敏,不准确</p><p>首先是本应该是1s刷新一下, 别人的代码也是</p><p>其次,数据不对</p><p>不知道为什么用别人的代码也是一样的问题(怀疑硬件有问题, 但是他们看上去都没什么问题,选择先学习血氧模块)</p><p>(换过hc-sr04)</p></li></ol><p>本来以为最多一上午,然后搞了一天,都没弄好,因为不知道为什么是这种现象</p><ol start="3"><li>会卡住</li></ol><pre class="line-numbers language-none"><code class="language-none">while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1)&#x3D;&#x3D;1);  &#x2F;&#x2F; 等待回声信号结束,这里也不对   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 触发HC-SR04发送超声波void HCSR04_Trig(void) &#123;    GPIO_SetBits(GPIOB, GPIO_Pin_0);  &#x2F;&#x2F; GPIOB Pin 0输出高电平    delay_us(40);                      &#x2F;&#x2F; 延时10微秒    GPIO_ResetBits(GPIOB, GPIO_Pin_0); &#x2F;&#x2F; GPIOB Pin 0输出低电平&#125;void Distance_Get(void) &#123;    HCSR04_Trig();    delay_ms(300);        printf(&quot;等待回声信号开始&quot;);    while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1));     TIM_SetCounter(TIM2, 0);    TIM_Cmd(TIM2, ENABLE);        printf(&quot;回声信号即将结束&quot;);      while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1)&#x3D;&#x3D;0);  &#x2F;&#x2F;!!!!?卡住    printf(&quot;回声信号结束&quot;);    TIM_Cmd(TIM2,DISABLE);    Distance&#x3D;(Num&#x2F;5000*340*100)&#x2F;2;    if(Distance&gt;0)    &#123;      printf(&quot;Distance:%fcm\r\n&quot;,Distance);    &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><p>3cm以下会不准确</p></li><li><p>现成程序不好用, <strong>有硬件出问题了</strong></p><p>会混淆while(1)是卡住</p></li></ol><p><strong>阻塞式等待回声信号结束</strong>：</p><ul><li>使用<code>while</code>循环等待回声信号的结束（<code>GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1)==1</code>）是不理想的。这种阻塞式等待会使整个中断服务例程停留在等待状态，直到回声信号结束。这会阻塞其他中断的处理，影响系统的响应能力和实时性。</li></ul><p><strong>在ISR中使用<code>printf</code></strong>：</p><ul><li>在中断服务例程中调用<code>printf</code>或任何可能耗时较长的函数都是不推荐的。这会大幅增加中断服务例程的执行时间，降低系统的实时性能。尤其是<code>printf</code>可能会涉及到串口通信，其速度远不如CPU执行速度，从而导致在中断中产生不必要的延迟。</li></ul><p>stm3f103c8t6 5.68cm</p><p>stm32f103rct6 56.88cm</p><p>另外程序都不好使了,是硬件的问题,可能是硬件没供电</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>echo不用5v转3.3v,否则会不好使</p><p>有的引脚有误差,可以换一个试试</p><p>为什么同样的程序到我这不好使了</p><p>一样的传感器,有的能显示,有的不能显示</p><h3 id="Stm32-RCT6-C8T6-移植过程的问题"><a href="#Stm32-RCT6-C8T6-移植过程的问题" class="headerlink" title="Stm32 RCT6 C8T6 移植过程的问题"></a>Stm32 RCT6 C8T6 移植过程的问题</h3><p>移植要改启动文件,否则时钟快十倍</p><p>unsigned char stateInit &#x3D; 0;<br>volatile unsigned char adjusted &#x3D; 1;<br>unsigned int paraIndex &#x3D; 1;<br>unsigned char paraTest &#x3D; 1;<br>unsigned char TestTemp &#x3D; 0;<br>signed char plscnt &#x3D; 1;</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">SystemInit();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>未解决</p><p>rct6移植后出现时钟变快十倍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简易数字示波器</title>
      <link href="/2024/04/05/105-jian-yi-shu-zi-shi-bo-qi/"/>
      <url>/2024/04/05/105-jian-yi-shu-zi-shi-bo-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="虚短和虚断"><a href="#虚短和虚断" class="headerlink" title="虚短和虚断"></a>虚短和虚断</h2><ol><li>虚断<ul><li>理想运放的输入阻抗是无穷大，真是的运放输入阻抗是有限的，，输入端加电压，电流几乎为零，像运放内部断开一样</li><li>深度负反馈是会出现虚短现象，是两个输入端的点位相等，像两个输入端短接到了一起，反馈作用是运放的两个输入端（正输入和负输入的电压差趋近于领域0）</li></ul></li></ol><img src="/2024/04/05/105-jian-yi-shu-zi-shi-bo-qi/image-20240705221455212.png" class="" title="image-20240705221455212"><img src="/2024/04/05/105-jian-yi-shu-zi-shi-bo-qi/image-20240705221942716.png" class="" title="image-20240705221942716"><img src="/2024/04/05/105-jian-yi-shu-zi-shi-bo-qi/image-20240705222640788.png" class="" title="image-20240705222640788"><img src="/2024/04/05/105-jian-yi-shu-zi-shi-bo-qi/image-20240705222449708.png" class="" title="image-20240705222449708"><img src="/2024/04/05/105-jian-yi-shu-zi-shi-bo-qi/image-20240705223816782.png" class="" title="image-20240705223816782"><img src="/2024/04/05/105-jian-yi-shu-zi-shi-bo-qi/image-20240707202255594.png" class="" title="image-20240707202255594"><img src="/2024/04/05/105-jian-yi-shu-zi-shi-bo-qi/image-20240707202308105.png" class="" title="image-20240707202308105"><img src="/2024/04/05/105-jian-yi-shu-zi-shi-bo-qi/image-20240707202429314.png" class="" title="image-20240707202429314"><img src="/2024/04/05/105-jian-yi-shu-zi-shi-bo-qi/image-20240707202927142.png" class="" title="image-20240707202927142">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32驱动无刷电机</title>
      <link href="/2024/04/02/104-stm32-qu-dong-wu-shua-dian-ji/"/>
      <url>/2024/04/02/104-stm32-qu-dong-wu-shua-dian-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="无刷电机"><a href="#无刷电机" class="headerlink" title="无刷电机"></a>无刷电机</h2><h3 id="KV值"><a href="#KV值" class="headerlink" title="KV值"></a>KV值</h3><p>实际转速&#x3D;KV值*工作电压</p><h3 id="直流无刷电机工作原理"><a href="#直流无刷电机工作原理" class="headerlink" title="直流无刷电机工作原理"></a>直流无刷电机工作原理</h3><p>安培定则，也叫右手螺旋定则，是表示电流和电流激发 磁场的磁感线方向间关系的定则。</p><p>通电直导线中的安培定则（安培定则一）：用右手握住通电直导线， 让大拇指指向电流的方向，那么四指指向就是磁感线的环绕方向；通电螺线管中的安培定则（安培定则二）： 用右手握住通电螺线管，让四指指向电流的方向，那么大拇指所指的那一端是通电螺线管的N极，如下图所示。</p><img src="/2024/04/02/104-stm32-qu-dong-wu-shua-dian-ji/image-20240406082359565.png" class="" title="image-20240406082359565"><img src="/2024/04/02/104-stm32-qu-dong-wu-shua-dian-ji/image-20240406082549676.png" class="" title="image-20240406082549676"><p>当两边的线圈通上电后，由右手螺旋定则可知两个线圈中将会产生方向向右的磁场，而<strong>中间的转子会尽量使 自己内部的磁感线方向与外磁感线方向保持一致，以形成一个最短闭合磁力线回路</strong>，N极与S极相互吸引， 这样内转子就会按顺时针方向旋转了。当转子旋转到如图所示的水平位置时转子将不会受到作用力。</p><img src="/2024/04/02/104-stm32-qu-dong-wu-shua-dian-ji/image-20240406082600016.png" class="" title="image-20240406082600016"><p>但是由于<strong>惯性</strong>的作用转子将会继续旋转，当转子旋转至水平位置时，<strong>交换两个线圈中的电流方向</strong>， 这时转子就会<strong>继续向顺时针方向转动</strong>了。当转子再次旋转至水平位置时，再次交换两个线圈中的电流方向， 这样转子就可以一直旋转了。</p><p>有了上面的基础，我们再来看下面的“<strong>三相星形联结</strong>的二二导通方式”。</p><img src="/2024/04/02/104-stm32-qu-dong-wu-shua-dian-ji/image-20240406082708898.png" class="" title="image-20240406082708898"><img src="/2024/04/02/104-stm32-qu-dong-wu-shua-dian-ji/image-20240406084253202.png" class="" title="image-20240406084253202"><p>想要转子转动就需要接入不同的电压，我们来分析一下图中的6个过程。</p><ol><li>在A端接入正电压，B端接入负电压，C端悬空，转子将会旋转至图中1的位置。</li><li>在1的基础上，C端接入正电压，B端接入负电压，A端悬空，转子将会从1的位置旋转至图中2的位置。</li><li>在2的基础上，C端接入正电压，A端接入负电压，B端悬空，转子将会从2的位置旋转至图中3的位置。</li><li>在3的基础上，B端接入正电压，A端接入负电压，C端悬空，转子将会从3的位置旋转至图中4的位置。</li><li>在4的基础上，B端接入正电压，C端接入负电压，A端悬空，转子将会从4的位置旋转至图中5的位置。</li><li>在5的基础上，A端接入正电压，C端接入负电压，B端悬空，转子将会从5的位置旋转至图中6的位置。</li></ol><p>当转子旋转到位置6时，在重复1的供电状态，转子将会从6的位置旋转到1的位置。 在经过上面的6个过程后转子正好转了一圈，我们将这种驱动方法称为6拍工作方式，<strong>每次电压的变化称为换相</strong>。想要电机持续的旋转我们只要按上面转子相应的位置接入相应的电压即可。</p><h2 id="电调"><a href="#电调" class="headerlink" title="电调"></a>电调</h2><p>电调全称电子调速器, 使用之前需要先解锁(<strong>也就是说明说上的行程校准</strong>)</p><p><strong>为什么需要电调</strong><br>因为单片机IO驱动能力弱，所以我们想<strong>实现一个小电流控制大电流</strong>的效果，就像直流有刷电机用L298N电机驱动器驱动一样，用无刷电调控制无刷电机。</p><p><strong>接线</strong></p><img src="/2024/04/02/104-stm32-qu-dong-wu-shua-dian-ji/image-20240406101522856.png" class="" title="image-20240406101522856"><ul><li><a href="https://www.hobbywing.com/uploads/file/20230321/573ff85876cf18a48d8f0b92b3244065.pdf">HW-SM048DUL_Platinum-HV-300A-V4.1说明书</a>)</li></ul><h3 id="行程校准"><a href="#行程校准" class="headerlink" title="行程校准"></a>行程校准</h3><p>电调每次上电都需要校准, 即确定量程</p><img src="/2024/04/02/104-stm32-qu-dong-wu-shua-dian-ji/image-20240406101653735.png" class="" title="image-20240406101653735"><p>大部分电调都是需要<strong>50Hz</strong>的PWM脉冲频率，其中，高电平的脉宽需要在<strong>1-2ms</strong>，50Hz就是20ms周期的方波，其中高电平时间是1-2ms，那占空比就是<strong>5%-10%</strong>。</p><blockquote><ol><li>单片机给2ms高电平（最大油门），此时电调不上电</li><li>电调上电(会有声音提示)</li><li>单片机给1ms高电平（最小油门）（解锁完成）</li><li>给任意1-2ms范围内的高电平，转</li></ol></blockquote><p>先将PWM占空比设置为10%，然后上电，首先会听到滴滴的声音，之后立刻PWM占空比设置为5%，然后会发出滴滴滴、滴的声音表示校准完成，最后把接线恢复。</p><p><strong>尝试通电复位完成自动校准</strong>,哔哔, 哔哔哔-哔–</p><p><strong>问题1</strong></p><p>实验现象: 1800 800   1200 1800会转</p><p>​              1200<del>1350,速度主次递减,1800也是1800</del>1850</p><p>我还是不明白是为什么,难道不是应该800-1800之间吗</p><p><a href="(https://blog.csdn.net/weixin_42119432/article/details/102962533#:~:text=%E5%8E%9F%E7%90%86%EF%BC%9A,%E7%94%B5%E8%B0%83%E6%AF%8F%E6%AC%A1%E4%B8%8A%E7%94%B5%EF%BC%88%E7%94%B5%E8%B0%83%E7%94%B1%E6%9D%BF%E5%AD%90%E4%BE%9B%E7%94%B5%EF%BC%89%EF%BC%8C%E5%8D%B3%E6%9D%BF%E5%AD%90%E6%AF%8F%E6%AC%A1%E5%90%AF%E5%8A%A8%EF%BC%8C%E9%83%BD%E8%A6%81%E7%BB%99%E7%94%B5%E8%B0%83%E8%AE%BE%E7%BD%AE%E6%B2%B9%E9%97%A8%E8%A1%8C%E7%A8%8B%EF%BC%9A%E6%9C%80%E9%AB%98%E6%B2%B9%E9%97%A8%E4%B8%8E%E6%9C%80%E4%BD%8E%E6%B2%B9%E9%97%A8%EF%BC%8C%E6%96%B9%E5%BC%8F%E6%98%AF%EF%BC%9A%E8%B0%83%E5%88%B6%E4%B8%80%E4%B8%AA%E5%8D%A0%E7%A9%BA%E6%AF%94%E9%AB%98%E4%B8%80%E7%82%B9pwn%E6%B3%A2%E8%AE%BE%E7%BD%AE%E6%9C%80%E9%AB%98%E6%B2%B9%E9%97%A8%E4%B8%8E%E8%B0%83%E5%88%B6%E4%B8%80%E4%B8%AA%E5%8D%A0%E7%A9%BA%E6%AF%94%E4%BD%8E%E4%B8%80%E7%82%B9pwn%E6%B3%A2%E8%AE%BE%E7%BD%AE%E6%9C%80%E4%BD%8E%E6%B2%B9%E9%97%A8%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84%E5%8D%A0%E7%A9%BA%E6%AF%94%E6%98%AF%E6%8C%87%E4%B8%80%E4%B8%AApwn%E5%91%A8%E6%9C%9F%E5%86%85%E9%AB%98%E7%94%B5%E5%B9%B3%E6%8C%81%E7%BB%AD%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8D%B3%E9%AB%98%E7%94%B5%E5%B9%B3%E8%84%89%E5%AE%BD%E3%80%82)">好盈无刷电调驱动</a></p><p><strong>问题2</strong>(2024.4.7)</p><p>无法进入校准, 也无法驱动</p><img src="/2024/04/02/104-stm32-qu-dong-wu-shua-dian-ji/image-20240407214554713.png" class="" title="image-20240407214554713"><p>没有pwm信号</p><ul><li><p>但是接了个led证明,是有的, 那应该是<strong>电调</strong>坏了</p></li><li><p>已换工程试过, 说明不是玄学</p></li></ul><p><strong>反转电调</strong></p><p>根据说明书: 反转需要将黄色线接入一个空闲通道, 也就是说,这根反转线也需要pwm来控制</p><blockquote><p>那其实就相当于两路pwm,一路正转,一路反转</p><p>反推刹车, 就是正转停止输出, 反转输出</p></blockquote><p>暂时不需要黄线, 反转<strong>任意交换两个电机线就可以改变电机反向</strong>就可以了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>问题</strong>(2024.4.7)</p><p>1.电调不按照预期旋转</p><p>1000-2000,结果只有800-1800才可以,并且1200-1350与1800-1950都会转</p><p>2.电调无法检测pwm信号</p><ul><li><p>无刷电机驱动需要六个MOS管控制三个电磁铁的电流方向</p></li><li><p>使用无刷电调只需像控制有刷电机的电机一样控制PWM</p></li><li><p>开发板的问题</p></li></ul><p><a href="https://blog.csdn.net/qq_28056277/article/details/91347436?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5-91347436-blog-119865081.235%5Ev43%5Epc_blog_bottom_relevance_base8&spm=1001.2101.3001.4242.4&utm_relevant_index=6">用STM32F103单片机控制电调制动无刷电机_stm32f103 c61电调-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_51472581/article/details/132189694?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-132189694-blog-86555732.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-132189694-blog-86555732.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=3">STM32电调控制无感无刷电机_stm32无刷电调-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_21405333/article/details/119860088?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-119860088-blog-91347436.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-119860088-blog-91347436.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=7">用stm32模拟遥控器初始化电调（电调解锁）（电调行程校准）（附百度云例程）_stm32控制电调-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MPU6050IIC通信</title>
      <link href="/2024/04/02/103-mpu6050iic-tong-xin/"/>
      <url>/2024/04/02/103-mpu6050iic-tong-xin/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IIC协议</title>
      <link href="/2024/03/28/102-iic-xie-yi/"/>
      <url>/2024/03/28/102-iic-xie-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="IIC通信协议"><a href="#IIC通信协议" class="headerlink" title="IIC通信协议"></a>IIC通信协议</h2><p>IIC是由Philips公司开发的一种通用数据总线,分为硬件IIC和软件IIC。</p><ul><li>两个通信线: SCL(Serial Clock)、SDA(Serial Data)</li><li>同同步、半双工</li><li>支持数据应答、支持总线挂载多设备</li></ul><img src="/2024/03/28/102-iic-xie-yi/image-20240329113138335.png" class="" title="image-20240329113138335"><p><strong>指定地址写</strong><img src="/2024/03/28/102-iic-xie-yi/image-20240407100559867.png" class="" title="image-20240407100559867"></p><p><strong>当前地址读</strong><img src="/2024/03/28/102-iic-xie-yi/image-20240407100622763.png" class="" title="image-20240407100622763"></p><p><strong>指定地址读</strong><img src="/2024/03/28/102-iic-xie-yi/image-20240407100703062.png" class="" title="image-20240407100703062"></p><p>默认高电平</p><h2 id="模拟IIC"><a href="#模拟IIC" class="headerlink" title="模拟IIC"></a>模拟IIC</h2><h3 id="有效状态"><a href="#有效状态" class="headerlink" title="有效状态"></a>有效状态</h3><p>SDA线上的数据必须在时钟的<strong>高电平周期保持稳定</strong>。数据线的高或低状态只有在SCL线的时钟信号是<strong>低电平时才能改变</strong>。</p><p>也就是只有SCL处于低电平状态时,才能够传输数据</p><img src="/2024/03/28/102-iic-xie-yi/image-20240329130838773.png" class="" title="image-20240329130838773"><h3 id="起始和停止状态"><a href="#起始和停止状态" class="headerlink" title="起始和停止状态"></a>起始和停止状态</h3><img src="/2024/03/28/102-iic-xie-yi/image-20240329130756843.png" class="" title="image-20240329130756843"><p>所有的数据传输都以START (S)开始,以 STOP (P)停止</p><ul><li>SCL高电平,SDA由高到低切换,则为START</li><li>SCL高电平,SDA由低到高切换,则为STOP</li></ul><h3 id="Byte-format"><a href="#Byte-format" class="headerlink" title="Byte format"></a>Byte format</h3><ul><li>SDA线上的每个字节都必须为8位长。</li><li>每个字节后面必须跟一个Acknowledgebit(应答位)。</li><li>数据传输<strong>高位先行</strong>。可以将SCL拉高</li><li>当<strong>从机不能响应</strong>从机地址时（如，正在执行一些实时函数不能接受和发送），<strong>从机必须使数据线保持高电平</strong>，<strong>主机</strong>然后<strong>产生一个停止条件</strong>终止传输或者产生重复起始条件开始新的传输。</li></ul><img src="/2024/03/28/102-iic-xie-yi/image-20240329131225835.png" class="" title="image-20240329131225835"><blockquote><p>数据传输遵循图9所示的格式。在START条件（S）之后发送目标地址。地址有七位长，第八位为<br>数据方向位（R&#x2F;W）——“零”表示传输（WRITE）。数据传输总是由控制器生成的STOP条件（P）终止。但是，如果控制器仍然希望在总线上通信，它可以生成<strong>重复的START条件（Sr）和地址</strong>另一个目标，而不首先生成STOP条件。</p></blockquote><img src="/2024/03/28/102-iic-xie-yi/image-20240401091944785.png" class="" title="image-20240401091944785"><h3 id="发送与接收字节"><a href="#发送与接收字节" class="headerlink" title="发送与接收字节"></a>发送与接收字节</h3><img src="/2024/03/28/102-iic-xie-yi/image-20240329152846927.png" class="" title="image-20240329152846927"><img src="/2024/03/28/102-iic-xie-yi/image-20240329152906915.png" class="" title="image-20240329152906915"><img src="/2024/03/28/102-iic-xie-yi/image-20240329152938792.png" class="" title="image-20240329152938792"><h3 id="应答-ACK-与未应答-NACK"><a href="#应答-ACK-与未应答-NACK" class="headerlink" title="应答(ACK) 与未应答 (NACK)"></a>应答(ACK) 与未应答 (NACK)</h3><img src="/2024/03/28/102-iic-xie-yi/image-20240331153821788.png" class="" title="image-20240331153821788"><p>确认从机是否收到数据</p><p>主机释放SDA,若保持高电平,则为NACK未应答</p><h3 id="关于模拟IIC延时"><a href="#关于模拟IIC延时" class="headerlink" title="关于模拟IIC延时"></a>关于模拟IIC延时</h3><img src="/2024/03/28/102-iic-xie-yi/image-20240329221718764.png" class="" title="image-20240329221718764"><p>是否需要延时, 延时多久</p><p>官方手册给的大多是0-160ns, 的其他大佬案例有2us,或者10us的</p><p><strong>验证硬件</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int main(void)&#123;  uint8_t ack ;  delay_init();  OLED_Init();  IIC_Init();        IIC_Start();        &#x2F;&#x2F;开始&#x2F;再开始  IIC_SendByte(0xD0); &#x2F;&#x2F; 1110 000 0R&#x2F;W 前七位是地址  ack &#x3D; IIC_ReadAck();&#x2F;&#x2F;读取响应  IIC_Stop();         &#x2F;&#x2F;停止      OLED_ShowString(1,1,&quot;ACK:&quot;);  OLED_ShowNum(1,5,ack,3);  while(1)&#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MPU6050"><a href="#MPU6050" class="headerlink" title="MPU6050"></a>MPU6050</h2><ol><li><p>初始化, 解除睡眠模式</p></li><li><p>开始-&gt;发送地址写-&gt;接收应答-&gt;发送MPU6050寄存器地址-&gt;接收应答-&gt;发送数据-&gt;接受应答-&gt;停止</p></li><li><p>读取数据(指定地址读):</p></li></ol><blockquote><p>开始-&gt;发送地址写-&gt;接收应答-&gt;发送MPU6050寄存器地址-&gt;接收应答-&gt;<em><strong>重复开始</strong></em>-&gt;发送寄存器地址 | 0x01-&gt;接受应答-&gt;读取字节-&gt;不发送应答(因为只读取一个字节)-&gt;停止</p><p><strong>主设备发送从设备的地址和写命令</strong>，以表明它想要进行写操作。这里的写操作实际上是告诉从设备“我接下来想要读取哪个寄存器”。</p><p><strong>主设备发送重复起始信号</strong>，转换为读模式。</p></blockquote><p>转为读的时序, 必须重新指定读写位, 需要重复起始</p><p><strong>这部分内容在手册哪里我还没有研究明白</strong></p><ol start="4"><li>获取寄存器三轴角速度与加速度值</li></ol><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define MPU6050_SMPLRT_DIV0x19#defineMPU6050_CONFIG0x1A#defineMPU6050_GYRO_CONFIG0x1B#defineMPU6050_ACCEL_CONFIG0x1C#defineMPU6050_ACCEL_XOUT_H0x3B#defineMPU6050_ACCEL_XOUT_L0x3C#defineMPU6050_ACCEL_YOUT_H0x3D#defineMPU6050_ACCEL_YOUT_L0x3E#defineMPU6050_ACCEL_ZOUT_H0x3F#defineMPU6050_ACCEL_ZOUT_L0x40#defineMPU6050_TEMP_OUT_H0x41#defineMPU6050_TEMP_OUT_L0x42#defineMPU6050_GYRO_XOUT_H0x43#defineMPU6050_GYRO_XOUT_L0x44#defineMPU6050_GYRO_YOUT_H0x45#defineMPU6050_GYRO_YOUT_L0x46#defineMPU6050_GYRO_ZOUT_H0x47#defineMPU6050_GYRO_ZOUT_L0x48#defineMPU6050_PWR_MGMT_10x6B#defineMPU6050_PWR_MGMT_20x6C#defineMPU6050_WHO_AM_I0x75<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><strong>MPU6050_SMPLRT_DIV</strong></li></ol><p>采样分频寄存器, 当DLPF被启用时（参见寄存器26）。加速度计的输出率为<strong>1kHz</strong>。这意味着，对于采样率超过1kHz的情况，相同的加速度计样本可能会被多次输出到FIFO（先进先出队列）、DMP（数字运动处理器）和传感器寄存器中。</p><p>Parameters:</p><blockquote><p>SMPLRT_DIV 8-bit unsigned value. The Sample Rate is determined by dividing the gyroscope output rate by this value.</p></blockquote><ol start="2"><li><p><strong>CONFIG</strong></p><p>外部同步0,数字低通滤波器6最平滑</p></li><li><p>**GYRO_CONFIG **</p></li></ol><p>​      此寄存器用于触发陀螺仪自检并配置陀螺仪的满量程。</p><ol start="4"><li><strong>ACCEL_CONFIG</strong></li></ol><p>​      此寄存器用于触发加速计自检并配置加速计满量程范围, 该寄存器还配置数字高通滤波器（DHPF）</p><ol start="5"><li><strong>MPU6050_PWR_MGMT_1</strong></li></ol><p>​      设置成0x00,sleep位给0,解除睡眠模式,其他位配置参照手册</p><ol start="6"><li><strong>MPU6050_PWR_MGMT_2</strong></li></ol><p>​      不需要低功耗模式</p><p>设置陀螺仪和加速度计的外部帧同步（FSYNC）引脚采样以及数字低通滤波器（DLPF）</p><p>配置陀螺仪外部时钟</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>已经第二次了,因为忘记<em><strong>初始化delay</strong></em>,导致程序卡死</p><p>是因为delay_us函数有一个do while,没初始化<em><strong>fac_us的值就无法初始化</strong></em>,所以就一直在while里面等待,</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void delay_us(u32 nus)&#123;u32 temp;     SysTick-&gt;LOAD&#x3D;nus*fac_us; &#x2F;&#x2F;时间加载   SysTick-&gt;VAL&#x3D;0x00;        &#x2F;&#x2F;清空计数器SysTick-&gt;CTRL|&#x3D;SysTick_CTRL_ENABLE_Msk ;&#x2F;&#x2F;开始倒数  do&#123;temp&#x3D;SysTick-&gt;CTRL;&#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16)));&#x2F;&#x2F;等待时间到达   SysTick-&gt;CTRL&amp;&#x3D;~SysTick_CTRL_ENABLE_Msk;&#x2F;&#x2F;关闭计数器SysTick-&gt;VAL &#x3D;0X00;       &#x2F;&#x2F;清空计数器 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="硬件IIC"><a href="#硬件IIC" class="headerlink" title="硬件IIC"></a>硬件IIC</h2><p><strong>软件IIC与硬件IIC的区别</strong></p><p>软件手动模拟IIC协议</p><p>硬件调用函数即可(硬件IIC协议应该会自动发送接收应答~猜的)</p><h3 id="软硬件波形图对比"><a href="#软硬件波形图对比" class="headerlink" title="软硬件波形图对比"></a>软硬件波形图对比</h3><img src="/2024/03/28/102-iic-xie-yi/image-20240407101421162.png" class="" title="image-20240407101421162"><p>可以看出硬件IIC更规整,但是IIC是同步时序,所以并不影响</p><p>开启IIC时钟, 设置为复用开漏模式, 引脚要交给外设</p><img src="/2024/03/28/102-iic-xie-yi/image-20240407221756088.png" class="" title="image-20240407221756088"><img src="/2024/03/28/102-iic-xie-yi/image-20240407221827545.png" class="" title="image-20240407221827545"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.关于什么时候用复用模式</p><blockquote><p>对寄存器AFIO_MAPR，AFIO_EXTICRX和AFIO_EVCR进行读写操作前，应当首先打开AFIO时钟。</p><p>- FIO_MAPR：配置复用功能重映射</p><p>- AFIO_EXTICRX：配置外部中断线映射</p><p>- AFIO_EVCR：配置EVENTOUT事件输出</p></blockquote><p>2.为什么只有读取应答位,而不用写入应答位</p><blockquote><p>check事件就相当于检测应答位了</p></blockquote><blockquote><img src="/2024/03/28/102-iic-xie-yi/image-20240407230637790.png" class="" title="image-20240407230637790"></blockquote><p>3.关于读数据要先当前地址写的逻辑没搞清楚</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32通信接口</title>
      <link href="/2024/03/24/101-stm32-tong-xin-jie-kou/"/>
      <url>/2024/03/24/101-stm32-tong-xin-jie-kou/</url>
      
        <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><img src="/2024/03/24/101-stm32-tong-xin-jie-kou/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1.png" class="" title="串口通信"><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><p>UART、RS-232和RS-485 是单片机中常见的串口通信协议，而 I2C 和 SPI 是总线通信协议</p><img src="/2024/03/24/101-stm32-tong-xin-jie-kou/image-20240324111732602.png" class="" title="image-20240324111732602"><h3 id="uart"><a href="#uart" class="headerlink" title="uart"></a>uart</h3><p><strong>uart与usart的区别</strong></p><ol><li><strong>uart</strong>异步通信<strong>不使用外部时钟信号</strong>来同步数据传输；相反，发送和接收设备必须事先同意数据传输的速率（波特率）。</li><li><strong>USART</strong>: 它支持异步串行通信和同步串行通信。在同步通信模式下，数据以连续的比特流形式传输，通常由<strong>外部时钟信号</strong>或数据中的时钟信息<strong>来同步</strong>。同步通信允许更高的数据传输速率，因为数据在没有起始位和停止位的情况下连续发送，从而提高了效率。</li></ol><img src="/2024/03/24/101-stm32-tong-xin-jie-kou/image-20240324114048999.png" class="" title="image-20240324114048999"><img src="/2024/03/24/101-stm32-tong-xin-jie-kou/image-20240324114810970.png" class="" title="image-20240324114810970"><p>参考手册推荐USART 的GPIO配置</p><img src="/2024/03/24/101-stm32-tong-xin-jie-kou/image-20240324120755083.png" class="" title="image-20240324120755083"><h2 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h2><p>TX：不发送数据时，TX引脚处于高电平</p><p><strong>单字节通信</strong></p><p><strong>清零TXE位</strong>总是通过对数据寄存器的写操作来完成的。TXE位由硬件来设置，它表明：</p><p>故<strong>不需要手动清零TXE</strong></p><p>● 数据已经从TDR移送到移位寄存器，数据发送已经开始</p><p>● TDR寄存器被清空</p><p>● 下一个数据可以被写进USART_DR寄存器而不会覆盖先前的数据</p><h3 id="发送字符串"><a href="#发送字符串" class="headerlink" title="发送字符串"></a>发送字符串</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*发送字符串函数*&#x2F;void Serial_SendString(char *string)&#123;  for(uint16_t i&#x3D;0;string[i]!&#x3D;&#39;\0&#39;;i++)                   &#x2F;&#x2F;C语言中字符串最后一位为&#39;\0&#39;  &#123;    Serial_SendByte(string[i]);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这是一个循环，它会持续检查当前字符是否是字符串的终结符（即空字符 <code>&#39;\0&#39;</code>）。</p><p> 在 C 语言中，<strong>所有的字符串都以空字符结束</strong>，这个循环利用这一点来判断何时停止发送。</p><p>用指针类型,是因为要对字符串一位一位读取</p><h3 id="发送数字"><a href="#发送数字" class="headerlink" title="发送数字"></a>发送数字</h3><p>注意: 0~9对应ASCII码分别是48-57</p><img src="/2024/03/24/101-stm32-tong-xin-jie-kou/image-20240324113452009.png" class="" title="image-20240324113452009"><h2 id="数据接收"><a href="#数据接收" class="headerlink" title="数据接收"></a>数据接收</h2><img src="/2024/03/24/101-stm32-tong-xin-jie-kou/image-20240324175812486.png" class="" title="image-20240324175812486"><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><img src="/2024/03/24/101-stm32-tong-xin-jie-kou/image-20240324183231834.png" class="" title="image-20240324183231834"><p>发送和接收由一<strong>共用的波特率发生器</strong>驱动，当发送器和接收器的使能位分别置位时，分别为其产生时钟。</p><p>在USART接收期间，数据的<strong>最低</strong>有效位首先从RX脚移进RXNE位被置位。它表明移位寄存器的内容被转移到RDR。换句话说，数据已经被接收并且可以被读出</p><p>如果RXNEIE位被设置，产生中断</p><h2 id="串口数据包"><a href="#串口数据包" class="headerlink" title="串口数据包"></a>串口数据包</h2><p>注意的地方就是条件判断, 注意条件循环到第几次时间成立</p><img src="/2024/03/24/101-stm32-tong-xin-jie-kou/image-20240325223953120.png" class="" title="image-20240325223953120"><h2 id="串口文本包"><a href="#串口文本包" class="headerlink" title="串口文本包"></a>串口文本包</h2><img src="/2024/03/24/101-stm32-tong-xin-jie-kou/image-20240326074656495.png" class=""><p>问题1</p><p>oled显示屏后面有乱码</p><p>解决: 代码的逻辑问题, 这段代码,会将\r写入发送的数据包,所以OLED会乱码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">else if(RxState&#x3D;&#x3D;1)  &#123;    Serial_RxPacket[pRxPacket]&#x3D;RxData;            pRxPacket++;      if(RxData&#x3D;&#x3D;&#39;\r&#39;)    &#123;      RxState&#x3D;2;     &#125;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;修改逻辑后, 只能返回一次收到的数据Serial_SendString((char *)Serial_RxPacket); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="未解决"><a href="#未解决" class="headerlink" title="未解决"></a>未解决</h3><p>问题2</p><p>串口发回数据包会影响主循环的oled显示,且数据只能发回一次,但是如果是@11可以一直返回,@111长度以后就不可以了,应该是溢出卡死了</p><p>但不是<strong>数组溢出</strong>因为我增大了数组值,也没有改变</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Serial_RxFlag &#x3D; 1;Serial_SendString((char *)Serial_RxPacket); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="格式问题"><a href="#格式问题" class="headerlink" title="格式问题"></a>格式问题</h2><p>如何发送字符串</p><p>发送数字</p><p>解析字符串</p><p>发送一帧数据</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">snprintf：将四个整型数据转换为字符串并格式化为&lt;data1,data2,data3,data4&gt;的形式。Serial_SendString：逐字符发送构造好的数据帧字符串。发送函数说明c复制代码void Send_Monitor_Data(int data1, int data2, int data3, int data4)&#123;    snprintf(Serial_TxPacket, sizeof(Serial_TxPacket), &quot;&lt;%d,%d,%d,%d&gt;&quot;, data1, data2, data3, data4);    Serial_SendString(Serial_TxPacket);&#125;snprintf：将整数数据格式化为字符串，并存储在Serial_TxPacket中。确保构造的字符串符合&lt;1,2,3,4&gt;的格式。Serial_SendString：发送格式化好的字符串。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>机械臂matlab仿真</title>
      <link href="/2024/03/21/100-ji-jie-bi-matlab-fang-zhen/"/>
      <url>/2024/03/21/100-ji-jie-bi-matlab-fang-zhen/</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>1.实物</p><p>2.建模</p><p>3.matlab仿真</p><p><strong>基于STM32单片机定位抓取和分拣的机械臂控制系统设计</strong>,选择<strong>STM32单片机</strong>作为主控制器，<strong>按钮</strong>、<strong>传感器</strong>、<strong>指示灯</strong>，用于机械臂的控制和<strong>状态监测</strong>。将机械臂安装到工作环境中，(<strong>旋转,有物体就放置</strong>),*。<strong>一键校准</strong>,写死的,一键定位,一键执行动作对机械臂进行综合测试，包括定位精度测试、抓取力度测试、<strong>分拣速度测试</strong>等，验证机械臂的性能和可靠性,<strong>拿起两个物体然后放下</strong></p><h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><p>首先需要六路PWM,两个定时器就够了</p><table><thead><tr><th align="center">外设</th><th align="center">引脚</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">六轴舵机驱动</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">HC-SR04超声波</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">蓝牙模块</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">按键</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">LED</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>让gpt来</p><p>找个思维导图的软件</p><p>任务表的软件</p><p>六轴机械臂</p><p>先实物</p><p>后建模</p><p>最后matlab仿真</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>泰山派学习笔记(1)</title>
      <link href="/2024/03/17/99-tai-shan-pai-xue-xi-bi-ji-1/"/>
      <url>/2024/03/17/99-tai-shan-pai-xue-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h2 id="学前问题"><a href="#学前问题" class="headerlink" title="学前问题"></a>学前问题</h2><h3 id="SDK是什么"><a href="#SDK是什么" class="headerlink" title="SDK是什么"></a>SDK是什么</h3><p><em><strong>SDK</strong>全称Software Development Kit(软件开发工具包), SDK通常可以从开发板或芯片制造商的官方网站下载,同时官方一般也会有编译好的镜像, 但是通过</em><em>下载编译sdk<strong>可以</strong>定制自己想要的系统镜像*</em></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>搭建linux编译环境</p><ul><li><p>安装Ubuntu操作系统(一般官方都是ubuntu系统配置的,所以保持一样可以减少错误)</p></li><li><p>安装虚拟机(VmWare或者VirtualBox)</p></li></ul></li><li><p>下载SDK</p></li><li><p>编译</p></li></ul><h2 id="搭建linux开发环境"><a href="#搭建linux开发环境" class="headerlink" title="搭建linux开发环境"></a>搭建linux开发环境</h2><h3 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h3><p><a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox官方下载</a></p><p>[VmWare官方下载](<a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html">Download VMware Workstation Pro</a>)</p><h3 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h3><p>拉取镜像</p><ul><li><p>中科大源：<a href="https://mirrors.ustc.edu.cn/ubuntu-releases/">Index of &#x2F;ubuntu-releases&#x2F; (ustc.edu.cn)</a></p></li><li><p>阿里云源：<a href="https://mirrors.aliyun.com/ubuntu-releases/">ubuntu-releases安装包下载_开源镜像站-阿里云 (aliyun.com)</a></p></li><li><p>官方（很慢不推荐）<a href="https://ubuntu.com/download">Get Ubuntu | Download | Ubuntu</a></p></li></ul><p>❗注意:</p><p>安装精简版后, 将CD&#x2F;DVD光盘换成自动检测,然后重启,否则会打不开</p><p>Ubuntu安装VMware-Tools需要在root下, 然后拖动文件到terminal中,终端会自动出现路径</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">passwd root  #设置root密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar zxvf VMware-Toolsxxxxxxxx.tarcd vmware-tools-distrib.&#x2F;vmware-install.pl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>安装后发现还是无法共享粘贴板</p><ol><li>需要安装虚拟机增强工具包open-vm-tools和open-vm-tools-desktop。</li></ol><h3 id="安装open-vm-tools"><a href="#安装open-vm-tools" class="headerlink" title="安装open-vm-tools"></a>安装open-vm-tools</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install open-vm-tools<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装open-vm-tools-desktop"><a href="#安装open-vm-tools-desktop" class="headerlink" title="安装open-vm-tools-desktop"></a>安装open-vm-tools-desktop</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install open-vm-tools-desktop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后确定<code>虚拟机设置-&gt;选项-&gt;客户机隔离</code>全部勾选对号, 重启即可完成安装</p><h2 id="解压SDK"><a href="#解压SDK" class="headerlink" title="解压SDK"></a>解压SDK</h2><p>将tspi_linux_sdk_xxxxxxxx.tar.gz 上传到ubuntu虚拟机中，目录路径不能包含中文，且需保证至少有100G的容量，最终编译完成后整个SDK大小会到80G左右，上传的方式有很多种比如<code>samba</code>、<code>共享文件夹</code>、<code>sftp</code>等</p><p>我这里直接使用Vmtools复制粘贴到桌面, 然后使用命令复制到根目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cp xxxx &#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">md5sum tspi_linux_sdk_repo_20240131.tar.gzcat tspi_linux_sdk_repo_20240131_md5sum.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>看一下这个值是否和内容一致</p><p>解压</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -xzf tspi_linux_sdk_repo_20240131.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压完成后只有.repo目录我们还需要把代码同步出来</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.repo&#x2F;repo&#x2F;repo sync -l -j88<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>报错</strong></p><ul><li><p>没有这个文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd repo&#x2F;repo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>继续cd repo时出现<code>root@maobin-virtual-machine:/taishanpi/.repo/repo# cd repo -bash: cd: repo: Not a directory</code></p></li><li><p>执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;repo sync -l -j88<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@maobin-virtual-machine:&#x2F;taishanpi&#x2F;.repo&#x2F;repo# .&#x2F;repo sync -l -j88&#x2F;usr&#x2F;bin&#x2F;env: ‘python’: No such file or directoryroot@maobin-virtual-machine:&#x2F;taishanpi&#x2F;.repo&#x2F;repo# .&#x2F;repo &#x2F;usr&#x2F;bin&#x2F;env: ‘python’: No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get python3vim .&#x2F;repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>j将**#!&#x2F;usr&#x2F;bin&#x2F;env python<strong>变为</strong>#!&#x2F;usr&#x2F;bin&#x2F;env python3**</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;repo sync -l -j88<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@maobin-virtual-machine:&#x2F;taishanpi&#x2F;.repo&#x2F;repo# .&#x2F;repo sync -l -j88repo: error: &quot;git&quot; is not availablerepo: error: [Errno 2] No such file or directory: &#39;git&#39;: &#39;git&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>安装后继续运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt install git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2024/03/17/99-tai-shan-pai-xue-xi-bi-ji-1/image-20240317221641540.png" class="" title="image-20240317221641540"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">- app： 存放上层应⽤ app，主要是 qcamera&#x2F;qfm&#x2F;qplayer&#x2F;settings 等⼀些应⽤程序。- buildroot： 基于 buildroot (2018.02-rc3) 开发的根⽂件系统。- debian： 基于debian 10 开发的根⽂件系统，⽀持部分芯⽚。- device&#x2F;rockchip： 存放各芯⽚板级配置和Parameter⽂件，以及⼀些编译与打包固件的脚本和预备⽂件。- IMAGE： 存放每次⽣成编译时间、XML、补丁和固件⽬录。- external： 存放第三⽅相关仓库,包括⾳频、视频、⽹络、recovery 等。- kernel： 存放 kernel 4.4 或 4.19 开发的代码。- prebuilts： 存放交叉编译⼯具链。- rkbin： 存放 Rockchip 相关的 Binary 和⼯具。- rockdev： 存放编译输出固件。- tools： 存放 Linux 和 Windows 操作系统环境下常⽤⼯具。- u-boot：存放基于 v2017.09 版本进⾏开发的 uboot 代码。- yocto：基于 yocto gatesgarth 3.2 开发的根⽂件系统，⽀持部分芯⽚。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="编译环境配置"><a href="#编译环境配置" class="headerlink" title="编译环境配置"></a>编译环境配置</h3><p>编译Linux SDK需要安装下列库：（注意不是全部复制粘贴）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install git ssh make gcc libssl-dev liblz4-tool expect \g++ patchelf chrpath gawk texinfo chrpath diffstat binfmt-support \qemu-user-static live-build bison flex fakeroot cmake gcc-multilib \g++-multilib unzip device-tree-compiler ncurses-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>据说编译要很久, 对电脑内存, 硬盘都有要求</p><p>开始对SDK进行配置</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32单片机的定时器</title>
      <link href="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/"/>
      <url>/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="基本定时器框图"><a href="#基本定时器框图" class="headerlink" title="基本定时器框图"></a>基本定时器框图</h2><p>定时器的常用功能主要为<strong>定时中断</strong>, <strong>PWM生成</strong></p><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240316213946464.png" class="" title="image-20240316213946464"><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240316213942990.png" class="" title="image-20240316213942990"><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240316213952782.png" class="" title="image-20240316213952782"><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240316213956447.png" class="" title="image-20240316213956447"><h2 id="STM32时钟树"><a href="#STM32时钟树" class="headerlink" title="STM32时钟树"></a>STM32时钟树</h2><p>SystemInit()就是用来配置时钟树的,左边为时钟产生电路,右边为分配电路, 内部四个振荡源, 启动内部时钟, 暂时以内部8MHz为系统时钟,启动外部时钟,PLL锁相环9倍频到72MHz,锁相环稳定输出后切换系统时钟为72MHz</p><p>❗注意:</p><p>若外部晶振出现问题, css会把时钟切换到内部时钟,此时系统的时钟就慢了九倍</p><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240317081714282.png" class="" title="image-20240317081714282"><h2 id="定时中断模式"><a href="#定时中断模式" class="headerlink" title="定时中断模式"></a>定时中断模式</h2><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240316214042758.png" class="" title="image-20240316214042758"><p>这两个函数的区别</p><blockquote><ul><li><p><strong>TIM_TimeBaseInit</strong>是根据你设定的参数初始化时基单元</p></li><li><p><strong>TIM_TimeBaseStructInit</strong>是将每一个参数按默认参数初始化</p><ul><li>(即设置为预定义的默认值。这些默认值是根据STM32微控制器库的规定预设的，通常是为了确保定时器模块能以一个基本且稳定的配置开始工作，即使开发者没有显式设置所有的参数)。</li></ul></li></ul></blockquote><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240317075352159.png" class="" title="image-20240317075352159"><h3 id="TIM1-RepetitionCounter"><a href="#TIM1-RepetitionCounter" class="headerlink" title="TIM1_RepetitionCounter"></a>TIM1_RepetitionCounter</h3><p><code>TIM1_RepetitionCounter</code>设置涉及到STM32微控制器中高级定时器的一个特性，即重复计数器（Repetition Counter，简称RCR）。</p><p>这个计数器的作用是<strong>定义在定时器产生一个更新事件（通常是计时周期结束并重新开始的标志）之前, 计数器需要完成的计数周期数</strong>。换句话说，<em>RCR决定了定时器需要计数多少次才触发一次更新事件</em>。</p><h3 id="RCR的工作原理"><a href="#RCR的工作原理" class="headerlink" title="RCR的工作原理"></a>RCR的工作原理</h3><blockquote><p>当RCR设置为某个值N时，定时器的向下计数器会从N开始计数，每次到0时，产生一个更新事件，并且计数器重新从N开始计数。这样，更新事件的产生不再是每个计数周期结束时发生，而是每N+1个周期发生一次。</p></blockquote><p>设置为0时，表示每个周期结束都会产生更新事件，即没有重复计数的延迟。</p><h3 id="TIM-ClearFlag"><a href="#TIM-ClearFlag" class="headerlink" title="TIM_ ClearFlag"></a>TIM_ ClearFlag</h3><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240317080908937.png" class="" title="image-20240317080908937"><p>放在这里清除</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">TIM_ClearFlag(TIM2, TIM_FLAG_Update);                           TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为<strong>TIM_TimeBaseInit()初始化函数</strong>的末尾手动生成了一个更新事件,重新装在预分频器和重复计数器的值</p><blockquote><p>预分频器有缓冲寄存器,写入的值只有在更新事件时, 才会真正起作用,</p><p>这句代码手动生成了一个更新事件, 让预分频器的值立刻生效</p></blockquote><p>产生的问题:</p><ul><li>更新事件与更新中断几乎同时发生, <strong>更新中断会置中断标志位, 初始化结束后就会立刻进入中断</strong>, 所以在初始化之后, <strong>手动清除中断标志位</strong>就可以解决这个问题</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;* Generate an update event to reload the Prescaler and the Repetition counter   values immediately *&#x2F;TIMx-&gt;EGR &#x3D; TIM_PSCReloadMode_Immediate;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="ARR与PSC"><a href="#ARR与PSC" class="headerlink" title="ARR与PSC"></a>ARR与PSC</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">TIM_TimeBaseInitStructure.TIM_Period &#x3D; 10000-1;                &#x2F;&#x2F;自动重装载值 ARRTIM_TimeBaseInitStructure.TIM_Prescaler &#x3D; 7200-1;              &#x2F;&#x2F;预分频系数 PSC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ARR↑, PSC↓,以更快的速度计更多的数</p><p>也就是说ARR越大, 计数上限越大, 同时频率越高;PSC越小, 频率越高</p><blockquote><p>72MHz&#x2F;720&#x3D;0.1MHz  1&#x2F;0.1MHz&#x3D;10us 10us*10000&#x3D;0.1s计数一次</p><p>1&#x2F;((72MHz&#x2F;7200)*10000)&#x3D;1s</p></blockquote><h2 id="外部中断模式"><a href="#外部中断模式" class="headerlink" title="外部中断模式"></a>外部中断模式</h2><p>外部触发定时器计数, 与外部中断相似</p><h2 id="输出比较模式"><a href="#输出比较模式" class="headerlink" title="输出比较模式"></a>输出比较模式</h2><p>也就是PWM模式</p><p>PWM脉冲宽度调制, 实际上是通过开、关、开、关实现等效模拟量(只对有惯性作用的起作用,比如电机、LED等)</p><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240319113441437.png" class="" title="image-20240319113441437"><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240319113626758.png" class="" title="image-20240319113626758"><p>下图, 如果没有ccr, 就是正常的计数值到自动重装载值清零为一个周期</p><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240318114913262.png" class="" title="image-20240318114913262"><p>公式如下:</p><p>比如: </p><ul><li><p>要频率为10k, 那么72M&#x2F;(psc+1)&#x2F;100&#x3D;10k, 则psc+1&#x3D;72</p></li><li><p>占空比为50%, ccr&#x3D;50</p></li><li><p>分辨率为1%, 那么从后往前推arr+1&#x3D;100</p></li></ul><p>关于为什都是+1</p><p>因为计数器溢出不是65535溢出而是第65536时溢出, 所以实际上计数值要多1</p><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240319113356763.png" class="" title="image-20240319113356763"><h3 id="呼吸灯"><a href="#呼吸灯" class="headerlink" title="呼吸灯"></a>呼吸灯</h3><p>原理: 通过调节占空比, 改变LED亮灭时长, 人眼看上去就是呼吸灯的效果</p><p>出现BUG, 不知道为啥, 就是江协科技的代码烧进去正常使用, 复制到新的工程就不好使了</p><p>解决: </p><p>加上就没反应了,其实这里应该断点调试,但是我选择了一个一个对,后来发现就剩delay不一样了,换了之后也好了</p><p>还以为是delay出了问题,结果是<strong>我没初始化delay</strong>, 所以程序应该是卡住了</p><p>另外,频率不能太低否则会一直闪烁</p><h3 id="舵机控制"><a href="#舵机控制" class="headerlink" title="舵机控制"></a>舵机控制</h3><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240319113514350.png" class="" title="image-20240319113514350"><p><strong>角度占空比换算</strong></p><p>所以**(angle&#x2F;180<em>2+0.5)&#x2F;20*100</em>*, </p><blockquote><ul><li>角度映射成脉冲宽度 angle&#x2F;180*(2.5-0.5)</li><li>脉冲宽度&#x2F;20(周期)&#x3D;占空比</li><li>因为ccr&#x2F;arr&#x3D;占空比,故换算出此时的ccr</li></ul></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">❌TIM_SetCompare2(TIM2,((angle&#x2F;180)*2+0.5)&#x2F;20*100);  没错,这么算是正确的,公式复杂了一些   CCR &#x3D; (最小脉宽 + (angle&#x2F;180) * 脉宽范围) &#x2F; 定时器周期 * ARR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>pulse&#x3D;(180&#x2F;180)*(2.5-0.5)+0.5角度换算脉冲宽度</p><p>pulse&#x2F;20(周期)&#x3D;占空比&#x3D;0.125&#x3D;12.5%&#x2F;100(ARR)&#x3D;CCR</p></blockquote><p>简单想,就是把0<del>180对应到2.5</del>12.5</p><p>根据占空比为2.5%~12.5%</p><p>根据<strong>0.5&#x2F;20</strong><del><strong>2.5&#x2F;20</strong>&#x3D;<strong>2.5&#x2F;100</strong></del><strong>12.5&#x2F;100</strong>的对应关系,其实就是<strong>占空比</strong></p><p>✔️其实就是0.5~2.5ms&#x2F;20ms&#x3D;占空比(2.5%12.5%)  ARR&#x3D;100,那么对应占空比的CCR为2.5-12.5</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">TIM_SetCompare2(TIM2,angle&#x2F;180*10+2.5);           &#x2F;&#x2F;这个也没错,之前失效的原因是更改ARR后没有更改PSC,导致周期发生变化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>单位HZ对应s,即20ms的频率为1&#x2F;0.02&#x3D;50hz,即舵机频率为50HZ</p><p>那么<strong>Freq&#x3D;CK_PSC&#x2F;(PSC+1)&#x2F;(ARR+1)&#x3D;50HZ,</strong></p><p>找一个比较好计算的值,可以设置PSC为72,ARR为20000, 20k对应20ms,CCR&#x3D;500对应0.5ms</p><h3 id="驱动电机"><a href="#驱动电机" class="headerlink" title="驱动电机"></a>驱动电机</h3><p>电机的频率一般式<strong>5K~20KHZ</strong>,根据公式72&#x2F;(psc+1)&#x2F;(arr+1)&#x3D;20K</p><p>可令(psc+1)&#x3D;0, (arr+1)&#x3D;3600</p><h3 id="非PID控制电机位置"><a href="#非PID控制电机位置" class="headerlink" title="非PID控制电机位置"></a>非PID控制电机位置</h3><p>以前写的,忘了咋算,难道是试出来的</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Load(-800,1000);  &#x2F;&#x2F;0.73s一圈左右                               delay_ms(762);    &#x2F;&#x2F;但是没有达到,取三次脉冲平均值计算,有误差,但是误差变小了t2&#x3D;Read_Speed(2);t4&#x3D;Read_Speed(4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>72m&#x2F;7200&#x3D;10k,1560&#x2F;10k&#x2F;2&#x3D;760</p><p>我当时很有可能是通过<strong>实际测试固定占空比的脉冲数</strong>,然后<strong>1560除以脉冲数</strong>就得到了<strong>固定占空比转一圈</strong>的时间</p><h2 id="输入捕获模式"><a href="#输入捕获模式" class="headerlink" title="输入捕获模式"></a>输入捕获模式</h2><p>IC（Input Capture）输入捕获</p><blockquote><p>输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR中，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数每个高级定时器和通用定时器都拥有4个输入捕获通道</p><p>可配置为PWMI模式，同时测量频率和占空比可配合主从触发模式，实现硬件全自动测量</p></blockquote><p>ps: 电机振动可以发声</p><p><strong>测频方法</strong></p><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240319113335201.png" class="" title="image-20240319113335201"><p>标准频率Fc就是时钟&#x2F;预分频系数,就是定时器自增的频率</p><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240319113712211.png" class="" title="image-20240319113712211"><p><strong>主从触发模式</strong></p><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240319113804333.png" class="" title="image-20240319113804333"><p>🔺重点</p><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240319113836650.png" class="" title="image-20240319113836650"><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240319113852705.png" class="" title="image-20240319113852705"><h3 id="易错"><a href="#易错" class="headerlink" title="易错"></a>易错</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">void IC_Init(void)&#123;  &#x2F;&#x2F; 初始化RCC时钟配置  &#x2F;&#x2F;定时器时钟开启      &#x2F;&#x2F;输入比较引脚初始化  &#x2F;&#x2F;时基单元初始化      &#x2F;&#x2F;下面是输入捕获初始化  TIM_ICInitTypeDef TIM_ICInitStructure;  TIM_ICInitStructure.TIM_Channel &#x3D; TIM_Channel_1;  TIM_ICInitStructure.TIM_ICFilter &#x3D; 0xF;                       &#x2F;&#x2F;输入捕获滤波器配置  TIM_ICInitStructure.TIM_ICPolarity &#x3D; TIM_ICPolarity_Rising; &#x2F;&#x2F; 捕获信号的极性设置，这里设置为上升沿触发捕获  TIM_ICInitStructure.TIM_ICPrescaler &#x3D; TIM_ICPSC_DIV1;         &#x2F;&#x2F;输入捕获分频系数,这里选择  TIM_ICInitStructure.TIM_ICSelection &#x3D; TIM_ICSelection_DirectTI;  TIM_PWMIConfig(TIM3,&amp;TIM_ICInitStructure);                    &#x2F;&#x2F;PWMI交叉模式, 相当于下面配置,只有通道1、2能用 &#x2F;&#x2F; 手动配置通道2间接捕获模式    &#x2F;&#x2F;  TIM_ICInitStructure.TIM_Channel &#x3D; TIM_Channel_2;&#x2F;&#x2F;  TIM_ICInitStructure.TIM_ICFilter &#x3D; 0xF;&#x2F;&#x2F;  TIM_ICInitStructure.TIM_ICPolarity &#x3D; TIM_ICPolarity_Falling;&#x2F;&#x2F;  TIM_ICInitStructure.TIM_ICPrescaler &#x3D; TIM_ICPSC_DIV1;        &#x2F;&#x2F;  TIM_ICInitStructure.TIM_ICSelection &#x3D; TIM_ICSelection_IndirectTI;      &#x2F;&#x2F; 初始化定时器3的输入捕获功能  TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);                         &#x2F;&#x2F; 选择定时器3的输入触发源，这里选择的是TI1FP1（通道1的滤波后上升沿触发）  TIM_SelectInputTrigger(TIM3,TIM_TS_TI1FP1);                   &#x2F;&#x2F;选择输入触发源  &#x2F;&#x2F; 设置定时器3的从模式为重置模式，使定时器可以在触发输入时自动重置计数器,清零  TIM_SelectSlaveMode(TIM3,TIM_SlaveMode_Reset);               &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>DirectTI</strong></p><p> 表示 <strong>Direct Input Capture</strong>,直接输入捕获. 当设置为 <code>TIM_ICSelection_DirectTI</code> 时，意味着输入捕获通道（如 IC1, IC2, IC3, IC4）直接连接到相应的外部引脚（即 TI1, TI2, TI3, TI4）上</p><p><strong>TIM_ICSelection_IndirectTI</strong>置为间接捕获模式，IC2将从IC1的信号捕获，即使物理上连接到TI2</p><p>即实现了<strong>通道一捕获频率,通道2捕获占空比</strong>,IC2选择下降沿,是因为占空比&#x3D;高电平脉冲宽度&#x2F;周期</p><p><strong>频率获取函数</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">uint32_t IC_GetFreq(void)&#123; &#x2F;&#x2F;捕获的是CNT计数值,Freq&#x3D;1M&#x2F;Nreturn 1000000 &#x2F; (TIM_GetCapture1(TIM3) + 1); &#x2F;&#x2F;因为计数器从0开始计数,所以实际计数值&#x3D;N+1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>占空比计算函数</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">uint32_t IC_GetDuty(void)&#123;    &#x2F;&#x2F;占空比的结果是0~1的数,所以*100变成整数return (TIM_GetCapture2(TIM3)+1)*100&#x2F; (TIM_GetCapture1(TIM3)+1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整型除法会导致小数部分丢失，导致结果总是0。当0乘以100后，结果仍然是0,<strong>所以*100要放在前面</strong></p><p>🔺注意<strong>类型转换</strong>的问题,或者可以使用(float)强制类型转换,函数类型也换成float,也可以</p><h2 id="编码器模式"><a href="#编码器模式" class="headerlink" title="编码器模式"></a>编码器模式</h2><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240322140930096.png" class="" title="image-20240322140930096"><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240322145039480.png" class="" title="image-20240322145039480"><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240322145045852.png" class="" title="image-20240322145045852"><h3 id="编码器测速"><a href="#编码器测速" class="headerlink" title="编码器测速"></a>编码器测速</h3><p><strong>M法测速</strong><br>又叫做频率测量法,统计固定时间内的编码器脉冲数,M法适合测量高速。</p><p>假设：</p><p>编码器单圈总脉冲数为C（常数）</p><p>统计时间为T0</p><p> 该时间内统计到的编码器脉冲数为M 0 </p><p>则：转速n（圈&#x2F;秒）的计算公式为：</p><img src="/2024/03/16/98-stm32-dan-pian-ji-de-ding-shi-qi/image-20240323075808389.png" class="" title="image-20240323075808389"><p><strong>例:</strong></p><p>假如编码器线数为11,减速比为30</p><p>则电机转动一圈的脉冲数为11*30&#x3D;330</p><p>则速度为CNT&#x2F;(11*30)&#x2F;t&#x3D;单位时间转几圈</p><p><strong>脉冲控制电机速度</strong>,编码器读数</p><p>通过一秒几个脉冲,然后延时</p><p><a href="https://blog.csdn.net/hbsyaaa/article/details/113784920">编码器计数原理与电机测速原理</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32单片机的EXTI外部中断</title>
      <link href="/2024/03/12/97-stm32-dan-pian-ji-de-exti-wai-bu-zhong-duan/"/>
      <url>/2024/03/12/97-stm32-dan-pian-ji-de-exti-wai-bu-zhong-duan/</url>
      
        <content type="html"><![CDATA[<h2 id="EXTI外部中断"><a href="#EXTI外部中断" class="headerlink" title="EXTI外部中断"></a>EXTI外部中断</h2><blockquote><p>EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序</p><p>支持的触发方式：上升沿&#x2F;下降沿&#x2F;双边沿&#x2F;软件触发</p><p>支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发(也就是PA1、PB1、PC1不能同时触发,因为是同一个通道)</p><p>中断通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒触发响应方式：中断响应&#x2F;事件响应</p></blockquote><p>外部中断主要是硬件中断,也可以软件中断, 为了避免占用CPU资源, 所以<strong>外部中断会先由内部的NVIC进行供排序</strong>,然后告诉CPU要执行哪一个</p><img src="/2024/03/12/97-stm32-dan-pian-ji-de-exti-wai-bu-zhong-duan/image-20240312222748673.png" class="" title="image-20240312222748673"><img src="/2024/03/12/97-stm32-dan-pian-ji-de-exti-wai-bu-zhong-duan/image-20240312222319460.png" class="" title="image-20240312222319460"><p>NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队</p><table><thead><tr><th><strong>分组方式</strong></th><th><strong>抢占优先级</strong></th><th><strong>响应优先级</strong></th></tr></thead><tbody><tr><td>分组0</td><td>0位，取值为0</td><td>4位，取值为0~15</td></tr><tr><td>分组1</td><td>1位，取值为0~1</td><td>3位，取值为0~7</td></tr><tr><td>分组2</td><td>2位，取值为0~3</td><td>2位，取值为0~3</td></tr><tr><td>分组3</td><td>3位，取值为0~7</td><td>1位，取值为0~1</td></tr><tr><td>分组4</td><td>4位，取值为0~15</td><td>0位，取值为0</td></tr></tbody></table><img src="/2024/03/12/97-stm32-dan-pian-ji-de-exti-wai-bu-zhong-duan/image-20240312222647139.png" class="" title="image-20240312222647139"><p><strong>GPIO-&gt;AFIO-&gt;EXTI-&gt;NVIC</strong>(NVIC由内核管理,所以库函数在misc.h中)</p><p>STM32中断函数的名字固定,一个中断通道对应一个中断,在启动文件中</p><p><strong>按键不建议用外部中断,一位涉及到滤波延时问题, 所以最好选择定时器扫描的方式</strong></p><h2 id="AFIO复用IO口"><a href="#AFIO复用IO口" class="headerlink" title="AFIO复用IO口"></a>AFIO复用IO口</h2><p>AFIO主要用于<strong>引脚复用功能</strong>的选择和<strong>重定义</strong></p><p>在STM32中，AFIO主要完成两个任务：<strong>复用功能引脚重映射</strong>、<strong>中断引脚选择</strong></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>配置AFIO外部中断引脚选择</strong></p><p>这个函数在GPIO的库里</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource0); &#x2F;&#x2F;这两个必须分开写不可以用|GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource1); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h2><img src="/2024/03/12/97-stm32-dan-pian-ji-de-exti-wai-bu-zhong-duan/image-20240408085600577.png" class="" title="image-20240408085600577"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line)与ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)的区别</li></ol><p>检查指定的 EXTI 线路标志位设置与否</p><p>检查指定的 EXTI 线路触发请求发生与否</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32单片机的GPIO模式</title>
      <link href="/2024/03/12/96-stm32-dan-pian-ji-de-gpio-mo-shi/"/>
      <url>/2024/03/12/96-stm32-dan-pian-ji-de-gpio-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="GPIO模式"><a href="#GPIO模式" class="headerlink" title="GPIO模式"></a>GPIO模式</h2><table><thead><tr><th align="left">#模式</th><th align="center">性质</th><th align="center">特征</th></tr></thead><tbody><tr><td align="left">浮空输入</td><td align="center">数字输入</td><td align="center">可读取引脚电平，若引脚悬空，则电平不确定</td></tr><tr><td align="left">上拉输入</td><td align="center">数字输入</td><td align="center">可读取引脚电平，内部连接上拉电阻，悬空时默认高电平</td></tr><tr><td align="left">下拉输入</td><td align="center">数字输入</td><td align="center">可读取引脚电平，内部连接下拉电阻，悬空时默认低电平</td></tr><tr><td align="left">模拟输入</td><td align="center">数字输入</td><td align="center">GPIO无效，引脚直接接入内部ADC</td></tr><tr><td align="left">开漏输出</td><td align="center">数字输出</td><td align="center">可输出引脚电平，高电平为高阻态，低电平接VSS</td></tr><tr><td align="left">推挽输出</td><td align="center">数字输出</td><td align="center">可输出引脚电平，高电平接VDD，低电平接VSS</td></tr><tr><td align="left">复用开漏输出</td><td align="center">数字输出</td><td align="center">由片上外设控制，高电平为高阻态，低电平接VSS</td></tr><tr><td align="left">复用推挽输出</td><td align="center">数字输出</td><td align="center">由片上外设控制，高电平接VDD，低电平接VSS</td></tr></tbody></table><img src="/2024/03/12/96-stm32-dan-pian-ji-de-gpio-mo-shi/image-20240312221330040.png" class="" title="image-20240312221330040"><img src="/2024/03/12/96-stm32-dan-pian-ji-de-gpio-mo-shi/image-20240312221408936.png" class="" title="image-20240312221408936"><img src="/2024/03/12/96-stm32-dan-pian-ji-de-gpio-mo-shi/image-20240312221509337.png" class="" title="image-20240312221509337"><p>注意:原英文手册是施密特触发器</p><p>可以进行滤波,只有高于上限, 低于下限时, 才会进行信号翻转</p><img src="/2024/03/12/96-stm32-dan-pian-ji-de-gpio-mo-shi/image-20240312221941592.png" class="" title="image-20240312221941592"><img src="/2024/03/12/96-stm32-dan-pian-ji-de-gpio-mo-shi/image-20240312221527981.png" class="" title="image-20240312221527981"><img src="/2024/03/12/96-stm32-dan-pian-ji-de-gpio-mo-shi/image-20240312221623316.png" class="" title="image-20240312221623316"><img src="/2024/03/12/96-stm32-dan-pian-ji-de-gpio-mo-shi/image-20240312221627066.png" class="" title="image-20240312221627066"><p>(1) VDD_FT 对5伏容忍I&#x2F;O脚是特殊的，它与VDD不同</p><h2 id="C语言相关知识"><a href="#C语言相关知识" class="headerlink" title="C语言相关知识"></a>C语言相关知识</h2><ul><li><p>关键字：<strong>#define</strong></p></li><li><p>用途：用一个字符串代替一个数字，便于理解，防止出错；提取程序中经常出现的参数，便于快速修改定义宏</p></li><li><p>定义：#define ABC 12345</p></li><li><p>引用宏定义：int a &#x3D; ABC;&#x2F;&#x2F;等效于int a &#x3D; 12345;</p></li><li><p>关键字：<strong>typedef</strong></p></li><li><p>用途：将一个比较长的变量类型名换个名字，便于使用</p></li><li><p>定义typedef：typedef unsigned char <code>uint8_t</code>;</p></li><li><p>引用typedef：uint8_t a;&#x2F;&#x2F;等效于unsigned char a;</p></li><li><p>关键字：<strong>struct</strong></p></li><li><p>用途：数据打包，不同类型变量的集合</p></li><li><p>定义结构体变量：struct{char x; int y; float z;} StructName;因为结构体变量类型较长，所以通常用typedef更改变量类型名</p></li><li><p>引用结构体成员：StructName.x &#x3D; ‘A’;</p><p>​                                 StructName.y &#x3D; 66;    </p><p>​                                 StructName.z &#x3D; 1.23;</p><p>​                                <code>pStructName-&gt;x = &#39;A&#39;;</code>    &#x2F;&#x2F;pStructName为结构体的地址，pStructName-&gt;y &#x3D; 66;pStructName-&gt;z &#x3D; 1.23;</p></li><li><p>关键字：<strong>enum</strong></p></li><li><p>用途：定义一个取值受限制的整型变量，用于限制变量取值范围；宏定义的集合(<strong>即变量只能为enum中定义的</strong>)</p></li><li><p>定义枚举变量：enum{</p><p>​                                            FALSE &#x3D; 0, </p><p>​                                            TRUE &#x3D; 1</p><p>​                                        } EnumName;    </p><p>因为枚举变量类型较长，所以通常用typedef更改变量类型名</p></li><li><p>引用枚举成员：EnumName &#x3D; FALSE;EnumName &#x3D; TRUE;</p></li></ul><h2 id="🔥C语言数据类型"><a href="#🔥C语言数据类型" class="headerlink" title="🔥C语言数据类型"></a>🔥C语言数据类型</h2><p>这部分很重要,<strong>经常会出现由于变量类型不对,导致测出的数据错误</strong>,常用<code>char</code>与<code>unsigned char</code></p><table><thead><tr><th><strong>关键字</strong></th><th><strong>位数</strong></th><th><strong>表示范围</strong></th><th><strong>stdint****关键字</strong></th><th><strong>ST****关键字</strong></th></tr></thead><tbody><tr><td>char</td><td>8</td><td>-128 ~ 127</td><td>int8_t</td><td>s8</td></tr><tr><td>unsigned char</td><td>8</td><td>0 ~ 255</td><td>uint8_t</td><td>u8</td></tr><tr><td>short</td><td>16</td><td>-32768 ~ 32767</td><td>int16_t</td><td>s16</td></tr><tr><td>unsigned short</td><td>16</td><td>0 ~ 65535</td><td>uint16_t</td><td>u16</td></tr><tr><td>int</td><td>32</td><td>-2147483648 ~ 2147483647</td><td>int32_t</td><td>s32</td></tr><tr><td>unsigned int</td><td>32</td><td>0 ~ 4294967295</td><td>uint32_t</td><td>u32</td></tr><tr><td>long</td><td>32</td><td>-2147483648 ~ 2147483647</td><td></td><td></td></tr><tr><td>unsigned long</td><td>32</td><td>0 ~ 4294967295</td><td></td><td></td></tr><tr><td>long long</td><td>64</td><td>-(2^64)&#x2F;2 ~ (2^64)&#x2F;2-1</td><td>int64_t</td><td></td></tr><tr><td>unsigned long long</td><td>64</td><td>0 ~ (2^64)-1</td><td>uint64_t</td><td></td></tr><tr><td>float</td><td>32</td><td>-3.4e38 ~ 3.4e38</td><td></td><td></td></tr><tr><td>double</td><td>64</td><td>-1.7e308 ~ 1.7e308</td><td></td><td></td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[<a href="https://www.bilibili.com/video/BV1th411z7sn?p=5&vd_source=e33ad22b3d91cb180bef532ce5877b2e">3-1] 江协科技_GPIO输出_</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于涡流悬浮的磁悬浮小车</title>
      <link href="/2024/03/10/95-wo-liu-xuan-fu-xiao-che/"/>
      <url>/2024/03/10/95-wo-liu-xuan-fu-xiao-che/</url>
      
        <content type="html"><![CDATA[<h2 id="电磁学基础"><a href="#电磁学基础" class="headerlink" title="电磁学基础"></a>电磁学基础</h2><p>它是利用常导电磁体中励磁电流产生的磁场与非磁性金属导体中感应涡流之间的排斥力来实现被悬浮体的稳定悬浮。非磁性金属导体中感应涡流产生的条件有两种，分别为：常导电磁体中通入的电流发生变化和常导电磁体与非磁性金属导体之间存在着相对运动。这种悬浮方式的实例如涡流型磁悬浮轴承及各种常导电动式磁悬浮装置等。</p><p><a href="https://zhuanlan.zhihu.com/p/455285594">涡流效应：产生的原因及涡流效应的利弊与控制 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/455279019">【高中•物理】有关左右手的定则总结 - 知乎 (zhihu.com)</a></p><h2 id="悬浮基本原理"><a href="#悬浮基本原理" class="headerlink" title="悬浮基本原理"></a>悬浮基本原理</h2><p>导体周围磁场变化会使导体产生感应电流,感应电流会产生感应磁场,感应磁场与原磁场相互作用</p><h3 id="海尔贝克阵列的具体排列方法"><a href="#海尔贝克阵列的具体排列方法" class="headerlink" title="海尔贝克阵列的具体排列方法"></a>海尔贝克阵列的具体排列方法</h3><p>使用10x10x10mm的钕铁硼磁铁来构建海尔贝克阵列，关键在于磁铁的磁化方向。海尔贝克阵列的特点是磁场在阵列的一侧被增强，而在另一侧几乎被取消。这是通过特定的磁化方向排列实现的：</p><ol><li><strong>序列和方向</strong>：海尔贝克阵列通常需要按照一定的序列排列磁铁，每个磁铁的磁化方向与其旁边的磁铁有一定的角度差。通常，这个角度差是连续变化的，比如每相邻两个磁铁之间磁化方向的角度差为45度。</li><li><strong>实例排列</strong>：对于10x10x10mm的钕铁硼磁铁，假设我们排列一个最简单的环形阵列。第一个磁铁指北（N）向上，第二个磁铁顺时针旋转45度，即其N极指向外侧和上方的对角线方向，第三个磁铁N极顺时针旋转90度，指向外侧，依此类推，直到完成一个360度的圆环。</li><li><strong>制作提示</strong>：实际操作中，需要使用精密的工具和仪器来确保每个磁铁的磁化方向准确无误。此外，制作过程中要小心，因为强磁相互作用可能导致损伤或不必要的困扰。</li></ol><p>下图每相邻两个磁铁之间磁化方向角度差为90度</p><img src="/2024/03/10/95-wo-liu-xuan-fu-xiao-che/image-20240314073509221.png" class="" title="image-20240314073509221"><img src="/2024/03/10/95-wo-liu-xuan-fu-xiao-che/image-20240314073509221-17115463325691.png" class="" title="image-20240314073509221"><img src="/2024/03/10/95-wo-liu-xuan-fu-xiao-che/image-20240327225454684.png" class="" title="image-20240327225454684"><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><img src="/2024/03/10/95-wo-liu-xuan-fu-xiao-che/image-20240329102557122.png" class="" title="image-20240329102557122"><h2 id="物料选择"><a href="#物料选择" class="headerlink" title="物料选择"></a>物料选择</h2><ul><li><p>导体板不需要太厚。为了使轨道导体中的感应电流达到最大，优先选择电阻率小的导体板状阵列(厚铝板可以和薄铜板)</p></li><li><p>大扭矩、高转速且重量轻的电机   (142g)</p></li><li><p>环状的 Halbach 磁体阵列</p></li><li><p>小车上存在电磁干扰，干扰源有：永磁体的磁场，电机运转时</p><p>产生的电火花带来的电磁波，涡流产生的感应磁场，为了</p><p>解决无线电遥控偶尔失灵的问题，本设计使用了长度偏长</p><p>的电控板天线，并在电机上并联了消火花电容</p></li><li><img src="/2024/03/10/95-wo-liu-xuan-fu-xiao-che/image-20240312211446910.png" class="" title="image-20240312211446910"></li></ul><h3 id="RCT6外设"><a href="#RCT6外设" class="headerlink" title="RCT6外设"></a>RCT6外设</h3><img src="/2024/03/10/95-wo-liu-xuan-fu-xiao-che/image-20240404162744572.png" class="" title="image-20240404162744572"><h3 id="引脚分配"><a href="#引脚分配" class="headerlink" title="引脚分配"></a>引脚分配</h3><table><thead><tr><th align="center">外设</th><th align="center">说明</th><th align="center">引脚</th></tr></thead><tbody><tr><td align="center">PWM</td><td align="center">TIM1(高级)_CH1,CH4</td><td align="center">PA8,PA11</td></tr><tr><td align="center"></td><td align="center">TIM8_CH1,TIM8_CH2,TIM8_CH3,TIM8_CH4,</td><td align="center">PC6,PC7,PC8,PC9</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">TIM3_CH1,TIM3_CH2,TIM4_CH3,TIM4_CH4</td><td align="center">PA6,PA7 ,PB8,PB9</td></tr><tr><td align="center"></td><td align="center">TIM5</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">有刷电机Motor</td><td align="center">电机IO</td><td align="center">PB12,PB13.PB14,PB15</td></tr><tr><td align="center">空心杯电机</td><td align="center">电机IO</td><td align="center">PD2,PD3,PD4,PD5(PC4,PC5)</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Encoder:</td><td align="center">TIM2_CH1_ETR,TIM2_CH2</td><td align="center">(PA15)PA0,PA1</td></tr><tr><td align="center"></td><td align="center">TIM4_CH1,TIM4_CH2</td><td align="center">PB6,PB7</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">定时器</td><td align="center">TIM6,TIM7</td><td align="center"></td></tr><tr><td align="center">OLED</td><td align="center"></td><td align="center">A15、B3、B4、B5</td></tr><tr><td align="center">MAX30102</td><td align="center"></td><td align="center">PB10,PB11</td></tr><tr><td align="center">HC-SR04超声波</td><td align="center">TIM3_CH1,TIM3_CH2</td><td align="center">(PA6,PA7)PB0,PB1</td></tr><tr><td align="center">KEY</td><td align="center"></td><td align="center">PC0,PC1,PC2,</td></tr></tbody></table><p>Motor:<br>KEY:PB1,PB11</p><h3 id="硬件pcb"><a href="#硬件pcb" class="headerlink" title="硬件pcb"></a>硬件pcb</h3><img src="/2024/03/10/95-wo-liu-xuan-fu-xiao-che/%E7%A3%81%E6%82%AC%E6%B5%AE%E4%B8%BB%E6%8E%A7%E6%9D%BFPCB_8858.png" class="" title="磁悬浮主控板PCB_8858"><p>新的心得体会</p><p><strong>不要死抠细节</strong>, 边做边检查,保证效率</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>545、550、350电机均不行,均会被抑制转动</p><p><strong>4250无刷电机</strong></p><p><strong>驱动原理</strong></p><p><strong>stm32驱动</strong></p><p><strong>供电</strong></p><p><strong>集成板</strong></p><p><strong>电源分线板</strong></p><p>一个电池需要给多个电调及主控板供电,所以需要电源分线板</p><p><strong>电池转换头</strong></p><p>XT头转T头</p><p>AWG（American Wire Gauge）是一种美国常用的电线尺寸标准，用于衡量电线的直径大小。AWG值越小，电线的直径就越大；相应地，电线的横截面积就越大，能够承载的电流就越多。这个标准不仅应用于裸电线，也适用于绝缘电线。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当供电3.5v,磁轮距离5mm铝板10mm时,磁轮旋转被抑制,距离铝底板越近,转速越慢,并且导线发热</p><p>你遇到的现象可以从涡电流和磁阻力的角度来解释，这些现象体现了磁场与导体相互作用的物理原理。让我们详细分析一下：</p><h3 id="1-磁轮旋转被抑制的原因"><a href="#1-磁轮旋转被抑制的原因" class="headerlink" title="1. 磁轮旋转被抑制的原因"></a>1. 磁轮旋转被抑制的原因</h3><p>当磁轮靠近铝板时，磁轮上的磁铁产生变化的磁场。由于铝是一种良好的导体，这个变化的磁场会在铝板中产生涡电流。根据法拉第电磁感应定律，这些电流产生的磁场与原始磁场相反，从而对磁轮产生一个反向的力——这就是所谓的磁阻力。这种力量足以减缓磁轮的旋转速度，尤其是当磁轮与铝板的距离减小时，这种效应会变得更加显著。</p><h3 id="2-距离铝板越近，转速越慢的原因"><a href="#2-距离铝板越近，转速越慢的原因" class="headerlink" title="2. 距离铝板越近，转速越慢的原因"></a>2. 距离铝板越近，转速越慢的原因</h3><p>当磁轮距离铝板更近时，磁场的变化在铝板中产生的涡电流会增加，因为磁场强度的变化更大。这会导致更强的涡电流产生，进一步增加了磁阻力，从而使得磁轮的旋转速度进一步减慢。这是因为涡电流产生的反作用磁场与磁轮的磁场相互作用，产生的力越来越大。</p><h3 id="3-导线发热的原因"><a href="#3-导线发热的原因" class="headerlink" title="3. 导线发热的原因"></a>3. 导线发热的原因</h3><p>电机和导线发热主要是由于电流的流动造成的。当磁轮旋转受到抑制时，电机需要消耗更多的功率来克服增加的阻力并尝试维持旋转。这会导致电流增加，进而导致导线中的电阻损耗（即焦耳热）增加，表现为导线发热。这是电能转化为热能的直接结果。</p><h3 id="如何改进"><a href="#如何改进" class="headerlink" title="如何改进"></a>如何改进</h3><ul><li><strong>降低阻力</strong>：可以通过增加磁轮与铝板之间的距离来减少涡电流的产生，从而减少磁阻力，帮助提高磁轮的旋转速度。</li><li><strong>优化供电</strong>：考虑调整电源的电压或电流，以找到一个平衡点，在保证磁轮有足够的转速的同时，减少导线的发热。可能需要通过实验来找到这个平衡点。</li><li><strong>改善散热</strong>：如果导线发热是不可避免的，考虑使用散热片或其他散热方法来帮助导线散热，以防过热损坏电机或导线。</li><li><strong>使用电机驱动控制器</strong>：使用适当的电机驱动控制器可能有助于更精确地控制电机的功率输出，以及更有效地管理电机的热量产生。</li></ul><p>通过这些方法，你可以尝试优化实验设置，以减少不希望的副作用，如磁轮旋转速度减慢和导线发热，进而更接近于实现磁性悬浮的目标。</p><h3 id="结项图片"><a href="#结项图片" class="headerlink" title="结项图片"></a>结项图片</h3><img src="/2024/03/10/95-wo-liu-xuan-fu-xiao-che/image-20240330203912213.png" class="" title="image-20240330203912213"><img src="/2024/03/10/95-wo-liu-xuan-fu-xiao-che/image-20240330204004114.png" class="" title="image-20240330204004114"><img src="/2024/03/10/95-wo-liu-xuan-fu-xiao-che/image-20240330204031440.png" class="" title="image-20240330204031440"><img src="/2024/03/10/95-wo-liu-xuan-fu-xiao-che/image-20240330204142067.png" class="" title="image-20240330204142067">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Word论文的食用方法</title>
      <link href="/2024/03/10/94-word-lun-wen-de-shi-yong-fang-fa/"/>
      <url>/2024/03/10/94-word-lun-wen-de-shi-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="关于公式加编号"><a href="#关于公式加编号" class="headerlink" title="关于公式加编号"></a>关于公式加编号</h2><p><strong>标尺</strong></p><p>公式左侧标尺20 字符3.27 </p><p>公式编号左侧标尺41</p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p><strong>如何给文档尾部空格添加下划线？</strong></p><p>使用WPS Office打开文档，选中文档尾部空格，点击“开始”—&gt;“下划线”无法添加下划线。</p><p>这时点击左上角“文件”，下拉菜单点击“选项”，选择“常规与保存”。</p><p>在“兼容性选项”中勾选“为尾部空格添加下划线”即可显示文档尾部下划线。</p><p><a href="https://www.wps.cn/learning/question/detail/id/1587.html">如何给文档尾部空格添加下划线？-WPS学堂</a></p><h2 id="公式转化"><a href="#公式转化" class="headerlink" title="公式转化"></a>公式转化</h2><p>某宝购买<strong>mathpix</strong>账号, 可以直接PDF转word, 很好用, 唯一的不足之处, 公式无法自动编号</p><p>[官网](<a href="https://snip.mathpix.com/home">Home - Snip Web (mathpix.com)</a>)</p><h2 id="外文翻译"><a href="#外文翻译" class="headerlink" title="外文翻译"></a>外文翻译</h2><p>选择知网搜索关键字, 选取论文, google学术下载即可, Chatgpt翻译</p><p><strong>除去准确度chatgpt并没有直接翻译快</strong></p><p>一般最好的办法是用<strong>mathpix</strong>来pdf转word,然后翻译,这样格式也不用改很快</p><p>公式和特殊符号都是无法翻译的</p><p>所以<strong>外文翻译</strong>的流程</p><p>mathpix-&gt;翻译(<strong>最快</strong>)</p><h2 id="文献综述"><a href="#文献综述" class="headerlink" title="文献综述"></a>文献综述</h2><p>基本上就是某个文献的谁干啥了,在摘要、研究背景、总结中去复制粘贴就行, 格式就像这样<code>&quot;陈晗（2019）[1]在其研究中探讨了基于给定关键点的6-DOF机械臂轨迹规划的问题... ...&quot;</code></p><h2 id="关于大创论文"><a href="#关于大创论文" class="headerlink" title="关于大创论文"></a>关于大创论文</h2><p>水的一篇《磁悬浮技术在应急救援系统中的设计与应用》,主要是流程图、公式、电路图、引用</p><p>即使我根本就不知道怎么做, 确实有人的论文是不水的, 加油</p><h2 id="参考文献引用"><a href="#参考文献引用" class="headerlink" title="参考文献引用"></a>参考文献引用</h2><img src="/2024/03/10/94-word-lun-wen-de-shi-yong-fang-fa/image-20240602174942203.png" class="" title="image-20240602174942203"><img src="/2024/03/10/94-word-lun-wen-de-shi-yong-fang-fa/image-20240602175032199.png" class="" title="image-20240602175032199"><p>按住ctrl，点击可跳到参考文献</p><p>另外，知网的引号<code>&quot;</code>可以直接复制引用格式</p><h2 id="期刊发表的注意事项"><a href="#期刊发表的注意事项" class="headerlink" title="期刊发表的注意事项"></a>期刊发表的注意事项</h2><p>不能一稿多投，一次智能投一个，人家拒绝你了或者长时间没回复才能投给其他的，回复了再投就算一稿多投了</p><p>知网可下载封面目录版权页，学校提交材料会需要</p><img src="/2024/03/10/94-word-lun-wen-de-shi-yong-fang-fa/image-20240604111421856.png" class="" title="image-20240604111421856"><p>版权页与目录</p><img src="/2024/03/10/94-word-lun-wen-de-shi-yong-fang-fa/image-20240604111738201.png" class="" title="image-20240604111738201"><h2 id="关于第一版毕业论文的问题"><a href="#关于第一版毕业论文的问题" class="headerlink" title="关于第一版毕业论文的问题"></a>关于第一版毕业论文的问题</h2><ol><li><p>首先是跑题，题目重点内容只有一页，而且没有图片没有代码</p></li><li><p>只有pid那里有程序，其他的地方都没写，要描述程序</p></li><li><p>卡尔曼滤波不会，但是写到摘要里面了，会被问</p></li><li><p>写出来的东西不相关，章与章之间没有联系</p></li></ol><h2 id="流程图自动生成"><a href="#流程图自动生成" class="headerlink" title="流程图自动生成"></a>流程图自动生成</h2><blockquote><p>gpt+<a href="https://mermaid.live/edit#pako:eNpNks9O20AQxl_FmrMTOU5sbB8qFcK_QNpD4VKbg4UNiUTsyLUlqBOph1AlDdC0pJRCqx5KSy41EUKAAuRpvOty6it02SXQ2878Zr75VjMhLLuWDRqsema1xC3kDeepjjon6F0PDbpJt7fEpVJPuHEdNb-h4zba2lucXTKccZqdeMzGl6fo_Q9CJijJ63-iYXIT4a3W7ccoHrTjq3MC8xROjgZEB_jzOfrSI2SSkqmQ6eDWLrp-8_f6e91wpu5IDXV-1bhpPfndQsNNYgs3L_DudnzzlfRO0woyKr5sP3_GRta4GZ2pPDiboSNmdXx4hvf69BtMG--f1LjCvTb-1MfbEd75ibt3jgu0aS5kCdTsM86szT1aK4wiKjavo6NG0nn70JUcNFgjkZynksV7H8nhB7xzjPeHydGAwCKFRA14qNhexSxbZDmh4XCcAX7JrtgGaORp2StmsOYbYDh1UmoGvvtiw1kGzfcCmwfPDVZLoK2Ya69IFFQt07fzZZMsuTIqqZrOS9f9PwQthHXQspmxdDajCIIqCVlRkWWJhw3QUpKQzqgkqapjqihKYrbOw2uqIKQVWZVzoqwoOSknZwSVB9sq-65XZMdFb6z-DzUWEu4">Online FlowChart &amp; Diagrams Editor - Mermaid Live Editor</a></p></blockquote><img src="/2024/03/10/94-word-lun-wen-de-shi-yong-fang-fa/image-20240609092001851.png" class="" title="image-20240609092001851"><p>然后平面捕获截图，大概250%清晰度导入word的清晰度较好，太大盒太小都不行</p><p>设计为几部分，mainwindow、widget容器，pushbtton，label，颜色、大小</p><p>使用什么什么库，然后代码，怎么做的实现，控制动作，通讯协议，数据帧，解析命令，函数接口，流程图，命令，点击按钮时会发生什么，如何接收的，检测状态，</p><p>软件包括的子功能</p><p>控制软件应该有什么功能，现在实现了demo，写出来的论文更理想化，更完善，上位机，与下位机，现成的，主要写蓝牙通信，通过返回的状态，进行什么动作，防撞，小于10cm，就不走了，防撞，现在做的只是一个demo，未来还要做什么什么完善，通信，命令接受，解析，在这些功能智商，摘要先写两句背景，逻辑，流程</p><p>开发什么驱动，什么驱动，然后kaifapid ，然后设定值，期望值是什么，为了pid是不是做了pid外围的工作</p><p>动作，防撞，避障，右面有豁口就往右转，路径规划，模型，方案 框架，结构</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于51单片机蜂鸣器的音乐播放器</title>
      <link href="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/"/>
      <url>/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h2><p>有源蜂鸣器:自带晶振,通电即可发声</p><p>无源蜂鸣器:无晶振,需要发送脉冲才可发声</p><ul><li>那么什么是脉冲,脉冲就是高低电平,一组高低电平为一个脉冲</li><li><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240306101606002.png" class="" title="image-20240306101606002"></li></ul><p>使用的51单片机的蜂鸣器接在步进电机的驱动上,如下方原理图</p><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240306103904701.png" class="" title="image-20240306103904701"><h2 id="ULN2003芯片"><a href="#ULN2003芯片" class="headerlink" title="ULN2003芯片"></a>ULN2003芯片</h2><ul><li><p>ULN2003 是高耐压、大电流达林顿陈列，由七个硅 NPN 达林顿管组成。</p></li><li><p>该电路的特点如下：<code>ULN2003 的每一对达林顿都串联一个 2.7K 的基极电阻,在 5V 的工作电压下它能与 TTL 和 CMOS 电路直接相连，可以直接处理原先需要标准逻辑缓冲器来处理的数据</code>。</p></li><li><p>ULN2003 工作电压高，工作电流大，灌电流可达 500mA，并且能够在关态时承受 50V 的电压，输出还可以在高负载电流并行运行。ULN2003 采用 DIP—16 或 SOP—16 塑料封装。</p></li></ul><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240306104256195.png" class="" title="image-20240306104256195"><p>内部是两个达林顿管</p><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240306105010881.png" class="" title="image-20240306105010881"><p>根据电路图,当输入1,经过非门,蜂鸣器导通</p><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240306105046915.png" class="" title="image-20240306105046915"><h2 id="buzzer发声驱动"><a href="#buzzer发声驱动" class="headerlink" title="buzzer发声驱动"></a>buzzer发声驱动</h2><p>错误写法: 这个是有源蜂鸣器的写法, 相当于发了一个脉冲。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void Buzzer_Beep(void)&#123;  Buzzer&#x3D;0;  Delay_ms(500);  Buzzer&#x3D;1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确写法: 应该持续发送脉冲</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void Buzzer_Beep(void)&#123;  unsigned i &#x3D;0;  for(i&#x3D;0;i&lt;50;i++) &#x2F;&#x2F;频率&#x3D;1&#x2F;周期ms  &#123;    Buzzer&#x3D;!Buzzer;    Delay_ms(2.5);   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="buzzer演奏音乐"><a href="#buzzer演奏音乐" class="headerlink" title="buzzer演奏音乐"></a>buzzer演奏音乐</h2><h3 id="乐理"><a href="#乐理" class="headerlink" title="乐理"></a>乐理</h3><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240306083044454.png" class="" title="image-20240306083044454"><p>分为四组,相邻两组之间相同音相差八度, 左低右高</p><ul><li>从上面看相邻键之间差半音, 看简谱数字上方一点升八度,下方一点降八度</li><li>左<strong>b</strong> 降半音,  **#**升半音</li><li>1 <code> -</code>表示1占两个拍子</li></ul><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240306084303184.png" class="" title="image-20240306084303184"><p>全音符 半音符 四分音符 八分音符 十六分音符 三十二分音符</p><p>以四分音符为基准,数字下加_,将音符半分(时间上)</p><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240306084609695.png" class="" title="image-20240306084609695"><ul><li><p>1&#x3D;D4&#x2F;4</p></li><li><p>以D调四分音符为一拍,每小结有四拍, C调的话是全白键</p></li><li><p>附点:1·,表示延长原来音符的1&#x2F;2</p></li><li><p>延音,按住不放</p></li></ul><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240306093612791.png" class="" title="image-20240306093612791"><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240306094658697.png" class="" title="image-20240306094658697"><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240306100742520.png" class="" title="image-20240306100742520"><p>以a为基准到a1相隔12个音符, 频率为2倍关系, 中间成等比数列关系</p><p>b的频率公式为440*2^1&#x2F;12</p><p><strong>周期&#x3D;1&#x2F;频率</strong>(hz&#x2F;s)</p><p>51单片机机器周期是振荡周期的1&#x2F;12, 机器周期为1M, 一个机器周期1um计数值+1。</p><p>IO口翻转两次,上升一次, 下降一次才是一个周期, 翻转一次的频率则为1&#x2F;2。</p><p>round(c2,0)取整</p><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240306101606002-17099426046991.png" class="" title="image-20240306101606002"><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240306094741247.png" class="" title="image-20240306094741247"><h3 id="关于定时器部分的复习"><a href="#关于定时器部分的复习" class="headerlink" title="关于定时器部分的复习"></a>关于定时器部分的复习</h3><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>例如, 音符1的振荡频率是262, 则振荡周期为 1&#x2F;262*1000 000&#x3D;3816us, 因为io翻转两次为1个周期, 所以定时器进入中断两次,为蜂鸣器的一个周期, 故定时器的周期为1908us,那么为什么重装载值为65535-1908呢</p><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240307223243780.png" class="" title="image-20240307223243780"><p><strong>公式：（2^n－初值）×（12*1÷ 晶振频率）&#x3D; 定时时间</strong>(1&#x2F;12是<strong>振荡周期</strong>,而51单片机的一个机器周期为12个振荡周期故为12*1&#x2F;晶振频率)</p><p><strong>n：定时器位数</strong> ，由定时器模式进行决定；<strong>时钟周期 &#x3D; 1 &#x2F; 晶振频率</strong>；<strong>机械周期 &#x3D; 12 × 时钟周期 &#x3D; 12 &#x2F; 晶振频率</strong>，如果这里认定晶振频率为12MHz，那么对应的机械周期就是12&#x2F;12MHz&#x3D;1us。那么进而可以得到上述公式的变形：</p><p><strong>答案</strong> :<strong>初值 &#x3D; 2^n - 定时时间，单位均为us。</strong></p><p>[](<a href="https://zhuanlan.zhihu.com/p/661574136">51单片机之定时器&amp;中断的应用 - 知乎 (zhihu.com)</a>)</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p><strong>不太理解这部分代码</strong>,FreqSelect500ms 加一次,但是为什么定时器中断也是500ms 进入一次呢,</p><img src="/2024/03/06/92-ji-yu-51-dan-pian-ji-feng-ming-qi-de-yin-le-bo-fang-qi/image-20240307222426689.png" class="" title="image-20240307222426689"><p>51单片机的机器周期是振荡周期的1&#x2F;12(11.0592), 12*1&#x2F;12</p><p>晶振频率为 12MHz，即 12百万 次每秒。</p><ol><li>对于 12MHz 晶振频率：<ul><li>一个晶振周期的时间为 1 &#x2F; 12MHz &#x3D; 0.08333 微秒（或者 83.33 纳秒）</li><li>一个机器周期为 12 个晶振周期，因此一个机器周期的时间为 12 * 0.08333 微秒 &#x3D; 1 微秒。</li></ul></li></ol><p>因此，在 12MHz 晶振频率下，一个晶振周期内包含 1 个机器周期。</p><p>对于 11.0592MHz 晶振频率，同样的计算方式：</p><ul><li>一个晶振周期的时间为 1 &#x2F; 11.0592MHz &#x3D; 0.09035 微秒（或者 90.35 纳秒）</li><li>一个机器周期为 12 个晶振周期，因此一个机器周期的时间为 12 * 0.09035 微秒 ≈ 1.0842 微秒。</li></ul><p>因此，在 11.0592MHz 晶振频率下，一个晶振周期内也包含大约 1 个机器周期。</p><p>Hz对应s：</p><p>振荡周期与机器周期不同。机器周期是单片机执行一条指令所需的时间，而振荡周期是晶振器振荡一个完整周期所需的时间。</p><h2 id="内存不够"><a href="#内存不够" class="headerlink" title="内存不够"></a>内存不够</h2><p>存入flash</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于51单片机的DS1302时钟</title>
      <link href="/2024/03/04/92-ji-yu-51-dan-pian-ji-de-ds1302-shi-zhong/"/>
      <url>/2024/03/04/92-ji-yu-51-dan-pian-ji-de-ds1302-shi-zhong/</url>
      
        <content type="html"><![CDATA[<h2 id="DS1302驱动代码"><a href="#DS1302驱动代码" class="headerlink" title="DS1302驱动代码"></a>DS1302驱动代码</h2><p>关于这句**DS1302_IO&#x3D;Command&amp;(0x01&lt;&lt;i);**位变量,逻辑判断,非0及增,什么意思 </p><p>过迭代 <code>Command</code> 的每个位来设置 <code>DS1302_IO</code> 的值，实现了将 <code>Command</code> 中的位逐个设置到 <code>DS1302_IO</code> 中的功能。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void DS1302_WriteByte(unsigned char Command,Data)&#123;unsigned char i;DS1302_CE&#x3D;1;for(i&#x3D;0;i&lt;8;i++)&#123;DS1302_IO&#x3D;Command&amp;(0x01&lt;&lt;i);DS1302_SCLK&#x3D;1;DS1302_SCLK&#x3D;0;&#125;for(i&#x3D;0;i&lt;8;i++)&#123;DS1302_IO&#x3D;Data&amp;(0x01&lt;&lt;i);DS1302_SCLK&#x3D;1;DS1302_SCLK&#x3D;0;&#125;DS1302_CE&#x3D;0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么读和写不同,为什么R&#x2F;W置1,为什么读的时候要从下降沿开始读</p><p>答: <strong>这个芯片的这个功能就是这么设计的</strong>,就像是方向键左键是向左,总不能问为什么不向右吧</p><img src="/2024/03/04/92-ji-yu-51-dan-pian-ji-de-ds1302-shi-zhong/image-20240303211037710.png" class="" title="image-20240303211037710"><p>官方文档的<strong>写保护位</strong></p><blockquote><p>控制寄存器的位 7是写保护位，前 7位（位 0至位 6）被强制为 0且读取时总是读 0. 在任何对时钟或 RAM的写操作以前，位 7必须为 0.当为高时，写保护位禁止任何寄存器的写操作. 初始加电状态未定义. 因此，在试图写器件之前应该清除 WP位</p></blockquote><p>由图可知, 例如秒的高四位是10秒,低四位是秒, 推断出DS1302写入和读取时间使用的是BCD码</p><blockquote><p>BCD码就是 0001 0011 的BCD码为13,十进制为19,十六进制为0x13</p></blockquote><p>BCD码本质上就是八位二进制数逢十进一,十六进制是逢十六进一</p><img src="/2024/03/04/92-ji-yu-51-dan-pian-ji-de-ds1302-shi-zhong/image-20240303222950773.png" class="" title="image-20240303222950773"><pre class="line-numbers language-C" data-language="C"><code class="language-C">unsigned char Second;void main()&#123;  DS1302_Init();  LCD_Init();    LCD_ShowString(1,1,&quot;time&quot;);  DS1302_WriteByte(0x80,0x03);    &#x2F;&#x2F;注意清除写保护位   Second&#x3D;DS1302_ReadByte(0x81);  LCD_ShowNum(2,1,Second,2);  while(1)  &#123;  Second&#x3D;DS1302_ReadByte(0x81);  &#x2F;&#x2F;当秒到9时,会跳到16,因为BCD码的9变为10 0000 1001 -&gt; 0001 0000 十六进制:16  LCD_ShowNum(2,1,Second,4);  &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个困惑,也就是说DS1302读取和写入数据都是BCD码</p><blockquote><p>比如我写入0x12,会出现18,我现在的问题是为什么lcd显示的时候不现实bcd而是16进制,应该是lcd显示源码的原因,转换成16进制了</p></blockquote><p>我明白了,比如我获取到的数据是bcd的10即0001 0000,但是这个数据格式是16进制的16,因为就是16进制的表示形式</p><img src="/2024/03/04/92-ji-yu-51-dan-pian-ji-de-ds1302-shi-zhong/image-20240303225106072.png" class="" title="image-20240303225106072"><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>函数已经有一个主体了,重定义了,看看是不是多复制了一个函数</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c">Hardware\Ds1302.c(99): error C237: &#39;_DS1302_ReadByte&#39;: function already has a body<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>非数组的下标或维度过多,就是一个不是数组的变量被以array[0]这种格式调用了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Hardware\Ds1302.c(109): error C216: subscript on non-array or too many dimensions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="可调时钟"><a href="#可调时钟" class="headerlink" title="可调时钟"></a>可调时钟</h2><p>首先想好程序流程, 可以写一个程序框图理清思路, 流程图如下</p><p>大概思路就是, 按键1控制设置模式和显示模式的切换, 设置模式检测按键2、3、4,进行切换时间位、++、–的操作, </p><p>最后更新显示, 写入DS1302中。</p><img src="/2024/03/04/92-ji-yu-51-dan-pian-ji-de-ds1302-shi-zhong/image-20240309075849348.png" class="" title="image-20240309075849348"><p>小于x的数对x取余的结果与自身相同，它无法被6整除，所以余数就是x本身。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">TimeSelectSet++%&#x3D;6;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>找bug,按照逻辑,依次测试功能手否可以正常实现</p><h3 id="BUG1"><a href="#BUG1" class="headerlink" title="BUG1"></a>BUG1</h3><p>新BUG,if不显示次外层对应花括号,整个内容复制也不可以,需要单个<strong>if(){}</strong>,然后一点一点复制</p><p>就是外面的大花括号对应不上</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">if(KeyNum&#x3D;&#x3D;4) &#123;   DS1302_Time[TimeSetSelect]--;   if(DS1302_Time[0]&lt;1)&#123;DS1302_Time[0]&#x3D;30;&#125;   if(DS1302_Time[1]&lt;1)&#123;DS1302_Time[1]&#x3D;12;&#125;                                                                                       ;&#125;   &#x2F;&#x2F;keil里没有这个,复制过来就有了   if(DS1302_Time[1]&#x3D;&#x3D;1|DS1302_Time[1]&#x3D;&#x3D;3||DS1302_Time[1]&#x3D;&#x3D;5||DS1302_Time[1]&#x3D;&#x3D;7     ||DS1302_Time[1]&#x3D;&#x3D;8||DS1302_Time[1]&#x3D;&#x3D;10||DS1302_Time[1]&#x3D;&#x3D;12)   &#123;        if(DS1302_Time[2]&lt;1)&#123;DS1302_Time[2]&#x3D;31;&#125;   &#125;   else if(DS1302_Time[1]&#x3D;&#x3D;4||DS1302_Time[1]&#x3D;&#x3D;6||DS1302_Time[1]&#x3D;&#x3D;9||DS1302_Time[1]&#x3D;&#x3D;11)   &#123;     if(DS1302_Time[2]&lt;1)&#123;DS1302_Time[2]&#x3D;30;&#125;   &#125;   else if(DS1302_Time[1]&#x3D;&#x3D;2)   &#123;     if(DS1302_Time[0]%4&#x3D;&#x3D;0)     &#x2F;&#x2F;平年闰年       &#123;         if(DS1302_Time[2]&lt;1)&#123;DS1302_Time[2]&#x3D;29;&#125;       &#125;     else&#123;if(DS1302_Time[2]&lt;1)&#123;DS1302_Time[2]&#x3D;28;&#125;&#125;   &#125;       if(DS1302_Time[3]&lt;0)&#123;DS1302_Time[3]&#x3D;23;&#125;   if(DS1302_Time[4]&lt;0)&#123;DS1302_Time[4]&#x3D;59;&#125;   if(DS1302_Time[5]&lt;0)&#123;DS1302_Time[5]&#x3D;59;&#125;   if(DS1302_Time[6]&lt;1)&#123;DS1302_Time[6]&#x3D;7;&#125;     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把多出来的那个;}删掉就好了</p><h3 id="BUG2"><a href="#BUG2" class="headerlink" title="BUG2"></a>BUG2</h3><p>时间减的时候,0-1&#x3D;55而不是59</p><p>因为 DS1302_Time[]类型是unsigned char,是从0-255,顾0-1&#x3D;255,显示后两位就是55</p><p>解决:</p><p>将unsigned char改为char(-128~127)即可</p><p>记得使用清屏函数,否则会有残留</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手动搭建V2ray节点</title>
      <link href="/2024/02/23/91l-shou-dong-da-jian-v2ray-jie-dian/"/>
      <url>/2024/02/23/91l-shou-dong-da-jian-v2ray-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="安装V2ray"><a href="#安装V2ray" class="headerlink" title="安装V2ray"></a>安装V2ray</h2><ul><li><p><a href="https://guide.v2fly.org/">新 V2Ray 白话文指南</a>(推荐)</p></li><li><p><a href="https://v2fly.org/">官方文档</a></p></li></ul><p>官方脚本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F; 安裝執行檔和 .dat 資料檔bash &lt;(curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;v2fly&#x2F;fhs-install-v2ray&#x2F;master&#x2F;install-release.sh)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>移除</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash &lt;(curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;v2fly&#x2F;fhs-install-v2ray&#x2F;master&#x2F;install-release.sh) --remove<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以拉安装包<a href="https://github.com/v2fly/v2ray-core/releases">Releases · v2fly&#x2F;v2ray-core</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#启动 V2Ray:systemctl start v2ray#设置开机自启动 V2Ray:systemctl enable v2ray#查看运行状态systemctl status v2ray<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="v2ray配置格式"><a href="#v2ray配置格式" class="headerlink" title="v2ray配置格式"></a>v2ray配置格式</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;v2ray&#x2F;config.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>基础配置</strong>: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#123;  &quot;inbounds&quot;: [      &#123;            &quot;listen&quot;: &quot;[::]&quot;,# 监听ipv6端口           &quot;port&quot;: 10000,  # 服务器监听端口          &quot;protocol&quot;: &quot;vmess&quot;,          &quot;settings&quot;: &#123;              &quot;clients&quot;: [                  &#123;                      &quot;id&quot;: &quot;93d177bc-5d90-0251-69d1-9a30237a9bac&quot;,                      &quot;alterId&quot;: 0              #可有可无,额外id                  &#125;              ]          &#125;      &#125;  ],  &quot;outbounds&quot;: [      &#123;          &quot;protocol&quot;: &quot;freedom&quot;      &#125;  ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><input checked="" disabled="" type="checkbox"> <strong>可以正常使用</strong></li></ul><h2 id="TLS-暂无法使用"><a href="#TLS-暂无法使用" class="headerlink" title="TLS(暂无法使用)"></a>TLS(暂无法使用)</h2><p>TLS 中文译名是传输层安全, TLS 是证书认证机制，所以使用 TLS 需要证书</p><p>条件:</p><ul><li>一个绑定ip的域名</li><li>一个证书(我这里使用的证书是cloudflare客户端证书)</li></ul><p>证书可以<strong>cloudflare</strong>生成,也可以*[acme.sh](<a href="https://github.com/acmesh-official/acme.sh">acmesh-official&#x2F;acme.sh: A pure Unix shell script implementing ACME client protocol (github.com)</a>)*脚本生成</p><p>配置:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#123;  &quot;inbounds&quot;: [    &#123;      &quot;listen&quot;: &quot;[::]&quot;,# 监听ipv6端口       &quot;port&quot;: 443, # 建议使用 443 端口      &quot;protocol&quot;: &quot;vmess&quot;,          &quot;settings&quot;: &#123;        &quot;clients&quot;: [          &#123;            &quot;id&quot;: &quot;23ad6b10-8d1a-40f7-8ad0-e3e35cd38297&quot;,              &quot;alterId&quot;: 64          &#125;        ]      &#125;,      &quot;streamSettings&quot;: &#123;        &quot;network&quot;: &quot;tcp&quot;,        &quot;security&quot;: &quot;tls&quot;, # security 要设置为 tls 才会启用 TLS        &quot;tlsSettings&quot;: &#123;          &quot;certificates&quot;: [            &#123;              &quot;certificateFile&quot;: &quot;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;v2ray&#x2F;v2ray.crt&quot;, # 证书文件              &quot;keyFile&quot;: &quot;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;v2ray&#x2F;v2ray.key&quot; # 密钥文件            &#125;          ]        &#125;      &#125;    &#125;  ],  &quot;outbounds&quot;: [    &#123;      &quot;protocol&quot;: &quot;freedom&quot;,      &quot;settings&quot;: &#123;&#125;    &#125;  ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/02/23/91l-shou-dong-da-jian-v2ray-jie-dian/image-20240224155224748.png" class="" title="image-20240224155224748"><img src="/2024/02/23/91l-shou-dong-da-jian-v2ray-jie-dian/image-20240224155306171.png" class="" title="image-20240224155306171"><p><strong>服务端和客户端都不报错, 只有测试真延迟的时候,说503错误</strong>, 但是无法访问网络</p><h3 id="acme-sh安装证书"><a href="#acme-sh安装证书" class="headerlink" title="acme.sh安装证书"></a>acme.sh安装证书</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@30f2f8f483:~#  ~&#x2F;.acme.sh&#x2F;acme.sh --issue -d bvnatsg.ideagpt.top --standalone --keylength ec-256 --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[Sat Feb 24 16:18:25 CST 2024] Using CA: https:&#x2F;&#x2F;acme.zerossl.com&#x2F;v2&#x2F;DV90[Sat Feb 24 16:18:25 CST 2024] Standalone mode.[Sat Feb 24 16:18:25 CST 2024] No EAB credentials found for ZeroSSL, let&#39;s get one[Sat Feb 24 16:18:25 CST 2024] acme.sh is using ZeroSSL as default CA now.[Sat Feb 24 16:18:25 CST 2024] Please update your account with an email address first.[Sat Feb 24 16:18:25 CST 2024] acme.sh --register-account -m my@example.com[Sat Feb 24 16:18:25 CST 2024] See: https:&#x2F;&#x2F;github.com&#x2F;acmesh-official&#x2F;acme.sh&#x2F;wiki&#x2F;ZeroSSL.com-CA[Sat Feb 24 16:18:26 CST 2024] Please add &#39;--debug&#39; or &#39;--log&#39; to check more details.[Sat Feb 24 16:18:26 CST 2024] See: https:&#x2F;&#x2F;github.com&#x2F;acmesh-official&#x2F;acme.sh&#x2F;wiki&#x2F;How-to-debug-acme.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>acme.sh –register-account -m <a href="mailto:&#105;&#x73;&#103;&#101;&#x65;&#107;&#48;&#49;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;">isgeek01@gmail.com</a> –server zerossl</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@30f2f8f483:~# acme.sh --register-account -m isgeek01@gmail.com --server zerossl[Sat Feb 24 16:22:17 CST 2024] No EAB credentials found for ZeroSSL, let&#39;s get one[Sat Feb 24 16:22:19 CST 2024] Registering account: https:&#x2F;&#x2F;acme.zerossl.com&#x2F;v2&#x2F;DV90[Sat Feb 24 16:22:21 CST 2024] Registered[Sat Feb 24 16:22:21 CST 2024] ACCOUNT_THUMBPRINT&#x3D;&#39;2lPZ8zUYF2z1V_G8uXwS92iHZaenoVa6h83GCcoaHiA&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>试一下</p><h3 id="cloudflare换成orgin-证书-会报错"><a href="#cloudflare换成orgin-证书-会报错" class="headerlink" title="cloudflare换成orgin 证书,会报错"></a>cloudflare换成orgin 证书,会报错</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">2024&#x2F;02&#x2F;24 20:00:37 [Warning] [1464760311] app&#x2F;proxyman&#x2F;outbound: failed to process outbound traffic &gt; proxy&#x2F;vmess&#x2F;outbound: failed to find an available destination &gt; common&#x2F;retry: [dial tcp: lookup bvnatsg.ideagpt.top: operation was canceled] &gt; common&#x2F;retry: all retry attempts failed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h3><p>应该是证书有问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建实时汇率简易api</title>
      <link href="/2024/02/19/90l-da-jian-jian-yi-api/"/>
      <url>/2024/02/19/90l-da-jian-jian-yi-api/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><a href="https://flask.palletsprojects.com/en/3.0.x/quickstart/">python的flask框架</a></li><li>数据爬取</li><li>数据整理，构建返回数据</li><li>Flask-limitter限流器</li><li><a href="https://www.osgeo.cn/cpython/library/logging.html?highlight=logging#module-logging">logging—python的日志记录工具</a></li></ul><h2 id="Flask-limitter限流器"><a href="#Flask-limitter限流器" class="headerlink" title="Flask-limitter限流器"></a>Flask-limitter限流器</h2><p>使用flask-limitter对访问频率限制,对获取到的ip进行五秒内最多三次的限制</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">limiter &#x3D; Limiter(    app,    key_func&#x3D;get_remote_address,    default_limits&#x3D;[&quot;3 per 5 seconds&quot;, &quot;10 per hour&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><a href="https://zhuanlan.zhihu.com/p/380861110">Flask-Limiter详细使用说明</a></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/677508786">flask框架—limiter限流器的使用方法</a></li></ul><h2 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h2><p>basicConfig()函数要在debug()、info()等运行，且只要第一次运行才生效。后续的调用都是无效的。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 创建一个日志记录器logger &#x3D; logging.getLogger(__name__)logger.setLevel(logging.DEBUG)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建一个日志记录器并设置其级别是为了为<strong>处理器（Handler）提供一个容器</strong>，以便可以将处理器添加到记录器中。</p><p>这样可以使得多个处理器共享同一日志级别和日志过滤器。如果没有指定日志记录器，则处理器将无法添加到日志记录器中。</p><p>比如两个处理器,<strong>一个控制端打印日志</strong>, <strong>一个输出日志到文件</strong></p><h2 id="校准时间"><a href="#校准时间" class="headerlink" title="校准时间"></a>校准时间</h2><p>检查和修复系统时区配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">查看当前时区设置：cat &#x2F;etc&#x2F;timezonereadlink &#x2F;etc&#x2F;localtime设置一致的时区：假设你希望使用 Asia&#x2F;Shanghai 时区：echo &quot;Asia&#x2F;Shanghai&quot; | sudo tee &#x2F;etc&#x2F;timezonesudo ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重置时间后,记得将正在运行的服务重启</strong></p><h2 id="无法启动nginx"><a href="#无法启动nginx" class="headerlink" title="无法启动nginx"></a>无法启动nginx</h2><p>查看监听端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">netstat -nultulnsudo netstat -tuln | grep 80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>发现80端口被ipv6监听, 可能是因为v2ray的伪装域名, 我选择更改nginx的端口改为8000, 但是出现域名无法正产访问, 端口可以的问题</p><p><a href="http://23.26.232.222:8000/">http://23.26.232.222:8000/</a></p><p>上面的可以,下面的不行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http:&#x2F;&#x2F;23.26.232.222:8000&#x2F;exchange_rate?currency&#x3D;usdhttp:&#x2F;&#x2F;exrate.apigpt.eu.org&#x2F;exchange_rate?currency&#x3D;usd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p><strong>exrate.apigpt.eu.org</strong> 目前无法处理此请求。HTTP ERROR 503</p><p>测试 反代到b站</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="http://23.26.232.222:8000/">http://23.26.232.222:8000/</a></li></ul><ul><li><input disabled="" type="checkbox"> <a href="http://exrate.apigpt.eu.org/">http://exrate.apigpt.eu.org/</a></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 8000;    server_name exrate.apigpt.eu.org;    location &#x2F; &#123;        #proxy_pass http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;;        proxy_pass https:&#x2F;&#x2F;www.bilibili.com&#x2F;;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_set_header X-Forwarded-Host $host;        proxy_set_header X-Forwarded-Prefix &#x2F;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>换回80端口就都行了, 域名换成80端口也行了</p></li></ul><p><em><strong>我的疑问</strong></em>,为什么如果nginx监听比如说9999端口,其他的配置都一样,访问域名就不行,但是访问ip,加端口就可以(<a href="http://your_server_ip:9999/">http://your_server_ip:9999</a>)</p><blockquote><p>答：浏览器访问，都是<strong>域名+端口</strong>，只不过<strong>默认80</strong>，所以一般不用输入</p><p>例如，输入<a href="http://example.com,浏览器会默认连接到example.com的80端口./">http://example.com，浏览器会默认连接到example.com的80端口。</a></p></blockquote><blockquote><p>使用域名来访问服务器，例如<em><strong><a href="http://yourdomain.com/">http://yourdomain.com</a></strong></em>，浏览器会默认尝试使用HTTP的标准端口（80端口）发送请求。</p><p>因此，如果Nginx监听的端口不是80端口，浏览器无法直接连接到Nginx服务器。</p></blockquote><p>如果更改nginx默认监听的端口，那么访问时就要使用域名加上端口号</p><h2 id="Nginx重启失败"><a href="#Nginx重启失败" class="headerlink" title="Nginx重启失败"></a>Nginx重启失败</h2><p>查看运行状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为 nginx 启动需要一点点时间，而 systemd 在 nginx 完成启动前就去读取 pid file造成读取 pid 失败</p><p>解决方法: </p><p>让 systemd 在执行 ExecStart 的指令后等待一点点时间即可, 如果你的 nginx 启动需要时间更长，可以把 sleep 时间改长一点</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir -p &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;nginx.service.dprintf &quot;[Service]\nExecStartPost&#x3D;&#x2F;bin&#x2F;sleep 0.1\n&quot; &gt; &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;nginx.service.d&#x2F;override.confsystemctl daemon-reloadsystemctl restart nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>出现报错,以及解决方法**[参考文章](<a href="https://www.v2ex.com/t/300986">nginx Failed to read PID from file &#x2F;run&#x2F;nginx.pid: Invalid argument - V2EX</a>)**</p><p><a href="https://blog.csdn.net/z_xuewen/article/details/103859099"> Active: failed (Result: exit-code)</a></p><p>安装redis</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt updateapt install nginx#安装redisapt install redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>报错</strong>: ImportError: cannot import name ‘url_quote’ from ‘werkzeug.urls’ (&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.9&#x2F;dist-packages&#x2F;werkzeug&#x2F;urls.py)</p><p>flask版本太低,不兼容,更新一下就好了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install --upgrade werkzeugpip install --upgrade Flask<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>报错</strong>: Job for nginx.service failed because the control process exited with error code.</p><p>我这里是因为忘记配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;weixin.conf &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不创建符号链接将配置文件链接到 <code>sites-enabled</code> 目录中，Nginx 将不会加载或应用该站点的配置，该站点将不会在服务器上运行或生效。这样可以将配置文件保存在<code>sites-available</code> 目录中，暂时不启用, 不创建符号链接到 <code>sites-enabled</code> 目录中， Nginx就不会加载这些配置文件。</p><hr><ol><li><p>检查nginx配置文件是否有错误</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -t  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>已经启动nginx或者配置文件中的端口号被占用<br>检查端口是否被占用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">netstat -tnlp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果端口已被占用, 选择换端口, 或者杀掉进程</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pkill -9 nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看nginx日志</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>考虑权限问题</p></li></ol><h2 id="nginx配置ssl证书"><a href="#nginx配置ssl证书" class="headerlink" title="nginx配置ssl证书"></a>nginx配置ssl证书</h2><p><strong>客户端证书与源服务器证书的区别</strong></p><h3 id="1-客户端证书"><a href="#1-客户端证书" class="headerlink" title="1. 客户端证书"></a>1. 客户端证书</h3><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>客户端证书用于在客户端和服务器之间进行双向身份验证。也就是说，服务器不仅验证客户端的身份，客户端也验证服务器的身份。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>客户端证书由客户端持有，用于证明客户端的身份。</li><li>服务器需要配置验证客户端证书的 CA（Certificate Authority）证书。</li></ul><h3 id="2-源服务器证书（Origin-Certificate）"><a href="#2-源服务器证书（Origin-Certificate）" class="headerlink" title="2. 源服务器证书（Origin Certificate）"></a>2. 源服务器证书（Origin Certificate）</h3><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><p>源证书用于在 Cloudflare 和源服务器之间加密流量。它确保从 Cloudflare 到源服务器的通信是安全的。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>源证书由 Cloudflare 签发，用于源服务器，通常不在公共信任链中，因此只在 Cloudflare 和源服务器之间使用。</li><li>只需在服务器上配置，客户端不会直接与源证书交互。</li></ul><h4 id="配置客户端证书"><a href="#配置客户端证书" class="headerlink" title="配置客户端证书"></a>配置客户端证书</h4><ol><li><p><strong>生成客户端证书：</strong> 在 Cloudflare 仪表板中生成客户端证书，并下载证书和私钥。</p></li><li><p><strong>配置服务器验证客户端证书：</strong> 在 Nginx 配置中启用客户端证书验证。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 443 ssl;    server_name exrate.apigpt.eu.org;    ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;server.crt;    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;server.key;    ssl_client_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;cloudflare_ca.pem;  # CA 证书    ssl_verify_client on;  # 启用客户端证书验证    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_set_header X-Forwarded-Host $host;        proxy_set_header X-Forwarded-Prefix &#x2F;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="配置源证书"><a href="#配置源证书" class="headerlink" title="配置源证书"></a>配置源证书</h4><ol><li><p><strong>生成源证书：</strong> 在 Cloudflare 仪表板中生成源证书，并下载证书和私钥。</p></li><li><p><strong>配置服务器使用源证书：</strong> 在 Nginx 配置中配置源证书。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 443 ssl;    server_name exrate.apigpt.eu.org;    ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;cloudflare_origin.pem;    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;cloudflare_origin.key;    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_set_header X-Forwarded-Host $host;        proxy_set_header X-Forwarded-Prefix &#x2F;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>客户端证书</strong>主要用于客户端和服务器之间的双向身份验证，确保只有授权的客户端可以访问服务器。</li><li><strong>源证书</strong>用于在 Cloudflare 和源服务器之间加密流量，保护从 Cloudflare 到源服务器的通信。</li></ul><p>给权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo chmod 600 &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;exrate_api.pem #公钥sudo chmod 600 &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;exrate_api.key #私钥<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>nginx配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 80;    server_name exrate.apigpt.eu.org;    # 重定向 HTTP 请求到 HTTPS    return 301 https:&#x2F;&#x2F;$server_name$request_uri;&#125;server &#123;    listen 443 ssl;    server_name exrate.apigpt.eu.org;    ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;exrate_api.pem;    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;exrate_api.key;          # ssl验证相关配置    ssl_session_timeout  5m;    #缓存有效期    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    #加密算法    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #安全链接可选的加密协议    ssl_prefer_server_ciphers on;   #使用服务器端的首选算法    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_set_header X-Forwarded-Host $host;        proxy_set_header X-Forwarded-Prefix &#x2F;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出现错误</p><img src="/2024/02/19/90l-da-jian-jian-yi-api/image-20240221085320742.png" class="" title="image-20240221085320742"><p><a href="https://developers.cloudflare.com/support/troubleshooting/cloudflare-errors/troubleshooting-cloudflare-5xx-errors/#526error">Cloudflare 5XX 错误疑难解答 ·Cloudflare 支持文档</a></p><p>查看日志,未发现报错,说明nginx配置没有问题</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo cat &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Error code 525</strong>可能能使因为nginx配置文件,关于ssl部分配置错误出现的问题</p><p>例如我这里<code> listen 443 ssl;</code>忘记加ssl的</p><img src="/2024/02/19/90l-da-jian-jian-yi-api/image-20240221105344522.png" class="" title="image-20240221105344522"><h2 id="07-21-24"><a href="#07-21-24" class="headerlink" title="07&#x2F;21&#x2F;24"></a>07&#x2F;21&#x2F;24</h2><p>不小心删了DNS解析记录，但是加回来了，依然访问不了，不知道哪里设置错误</p><p>反应慢吧应该是</p><img src="/2024/02/19/90l-da-jian-jian-yi-api/image-20240721162835575.png" class="" title="image-20240721162835575"><img src="/2024/02/19/90l-da-jian-jian-yi-api/image-20240721162942436.png" class="" title="image-20240721162942436"><h2 id="07-27-24"><a href="#07-27-24" class="headerlink" title="07&#x2F;27&#x2F;24"></a>07&#x2F;27&#x2F;24</h2><p>bytevirt的机器被dd黑洞，api无法使用，我打算将网站</p><ul><li>迁移到其他服务器</li><li>负载均衡(但是由于这个api有ssh，要稍微麻烦一些)</li><li>并且更改爬取方式和源站，对数据进行缓存，减少对源站的压力</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>🏻ipv6搭建v2ray节点</title>
      <link href="/2024/02/18/89l-ipv6-da-jian-v2ray-jie-dian/"/>
      <url>/2024/02/18/89l-ipv6-da-jian-v2ray-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>VPS的流量走向：卢森堡v6入，v4+v6出</p><h2 id="v2ray-下载安装-·-Project-V-官方网站-v2ray-com"><a href="#v2ray-下载安装-·-Project-V-官方网站-v2ray-com" class="headerlink" title="[v2ray](下载安装 · Project V 官方网站 (v2ray.com))"></a>[v2ray](<a href="https://www.v2ray.com/chapter_00/install.html">下载安装 · Project V 官方网站 (v2ray.com)</a>)</h2><p>V2Ray 和 Xray 都是一种开源的网络代理软件，主要功能是通过代理服务器转发网络流量，以帮助用户绕过网络封锁、加密通信数据以及隐藏用户真实 IP 地址等。</p><h2 id="x-ui"><a href="#x-ui" class="headerlink" title="x-ui"></a>x-ui</h2><p>x-ui是基于v2ray软件的一个面板, 便于管理和配置。</p><p><strong>这里ipv6就要用x-ui搭建</strong>, 可能是大部分的v2ray的一键脚本, <strong>会默认获取ipv4的ip</strong>, 导致绑定ipv6的域名被认为是未解析,当然,不用伪装域名的也不可以, 因为该脚本只能获取ipv4。</p><p>比如这个<a href="%5Braw.githubusercontent.com/xyz690/v2ray/master/install.sh%5D(https://raw.githubusercontent.com/xyz690/v2ray/master/install.sh)">脚本</a>获取ipv4的命令(这个可以获取ipv6的地址<a href="https://api6.ipify.org/">https://api6.ipify.org/</a>)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">get_ip() &#123;# ip&#x3D;$(curl -s https:&#x2F;&#x2F;ipinfo.io&#x2F;ip)    # [[ -z $ip ]] &amp;&amp; ip&#x3D;$(curl -s https:&#x2F;&#x2F;api.ip.sb&#x2F;ip)# [[ -z $ip ]] &amp;&amp; ip&#x3D;$(curl -s https:&#x2F;&#x2F;api.ipify.org)# [[ -z $ip ]] &amp;&amp; ip&#x3D;$(curl -s https:&#x2F;&#x2F;ip.seeip.org)# [[ -z $ip ]] &amp;&amp; ip&#x3D;$(curl -s https:&#x2F;&#x2F;ifconfig.co&#x2F;ip)# [[ -z $ip ]] &amp;&amp; ip&#x3D;$(curl -s https:&#x2F;&#x2F;api.myip.com | grep -oE &quot;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot;)# [[ -z $ip ]] &amp;&amp; ip&#x3D;$(curl -s icanhazip.com)# [[ -z $ip ]] &amp;&amp; ip&#x3D;$(curl -s myip.ipip.net | grep -oE &quot;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot;)export &quot;$(wget -4 -qO- https:&#x2F;&#x2F;dash.cloudflare.com&#x2F;cdn-cgi&#x2F;trace | grep ip&#x3D;)&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1[[ -z $ip ]] &amp;&amp; export &quot;$(wget -6 -qO- https:&#x2F;&#x2F;dash.cloudflare.com&#x2F;cdn-cgi&#x2F;trace | grep ip&#x3D;)&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1[[ -z $ip ]] &amp;&amp; echo -e &quot;\n$red 获取IP失败, 这垃圾小鸡扔了吧！$none\n&quot; &amp;&amp; exit&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以,我这里给他换成获取ipv6的试一下</p><p>但是可以选择手动修改配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-bash: .&#x2F;ipv6.sh: &#x2F;bin&#x2F;bash^M: bad interpreter: No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dos2unix ipv6.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只改了获取的ip,结果无法正常使用,观察发现配置文件<code>/etc/v2ray/config.json</code>不同,更改过去ip导致生成的配置错误</p><p><strong>这台机限制资源太小了,给关机了</strong>,下次研究</p><h2 id="待完成"><a href="#待完成" class="headerlink" title="待完成"></a>待完成</h2><p>…..</p><h2 id="目前搭建方法是使用x-ui-然后面板配置证书"><a href="#目前搭建方法是使用x-ui-然后面板配置证书" class="headerlink" title="目前搭建方法是使用x-ui,然后面板配置证书"></a>目前搭建方法是使用x-ui,然后面板配置证书</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/veip007/IPV6">github参考配置</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建v2ray节点</title>
      <link href="/2024/02/16/88l-da-jian-v2ray-jie-dian/"/>
      <url>/2024/02/16/88l-da-jian-v2ray-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="ws-tls一键脚本"><a href="#ws-tls一键脚本" class="headerlink" title="ws+tls一键脚本"></a>ws+tls一键脚本</h2><p>只需要准备一个伪装域名即可(无CDN)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash &lt;(curl -s -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;xyz690&#x2F;v2ray&#x2F;master&#x2F;install.sh)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="V2rayN报错"><a href="#V2rayN报错" class="headerlink" title="V2rayN报错"></a>V2rayN报错</h2><p>大佬总结: <strong>端口被封</strong>, <strong>节点挂了</strong>,配置错了</p><blockquote><p>本次原因:资源不够, 导致v2ray没有运行起来,表现为443端口没有被监听, 重装或者重启解决</p></blockquote><h3 id="报错-1"><a href="#报错-1" class="headerlink" title="报错(1)"></a>报错(1)</h3><p> failed to find an available destination</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">2024&#x2F;02&#x2F;17 07:44:56 [Warning] [2442645581] app&#x2F;proxyman&#x2F;outbound: failed to process outbound traffic &gt; proxy&#x2F;vmess&#x2F;outbound: failed to find an available destination &gt; common&#x2F;retry: [transport&#x2F;internet&#x2F;websocket: failed to dial WebSocket &gt; transport&#x2F;internet&#x2F;websocket: failed to dial to (wss:&#x2F;&#x2F;wap_sg2.ideagpt.top&#x2F;):  &gt; dial tcp 185.151.146.79:443: operation was canceled transport&#x2F;internet&#x2F;websocket: failed to dial WebSocket &gt; transport&#x2F;internet&#x2F;websocket: failed to dial to (wss:&#x2F;&#x2F;wap_sg2.ideagpt.top&#x2F;):  &gt; dial tcp: lookup wap_sg2.ideagpt.top: operation was canceled] &gt; common&#x2F;retry: all retry attempts failed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="报错-2"><a href="#报错-2" class="headerlink" title="报错(2)"></a>报错(2)</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">2024&#x2F;03&#x2F;18 06:49:13 [Warning] [2497832095] github.com&#x2F;v2fly&#x2F;v2ray-core&#x2F;v4&#x2F;app&#x2F;proxyman&#x2F;outbound: failed to process outbound traffic &gt; github.com&#x2F;v2fly&#x2F;v2ray-core&#x2F;v4&#x2F;proxy&#x2F;vmess&#x2F;outbound: failed to find an available destination &gt; github.com&#x2F;v2fly&#x2F;v2ray-core&#x2F;v4&#x2F;common&#x2F;retry: [github.com&#x2F;v2fly&#x2F;v2ray-core&#x2F;v4&#x2F;transport&#x2F;internet&#x2F;websocket: failed to dial WebSocket &gt; github.com&#x2F;v2fly&#x2F;v2ray-core&#x2F;v4&#x2F;transport&#x2F;internet&#x2F;websocket: failed to dial to (wss:&#x2F;&#x2F;xxx.xx.xx.xx:443&#x2F;search):  &gt; dial tcp xxx.xx.xx.xx:443: connectex: No connection could be made because the target machine actively refused it.] &gt; github.com&#x2F;v2fly&#x2F;v2ray-core&#x2F;v4&#x2F;common&#x2F;retry: all retry attempts failed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="报错-3"><a href="#报错-3" class="headerlink" title="报错(3)"></a>报错(3)</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">2024&#x2F;03&#x2F;18 07:05:03 127.0.0.1:50982 accepted http:&#x2F;&#x2F;www.gstatic.com&#x2F;generate_204 [http10911 -&gt; proxy10911]2024&#x2F;03&#x2F;18 07:05:07 [Warning] [3072752593] app&#x2F;proxyman&#x2F;outbound: failed to process outbound traffic &gt; proxy&#x2F;vmess&#x2F;outbound: failed to find an available destination &gt; common&#x2F;retry: [transport&#x2F;internet&#x2F;websocket: failed to dial WebSocket &gt; transport&#x2F;internet&#x2F;websocket: failed to dial to (wss:&#x2F;&#x2F;zgo.apigpt.eu.org&#x2F;):  &gt; tls: first record does not look like a TLS handshake] &gt; common&#x2F;retry: all retry attempts failed2024&#x2F;03&#x2F;18 07:05:07 [Warning] [3072752593] proxy&#x2F;http: failed to read response from www.gstatic.com &gt; io: read&#x2F;write on closed pipe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2024/02/16/88l-da-jian-v2ray-jie-dian/image-20240318072713050.png" class="" title="image-20240318072713050"><p>v2ray监听的端口是ipv6的</p><p>[ v2ray failed to dial WebSocket 解决方法](<a href="https://codefuturesql.top/post/v2ray_failed_to_dail/">转载 v2ray failed to dial WebSocket 解决方法_ find an available destination | Academic (codefuturesql.top)</a>)</p><h2 id="暂未解决"><a href="#暂未解决" class="headerlink" title="暂未解决"></a>暂未解决</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">临时禁用 IPv6，只需要输入三条命令：sudo sysctl -w net.ipv6.conf.all.disable_ipv6&#x3D;1sudo sysctl -w net.ipv6.conf.default.disable_ipv6&#x3D;1sudo sysctl -w net.ipv6.conf.lo.disable_ipv6&#x3D;1检查命令是否生效：ip a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说是因为80或者443端口被占用了需要手动转发tls,因为服务器上搭建了其他的网站,</p><p>但是443端口并未被占用,为什么自动监听ipv6的端口呢</p><p>确实其他为搭建网站的服务器可以正常搭建,tcp协议也可以正常搭建</p><p>而且不知道为啥朝鲜的GPT解锁掉了</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><ol><li><p><strong>测试ip端口通不通</strong></p><p>测试网站: <a href="https://tcp.ping.pe/">Ping.pe</a></p><blockquote><p>Connection to 1xxx.xxx.xxx.xxx:443 failed</p></blockquote></li><li><p><strong>查看正在监听的端口</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">netstat -tuln<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>发现443端口没有被监听</p></blockquote><p>运行 <strong>sudo lsof -i :443</strong>或者<strong>netstat -anp | grep 【端口号】</strong> 没有显示任何输出，说明目前没有进程在使用443端口。</p></li><li><p><strong>检查服务状态</strong>：运行以下命令来查看您的服务是否正在运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl status &lt;your-service-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果服务正在运行，检查服务的状态和日志以查看是否有任何错误消息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@HKserver1:~# sudo systemctl status v2ray● v2ray.service - V2Ray Service     Loaded: loaded (&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;v2ray.service; enabled; vendor preset: enabled)     Active: activating (auto-restart) (Result: signal) since Sat 2024-02-17 11:55:05 CST; 79ms ago       Docs: https:&#x2F;&#x2F;www.v2ray.com&#x2F;             https:&#x2F;&#x2F;www.v2fly.org&#x2F;    Process: 12023 ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;env v2ray.vmess.aead.forced&#x3D;false &#x2F;usr&#x2F;bin&#x2F;v2ray&#x2F;v2ray run -config &#x2F;etc&#x2F;v2ray&#x2F;c&gt;   Main PID: 12023 (code&#x3D;killed, signal&#x3D;KILL)Feb 17 11:55:05 HKserver1 systemd[1]: v2ray.service: Main process exited, code&#x3D;killed, status&#x3D;9&#x2F;KILLFeb 17 11:55:05 HKserver1 systemd[1]: v2ray.service: Failed with result &#39;signal&#39;.Feb 17 11:55:05 HKserver1 systemd[1]: v2ray.service: Scheduled restart job, restart counter is at 21.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出显示, <code>Main process exited, code=killed, status=9/KILL</code>, V2Ray 服务正在以信号KILL退出，然后尝试自动重启。这种情况通常表明有一个问题导致了 V2Ray 服务的异常退出。</p></li><li><p><strong>检查服务日志</strong>：查看服务的日志文件以获取有关启动过程的详细信息。通常，服务的日志文件位于 <code>/var/log</code> 目录下</p><ol><li><p><strong>查看 V2Ray 日志</strong>：查看 V2Ray 的日志文件以获取更多详细信息，帮助确定为什么服务异常退出。您可以使用以下命令查看日志：&#96;&#96;&#96;</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">journalctl -u v2ray.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>日志输出</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Feb 16 20:53:41 HKserver1 env[102815]: V2Ray 5.12.1 (V2Fly, a community-driven edition of V2Ray.) Custom (go1.21.4 li&gt;Feb 16 20:53:41 HKserver1 env[102815]: A unified platform for anti-censorship.Feb 16 20:53:46 HKserver1 systemd[1]: v2ray.service: Main process exited, code&#x3D;killed, status&#x3D;9&#x2F;KILLFeb 16 20:53:46 HKserver1 systemd[1]: v2ray.service: Failed with result &#39;signal&#39;.Feb 16 20:53:46 HKserver1 systemd[1]: v2ray.service: Scheduled restart job, restart counter is at 5.Feb 16 20:53:46 HKserver1 systemd[1]: Stopped V2Ray Service.Feb 16 20:53:46 HKserver1 systemd[1]: Started V2Ray Service.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>V2Ray 服务似乎在启动后立即被信号KILL终止。这表明有某种问题导致服务无法正常运行，系统因此将其终止。</p><p>通常情况下，<strong>V2Ray 进程被信号KILL终止</strong>的原因可能包括：</p><ol><li><strong>资源不足</strong>：V2Ray 可能需要的系统资源（例如内存）不足以正常运行，导致操作系统强制终止进程。</li><li><strong>配置错误</strong>：V2Ray 配置文件可能存在错误</li><li><strong>异常情况</strong>：这可能是由于软件错误、兼容性问题或其他未知原因引起的。</li></ol></li></ol></li><li><p><strong>手动启动服务</strong>：尝试手动启动服务并检查是否有任何错误消息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl start &lt;your-service-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p><strong>常见问题</strong></p><ul><li>校正时间</li><li>防火墙端口(一般端口都是默认打开的,不用设置)</li><li>DNS无法解析域名</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p><a href="https://github.com/v2fly/v2ray-core/issues/1873">github上的相关解答</a></p></li><li><p><a href="https://hostloc.com/thread-969845-1-1.html">hostloc上的相关解答</a></p></li><li><p><a href="https://hostloc.com/thread-1049249-1-1.html">hostloc上额相关解答</a></p></li><li><p><a href="https://www.itblogcn.com/article/406.html#title-7">2024年V2Ray搭建图文教程</a>](<a href="https://www.itblogcn.com/article/406.html#title-7">https://www.itblogcn.com/article/406.html#title-7</a>)</p></li><li><p><a href="https://github.com/233boy/v2ray/wiki/V2Ray%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC"> 233boy的V2Ray一键安装脚本</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在VPS上部署NeZha探针</title>
      <link href="/2024/02/15/87l-nezha-tan-zhen/"/>
      <url>/2024/02/15/87l-nezha-tan-zhen/</url>
      
        <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>监控多台VPS的运行情况</li></ul><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h2><ul><li>一台vps做面板端</li><li>一个域名指向面板服务器的ip</li><li>一个github账号</li></ul><h2 id="Github-OAuth设置"><a href="#Github-OAuth设置" class="headerlink" title="Github OAuth设置"></a>Github OAuth设置</h2><ol><li><p>访问<code>https://github.com/settings/developers</code>，右上角<code>New OAuth App</code></p></li><li><p>如图设置应用名称、主页、回调页面</p><img src="/2024/02/15/87l-nezha-tan-zhen/image-20240216105427454.png" class="" title="image-20240216105427454"></li><li><p>点击 “Register application”，保存页面中的<code>Client ID</code>，然后点击 <code>Generate a new client secret</code>，创建一个新的 <code>Client Secret</code>，新建的密钥<strong>仅会显示一次</strong>，请保存。</p><img src="/2024/02/15/87l-nezha-tan-zhen/image-20240216105017818.png" class="" title="image-20240216105017818"></li><li><p>Client ID和Client Secret在面板安装的时候会用到。</p></li></ol><h2 id="面板端"><a href="#面板端" class="headerlink" title="面板端"></a>面板端</h2><ol><li><p>官方安装脚本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;naiba&#x2F;nezha&#x2F;master&#x2F;script&#x2F;install.sh  -o nezha.sh &amp;&amp; chmod +x nezha.sh &amp;&amp; sudo .&#x2F;nezha.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>境内服务器使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -L https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;naiba&#x2F;nezha@master&#x2F;script&#x2F;install.sh -o nezha.sh &amp;&amp; chmod +x nezha.sh &amp;&amp; sudo CN&#x3D;true .&#x2F;nezha.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>访问面板<code>http://a.com:8008</code>或者<code>ip:8008</code>检查是否安装成功</p><h3 id="❗注意"><a href="#❗注意" class="headerlink" title="❗注意:"></a>❗注意:</h3><p>若服务器搭建了其它网站需要配置<code>nginx反向代理</code>,<strong>否则会跳转至你的服务器的其他网站</strong></p><p>1.在<code>/etc/nginx/sites-available/</code>目录下, 创建一个新的配置文件</p><blockquote><p>vim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;nezha.conf</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#PROXY-START&#x2F;server &#123;    listen 80;    server_name vps.isgeek.eu.org;    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000;        proxy_set_header Host $http_host;        proxy_set_header Upgrade $http_upgrade;    &#125;    location ~ ^&#x2F;(ws|terminal&#x2F;.+)$ &#123;        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000;        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &quot;Upgrade&quot;;        proxy_set_header Host $http_host;    &#125;&#125;#PROXY-END&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.<strong>启用配置文件</strong>：在 <code>/etc/nginx/sites-enabled/</code> 目录中创建符号链接，将配置文件链接到 <code>sites-available</code> 中。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;nezha.conf &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.<strong>重新加载 Nginx</strong>：重新加载 Nginx，使配置生效。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl reload nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>访问面板<code>http://a.com:8008</code>或者<code>ip:8008</code>检查是否成功</p></li></ol><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li><p>访问面板<br><code>http://a.com:8008</code></p></li><li><p>点击右上角登录，使用Github账户登录，进入后台</p><p>准备<strong>另一个</strong>绑定面板端ip的域名(<code>注意不能开小黄云代理</code>),或者直接绑定原面板端的域名也可以, 去<strong>设置</strong>添加<strong>未接入cdn的面板服务器域名&#x2F;ip</strong>, 保存(比较麻烦的一点就是,需要一个域名一台机器)</p><p>先点击<strong>新增服务器</strong>，设置好信息，<strong>新增</strong>, 然后点击绿色小企鹅，复制一键安装客户端命令，在客户机上粘贴执行即可<br>命令格式为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;naiba&#x2F;nezha&#x2F;master&#x2F;script&#x2F;install.sh -o nezha.sh &amp;&amp; chmod +x nezha.sh &amp;&amp; sudo .&#x2F;nezha.sh install_agent b.com 5555 [密钥]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>一切顺利的话，在面板首页即可看到客户端上线了</p></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p><a href="https://nezha.wiki/guide/dashboard.html">官方文档 | 哪吒监控 (nezha.wiki)</a></p></li><li><p><a href="https://www.nodeseek.com/post-8361-1">哪吒探针教程</a></p></li><li><p><a href="https://potyz0.hashnode.dev/hax-woiden-status">使用Hax或Woiden搭建哪吒探针及问题解答 (hashnode.dev)</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Warp</title>
      <link href="/2024/02/12/86l-warp/"/>
      <url>/2024/02/12/86l-warp/</url>
      
        <content type="html"><![CDATA[<h1 id="warp"><a href="#warp" class="headerlink" title="warp"></a>warp</h1><p><a href="https://p3terx.com/go/aHR0cHM6Ly8xLjEuMS4xLw">Cloudflare WARP</a> (简称 WARP) 是 Cloud­flare 提供的一项基于 Wire­Guard 的网络流量安全及加速服务</p><p>##LXC使用教程</p><h2 id="安装Warp："><a href="#安装Warp：" class="headerlink" title="安装Warp："></a>安装Warp：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apk updateapk upgradeapk add sudo bash curl wget vim tar unzipapk add curl &amp;&amp; apk add bash &amp;&amp; apk add wget<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget -N https:&#x2F;&#x2F;gitlab.com&#x2F;fscarmen&#x2F;warp&#x2F;-&#x2F;raw&#x2F;main&#x2F;menu.sh &amp;&amp; bash menu.sh 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果第一次没有获取到ip,则使用<code>warp u</code>卸载然后重装,一般第二次就可以了</p><h2 id="哪吒面板："><a href="#哪吒面板：" class="headerlink" title="哪吒面板："></a>哪吒面板：</h2><p>apk add bash curl (把community源前的#删了)<br>使用哪吒后台一键安装命令，去掉sudu</p><h2 id="常用脚本"><a href="#常用脚本" class="headerlink" title="常用脚本"></a>常用脚本</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 某某UI：apk add curl&amp;&amp;apk add bash &amp;&amp; bash &lt;(curl -Ls https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Lynn-Becky&#x2F;Alpine-x-ui&#x2F;main&#x2F;alpine-xui.sh)## 某R：apk add wget sudo curl &amp;&amp; wget -N https:&#x2F;&#x2F;github.com&#x2F;Cd1s&#x2F;alpineXrayR&#x2F;releases&#x2F;download&#x2F;one-click&#x2F;install-xrayr.sh &amp;&amp; chmod +x install-xrayr.sh &amp;&amp; bash install-xrayr.sh##ArgoX：bash &lt;(wget -qO- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;fscarmen&#x2F;argox&#x2F;main&#x2F;argox.sh)##某BOX：bash &lt;(wget -qO- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;fscarmen&#x2F;sing-box&#x2F;main&#x2F;sing-box.sh)## Alpine 软件管理：rc-service 软件名 restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>x-ui</p><pre class="line-numbers language-none"><code class="language-none">bash &lt;(curl -Ls https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ozersource&#x2F;x-ui-alpine&#x2F;main&#x2F;x-ui<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2024/02/11/85l-nginx/"/>
      <url>/2024/02/11/85l-nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="location匹配规则"><a href="#location匹配规则" class="headerlink" title="location匹配规则"></a>location匹配规则</h2><ol><li>&#x3D;, ^~, ~ 普通文本四个优先级较高的先匹配</li><li>同优先级的, 匹配程度较高的先匹配</li><li>匹配程度一样, 则写在前面的先匹配</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>🔥Nginx反向代理</title>
      <link href="/2024/02/05/84l-nginx-fan-xiang-dai-li/"/>
      <url>/2024/02/05/84l-nginx-fan-xiang-dai-li/</url>
      
        <content type="html"><![CDATA[<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>请求经过中间商,中间商发送给目标服务器</p><h2 id="正向代理和反向代理的区别"><a href="#正向代理和反向代理的区别" class="headerlink" title="正向代理和反向代理的区别"></a>正向代理和反向代理的区别</h2><p>一个作用在客户端,一个作用在服务端</p><p>正向代理:即所谓的vpn,客户端将请求发送至代理服务器,由代理服务器发出最终请求,并将响应返回</p><ul><li>客户端—&gt;代理服务器—&gt;访问的<a href="https://cloud.tencent.com/act/pro/domain-sales?from_column=20065&from=20065">域名</a>—&gt;访问的服务器</li><li>客户端&lt;—代理服务器&lt;—访问的域名&lt;—访问的服务器</li></ul><img src="/2024/02/05/84l-nginx-fan-xiang-dai-li/image-20240207081314588.png" class="" title="image-20240207081314588"><p>反向代理:客户端-&gt;目标地址</p><p>我的理解是<strong>服务器将被访问域名的流量转发到配置端口上</strong></p><img src="/2024/02/05/84l-nginx-fan-xiang-dai-li/image-20240207081328054.png" class="" title="image-20240207081328054"><ul><li>nginx代理主机是中间人，客户端请求代理机，代理机自己重新构建请求报文，发给服务器。服务器响应给代理主机，代理主机接收后，自己重新构建响应报文，发送给客户端。client到server之间，不会知对方真实面目</li></ul><p>要在新加坡服务器上设置反向代理以代理洛杉矶服务器上的 Hexo 博客，你可以按照以下步骤操作：</p><ol><li><p><strong>安装 Nginx</strong>：确保在新加坡服务器上安装了 Nginx。你可以使用适合你操作系统的包管理器来安装它。比如，在 Ubuntu 上，你可以运行 <code>sudo apt update</code> 和 <code>sudo apt install nginx</code> 来安装 Nginx。</p></li><li><p><strong>配置 Nginx 反向代理</strong>：编辑 Nginx 的配置文件以设置反向代理。</p><p>在新加坡服务器上找到 Nginx 的配置文件，通常在 <code>/etc/nginx/sites-available/</code> 目录下。你可以创建一个新的配置文件，比如 <code>isgeek.top</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 80;    server_name www.123.top;    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;111.111.111.111:80;         proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个配置会将所有来自 <code>www.isgeek.top</code> 的请求转发到洛杉矶服务器上的 Hexo 博客。</p></li><li><p><strong>启用配置文件</strong>：在 <code>/etc/nginx/sites-enabled/</code> 目录中创建符号链接，将配置文件链接到 <code>sites-available</code> 中。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;123.top &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>重新加载 Nginx</strong>：重新加载 Nginx，使配置生效。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl reload nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>现在，当访问 <code>www.123.top</code> 时，请求将被转发到洛杉矶服务器上的 Hexo 博客。请确保新加坡服务器上的防火墙允许流量通过端口 80（如果使用了其他端口，也需要打开相应的端口）。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>配置如下,希望能通过ip+端口访问该路径的文件,但是一直是<strong>welcom to nginx</strong>,也就是nginx的默认界面,我还以为是自定义配置没有生效,结果是<strong>默认配置</strong>的锅🥘</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 80;    root &#x2F;home; # 网站目录的路径    #server_name www.isgeek.top; # 你的域名    #root &#x2F;home&#x2F;hexo; # 网站目录的路径    location &#x2F; &#123;        try_files $uri $uri&#x2F; &#x3D;404;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原因:</strong></p><p><code>/etc/nginx/sites-available</code>的default文件,默认配置直接访问80端口的页面,所以只需要删掉或者注释掉即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Default server configurationserver &#123;listen 80 default_server;listen [::]:80 default_server;# SSL configuration## listen 443 ssl default_server;# listen [::]:443 ssl default_server;root &#x2F;var&#x2F;www&#x2F;html;# Add index.php to the list if you are using PHPindex index.html index.htm index.nginx-debian.html;server_name _;#location &#x2F; &#123;# First attempt to serve request as file, then# as directory, then fall back to displaying a 404.#try_files $uri $uri&#x2F; &#x3D;404;#&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 80;    root &#x2F;home; # 网站目录的路径    #server_name www.isgeek.top; # 你的域名    #root &#x2F;home&#x2F;hexo; # 网站目录的路径    location &#x2F; &#123;        try_files $uri $uri&#x2F; &#x3D;404;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>不能用ipv4反代ipv6啊小傻瓜😢</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反代</p><ul><li><p>可以是同一台机器的一个端口反代另一个端口</p></li><li><p>也可以是代理服务器反代目标地址</p></li></ul><p>代理服务器的nginx配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 80;    server_name www.isgeek.top;    #绑定代理服务器(本机)ip地址    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;ip;  # 目标服务器的IP和端口        #proxy_pass https:&#x2F;&#x2F;www.bilibili.com&#x2F;;  # 直接跳b站    &#125;&#125;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡\"></a>负载均衡\</h2><p><strong>个人理解</strong></p><blockquote><p>负载均衡就是多台服务器搭建同一个网站,然后你访问代理服务器,转发到任意或者固定的一台服务器,实现负载均衡</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream backend_servers &#123;     server ip;          # 多台搭建同一网站的服务器ip     server ip;       &#125;server &#123;    listen 80;    server_name www.isgeek.top;    #绑定本机ip地址    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;backend_servers;                  proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;    &#125;&#125;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="%5B%E3%80%90nginx%E5%85%A5%E9%97%A8%E3%80%91nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%95%99%E7%A8%8B_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1Bx411Z7Do/?spm_id_from=333.337.search-card.all.click)">b站大佬关于nginx负载均衡的讲解</a></p><p><a href="https://blog.csdn.net/weixin_45490198/article/details/131357591">Nginx-反向代理详解</a></p><p><a href="https://cloud.tencent.com/developer/article/1985011">nginx快速入门+反向代理hexo个人博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>💻F1200S_linux小电脑</title>
      <link href="/2023/10/06/83l-linux-xiao-dian-nao/"/>
      <url>/2023/10/06/83l-linux-xiao-dian-nao/</url>
      
        <content type="html"><![CDATA[<p>稚晖君大佬的项目</p><p><a href="https://github.com/peng-zhihui/Planck-Pi">GitHub - peng-zhihui&#x2F;Planck-Pi: Super TINY &amp; Low-cost Linux Develop-Kit Based On F1C200s.</a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>读卡器、TF卡</p></li><li><p><a href="http://wiki.lcmaker.com/index.php?title=LC-PI-200S">官方LC-PI-200S</a></p><p><a href="https://whycan.com/t_7275.html">小白自制Linux开发板(F1C200s)整理系列，持续更新中 &#x2F; 全志 SOC &#x2F; WhyCan Forum(哇酷开发者社区)</a></p></li></ul><h2 id="镜像烧录"><a href="#镜像烧录" class="headerlink" title="镜像烧录"></a>镜像烧录</h2><ol><li>烧到Flash中</li><li>烧到TF卡中</li></ol><p>烧录的系统为buildroot，是专门为嵌入式系统准备的，没有apt等命令，需要编译</p><h3 id="烧录到flash"><a href="#烧录到flash" class="headerlink" title="烧录到flash"></a>烧录到flash</h3><ul><li><p><a href="https://blog.csdn.net/Chhjnavy/article/details/126269006">安装usb驱动</a></p></li><li><p><a href="https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/get_started/first_eye.html#Nano-%E6%89%8B%E5%86%8C%E8%B5%84%E6%96%99">荔枝派</a></p></li></ul><h3 id="烧录到TF卡"><a href="#烧录到TF卡" class="headerlink" title="烧录到TF卡"></a>烧录到TF卡</h3><p>使用<strong>Win32DiskImager</strong>烧录即可</p><ul><li>用户名：root</li><li>密码：licheepi</li><li>大佬弄好的镜像没有密码</li></ul><h2 id="串口连接"><a href="#串口连接" class="headerlink" title="串口连接"></a>串口连接</h2><p>波特率：115200</p><h2 id="问题小结"><a href="#问题小结" class="headerlink" title="问题小结"></a>问题小结</h2><p><strong>24&#x2F;9&#x2F;15</strong></p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ol><li><p>格式化后磁盘只显示15.8M，还以为坏了，实际上是未分配<img src="/2023/10/06/83l-linux-xiao-dian-nao/image-20240915181900268.png" class="" title="image-20240915181900268"></p><img src="/2023/10/06/83l-linux-xiao-dian-nao/image-20240915181940275.png" class="" title="image-20240915181940275"></li><li><p><strong>无法直接运行 NES 游戏文件 (<code>.nes</code>)</strong>：你尝试直接执行 NES 游戏文件，结果报错，因为 <code>.nes</code> 是游戏 ROM 文件，需要通过 NES 模拟器来运行。</p></li><li><p><strong>系统缺少包管理器和常见工具 (<code>apt-get</code>, <code>git</code>, <code>sudo</code>)</strong>：Buildroot 系统是精简的嵌入式系统，缺少包管理工具和其他常见的工具，无法通过传统方式安装软件。</p></li><li><p><strong>通过串口连接系统，没有网络</strong>：你是通过串口连接 Buildroot 系统，没有直接的网络访问，无法在线下载软件。</p></li><li></li></ol><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ol><li>都删掉，重新建卷</li><li><strong>确认 Buildroot 系统特性</strong>：Buildroot 没有包管理工具，需要手动下载并传输软件或源码到系统。</li><li><strong>下载 NES 模拟器源码</strong>：<ul><li>在主机上（有网络连接的电脑），下载 NES 模拟器 <code>fceux</code> 的源码（从 GitHub 或其他网站下载）。</li></ul></li><li><strong>通过串口上传文件</strong>：<ul><li>使用串口工具（如 <code>minicom</code>）配合 <code>rz</code> 命令，将下载的源码或预编译的二进制文件通过串口传输到 Buildroot 系统。</li></ul></li><li><strong>编译或运行 NES 模拟器</strong>：<ul><li>在 Buildroot 系统上编译 <code>fceux</code>（如有编译工具），或者在主机上交叉编译后传输已编译的可执行文件到 Buildroot。</li></ul></li><li><strong>运行 NES 游戏</strong>：<ul><li>使用 <code>fceux</code> 模拟器运行 <code>.nes</code> 游戏文件。</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言IDE环境搭建</title>
      <link href="/2023/09/08/82c-c-yu-yan-ide-huan-jing-da-jian/"/>
      <url>/2023/09/08/82c-c-yu-yan-ide-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="DEV-C"><a href="#DEV-C" class="headerlink" title="DEV-C++"></a>DEV-C++</h2><p><a href="http://www.taodudu.cc/news/show-140098.html?action=onClick">Dev-C++安装和使用教程（手把手傻瓜式教学） (taodudu.cc)</a></p><p>调试方法</p><p><a href="https://blog.csdn.net/weixin_42212753/article/details/104105692">DEVC++单步调试方法（详细步骤）_devc++怎么单步调试_疯狂的Alex的博客-CSDN博客</a></p><h2 id="VS2022"><a href="#VS2022" class="headerlink" title="VS2022"></a>VS2022</h2><p><a href="https://blog.csdn.net/qq_38332975/article/details/128339226">c语言环境搭建（vs）2022版_vs搭建c语言环境_ら、缘未尽的博客-CSDN博客</a></p><p>主要是这个</p><p><img src="/2023/09/08/82c-c-yu-yan-ide-huan-jing-da-jian/image-20230908211213888.png" alt="image-20230908211213888"></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>🐍JS逆向网校</title>
      <link href="/2023/09/02/81p-js-ni-xiang-wang-xiao/"/>
      <url>/2023/09/02/81p-js-ni-xiang-wang-xiao/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>观察到<code>password为目标</code>,所需数据为<code>user,password的加密,以及验证码</code></p><p>获取验证图片-&gt;打码网站-&gt;找到加密密码位置</p><img src="/2023/09/02/81p-js-ni-xiang-wang-xiao/image-20230902090227692.png" class="" title="image-20230902090227692"><img src="/2023/09/02/81p-js-ni-xiang-wang-xiao/image-20230902090015782.png" class="" title="image-20230902090015782"><img src="/2023/09/02/81p-js-ni-xiang-wang-xiao/image-20230902090031385.png" class="" title="image-20230902090031385"><p>但是ajax是异步请求,所以跳不进去</p><img src="/2023/09/02/81p-js-ni-xiang-wang-xiao/image-20230902090403249.png" class="" title="image-20230902090403249"><h2 id="逆向passwd"><a href="#逆向passwd" class="headerlink" title="逆向passwd"></a>逆向passwd</h2><img src="/2023/09/02/81p-js-ni-xiang-wang-xiao/image-20230902092312514.png" class="" title="image-20230902092312514"><p>​          password: encryptFn(pwd + ‘’ + ress.data),</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function-variable function">encryptFn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSEncrypt</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> o<span class="token punctuation">.</span><span class="token function">setPublicKey</span><span class="token punctuation">(</span><span class="token string">"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDA5Zq6ZdH/RMSvC8WKhp5gj6Ue4Lqjo0Q2PnyGbSkTlYku0HtVzbh3S9F9oHbxeO55E8tEEQ5wj/+52VMLavcuwkDypG66N6c1z0Fo2HgxV3e0tqt1wyNtmbwg7ruIYmFM+dErIpTiLRDvOy+0vgPcBVDfSUHwUSgUtIkyC47UNQIDAQAB"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        o<span class="token punctuation">.</span><span class="token function">encrypt</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token class-name">JSEncrypt</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">encrypt</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">hex2b64</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encrypt</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">!</span><span class="token number">1</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>RSA公钥加密</strong></p><img src="/2023/09/02/81p-js-ni-xiang-wang-xiao/image-20230902105341594.png" class="" title="image-20230902105341594"><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>刚进入界面即使什么都没有点,就已经在发cookie了</li></ul><p>解决:&gt;session.get(主界面)</p><img src="/2023/09/02/81p-js-ni-xiang-wang-xiao/image-20230902151320406.png" class="" title="image-20230902151320406"><ul><li><p>登录为什么不需要一面的cookie,而获取题目需要</p></li><li><p>构建完password,不去构建cookie吗\</p><blockquote><p>构建完password直接反悔了,没有继续,也就是说登陆的时候并没有给这个cookie</p></blockquote></li></ul><img src="/2023/09/02/81p-js-ni-xiang-wang-xiao/image-20230902190814440.png" class="" title="image-20230902190814440"><p>res是登录后的返回值,即登陆成功执行cookie函数</p><img src="/2023/09/02/81p-js-ni-xiang-wang-xiao/image-20230902191311556.png" class="" title="image-20230902191311556"><ul><li>不找到为什么code会从1变成9</li><li>断点没有取消,进入别的请求了</li></ul><img src="/2023/09/02/81p-js-ni-xiang-wang-xiao/image-20230902193032863.png" class="" title="image-20230902193032863">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>🐍JS逆向看准网</title>
      <link href="/2023/09/01/80p-js-ni-xiang-kan-zhun-wang/"/>
      <url>/2023/09/01/80p-js-ni-xiang-kan-zhun-wang/</url>
      
        <content type="html"><![CDATA[<h2 id="多个url"><a href="#多个url" class="headerlink" title="多个url"></a>多个url</h2><p>就是一个函数会发送多个请求,确保打断点的请求为你需要的</p><p>一直跳找到正确的请求,然后再向前找堆栈</p><blockquote><p>这种时候可以找一个支出法一个请求的按钮,替换刷新</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>搜索关键字或路径</li><li>查找堆栈</li><li>逐个进入</li></ul><h2 id="获取param"><a href="#获取param" class="headerlink" title="获取param"></a>获取param</h2><img src="/2023/09/01/80p-js-ni-xiang-kan-zhun-wang/image-20230901152749884.png" class="" title="image-20230901152749884"><p>注意加密之后的b进行replace</p><img src="/2023/09/01/80p-js-ni-xiang-kan-zhun-wang/image-20230901210506972.png" class="" title="image-20230901210506972"><img src="/2023/09/01/80p-js-ni-xiang-kan-zhun-wang/image-20230901152937915.png" class="" title="image-20230901152937915"><img src="/2023/09/01/80p-js-ni-xiang-kan-zhun-wang/image-20230901154028133.png" class="" title="image-20230901154028133"><p>进入</p><img src="/2023/09/01/80p-js-ni-xiang-kan-zhun-wang/image-20230901154245020.png" class="" title="image-20230901154245020"><img src="/2023/09/01/80p-js-ni-xiang-kan-zhun-wang/image-20230901202624173.png" class="" title="image-20230901202624173"><img src="/2023/09/01/80p-js-ni-xiang-kan-zhun-wang/image-20230901202554617.png" class="" title="image-20230901202554617"><p>解密</p><ul><li><p>搜索parse序列化,字典转json</p></li><li><p>搜索interceptor(拦截器),发起请求和接收响应都会用到</p></li></ul><img src="/2023/09/01/80p-js-ni-xiang-kan-zhun-wang/image-20230901230839509.png" class="" title="image-20230901230839509"><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>不知道为什么断电不断在函数处,而是断在函数结尾,与之前遇见的直接跳过断点相似</p><p>对的,打在那里的断点不停</p><p><strong>gpt</strong>:</p><p>这可能是因为 JavaScript 引擎的优化或者调试器的工作方式造成的。这并不一定意味着代码执行逻辑发生了错误，而是调试器在显示断点时的表现。</p><p>在你的情况下，如果断点跳到了 <code>i.request(r)</code> 处，而不是 <code>var a = function(e) &#123;</code> 处，这可能是因为调试器认为在后者设置断点不会有效，或者是因为 JavaScript 引擎的执行逻辑使得它更自然地在 <code>i.request(r)</code> 处停下来。这不一定意味着代码有错误，只是调试器的行为可能会根据具体情况而异。你仍然可以通过单步执行和观察变量值来分析代码的执行流程。</p><h3 id="interceptor-request"><a href="#interceptor-request" class="headerlink" title="interceptor_request"></a>interceptor_request</h3><p>interceptor_request找到发起请求的地方是否可行</p><blockquote><p>可行,也需要一层层向上找</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🔋有道翻译js逆向</title>
      <link href="/2023/08/27/79p-js-ni-xiang/"/>
      <url>/2023/08/27/79p-js-ni-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="🔋思路"><a href="#🔋思路" class="headerlink" title="🔋思路"></a>🔋思路</h2><p>找到获得数据的请求-&gt;逆向得到构建数据的请求-&gt;模拟获得加密的数据-&gt;找到解密的函数</p><h2 id="找到获取数据的请求"><a href="#找到获取数据的请求" class="headerlink" title="找到获取数据的请求"></a>找到获取数据的请求</h2><img src="/2023/08/27/79p-js-ni-xiang/image-20230827201932012.png" class="" title="image-20230827201932012"><p>这个得到的是个加密数据</p><img src="/2023/08/27/79p-js-ni-xiang/image-20230827202100847.png" class="" title="image-20230827202100847"><p>这个一看就不是,啥数据也没有</p><img src="/2023/08/27/79p-js-ni-xiang/image-20230827201949623.png" class="" title="image-20230827201949623"><h3 id="构建表单"><a href="#构建表单" class="headerlink" title="构建表单"></a>构建表单</h3><p>多试几次找到表单中变化的数据,即目标</p><p><strong>一般sign与time时间戳为动态数据</strong></p><p>这个比较特殊,经过测试,发现时间只要随便一个就可以,也就是说对方服务器没有对时间戳进行验证</p><img src="/2023/08/27/79p-js-ni-xiang/image-20230827203315907.png" class="" title="image-20230827203315907"><h3 id="发起程序"><a href="#发起程序" class="headerlink" title="发起程序"></a>发起程序</h3><p><strong>这一步也可以进行全局搜索,地址末尾变量名webtranslate,或直接搜索变量sign</strong></p><ul><li><p>定位到发起请求的位置后,开始观察</p></li><li><p>执行到哪个函数数据出现,注意变量传参时的位置</p><p>注: ({()&#x3D;123,是将123作为返回值返回},打断点,控制台打印值)</p></li></ul><img src="/2023/08/27/79p-js-ni-xiang/image-20230827203019749.png" class="" title="image-20230827203019749"><p>找到发起程序的第一个,就是这个代码发送了这个请求,此时动态数据应该已经构建完毕</p><img src="/2023/08/27/79p-js-ni-xiang/image-20230827203934544.png" class="" title="image-20230827203934544"><img src="/2023/08/27/79p-js-ni-xiang/image-20230827203948539.png" class="" title="image-20230827203948539"><p>同时也要注意,一个函数会发起好几个请求,看此次发的请求是否正确</p><p>也可直接回车发送对应请求</p><img src="/2023/08/27/79p-js-ni-xiang/image-20230827204141254.png" class="" title="image-20230827204141254"><p>现在sign存在,找到sign消失的位置,说明执行此函数后sign生成</p><img src="/2023/08/27/79p-js-ni-xiang/image-20230828091313627.png" class="" title="image-20230828091313627"><img src="/2023/08/27/79p-js-ni-xiang/image-20230828105240649.png" class="" title="image-20230828105240649"><p>找堆栈时时调用此函数的函数,而在debug时,是正常执行的,也就是说现在没有sign,下一步出现,则说明此函数生成sign</p><p>此时一个一个断点打,发现sign没出现,跳到下一个函数,sign出现了,书名中间还有其他函数,也就是这个C</p><p>明明打断点了为啥没断呢</p><img src="/2023/08/27/79p-js-ni-xiang/image-20230828105312866.png" class="" title="image-20230828105312866"><img src="/2023/08/27/79p-js-ni-xiang/image-20230828105628119.png" class="" title="image-20230828105628119"><p>直接进去了</p><img src="/2023/08/27/79p-js-ni-xiang/image-20230828113357698.png" class="" title="image-20230828113357698"><img src="/2023/08/27/79p-js-ni-xiang/image-20230828113609387.png" class="" title="image-20230828113609387"><img src="/2023/08/27/79p-js-ni-xiang/image-20230828114259341.png" class="" title="image-20230828114259341"><img src="/2023/08/27/79p-js-ni-xiang/image-20230828113751240.png" class="" title="image-20230828113751240"><p>注意e,t调换,并且,.digest与degest(“hex不同”)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">obj.hexdigest()md5.digest()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2023/08/27/79p-js-ni-xiang/image-20230828171507692.png" class="" title="image-20230828171507692"><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p><strong>第一种</strong></p><p>解密入口,因为他是发起请求的函数,也就是说发送完请求应该就会接收相应数据</p><img src="/2023/08/27/79p-js-ni-xiang/image-20230830120914954.png" class="" title="image-20230830120914954"><p>解密函数</p><img src="/2023/08/27/79p-js-ni-xiang/image-20230830120313070.png" class="" title="image-20230830120313070"><p><strong>第二种</strong></p><p>在加密上面找到了解密函数</p><p>直接打断点,看哪里调用了它,即在哪解密</p><p>看是否是静态数据,如果是,那他爱咋来咋来,直接拿key,还是得看一下<code>aes-128-cbc</code></p><img src="/2023/08/27/79p-js-ni-xiang/image-20230828124355186.png" class="" title="image-20230828124355186"><img src="D:\blog\source\_posts\79P-JS逆向\image-20230828123416791.png" alt="image-20230828123416791"  /><p>解密<br>获取sign值的函数是一个promise,构建发送请求的promise的信息的位置,谁调用的y,谁发出去的请求,并且解析响应,<br>有一then,前面是请求,后面是解析响应的</p><h2 id="js逆向"><a href="#js逆向" class="headerlink" title="js逆向"></a>js逆向</h2><h2 id="搭建api"><a href="#搭建api" class="headerlink" title="搭建api"></a>搭建api</h2><h2 id="问题-未解决"><a href="#问题-未解决" class="headerlink" title="问题_未解决"></a>问题_未解决</h2><img src="/2023/08/27/79p-js-ni-xiang/image-20230828234626634.png" class="" title="image-20230828234626634"><img src="/2023/08/27/79p-js-ni-xiang/image-20230828234640331.png" class="" title="image-20230828234640331"><p>因为jsonify会将中文转为unicode,json.dump也会,但是<code>ensure_ascii=False</code>会保留原数据</p><ol><li><code>json.dumps(response_data, ensure_ascii=False)</code>：将字典数据 <code>response_data</code> 转换为 JSON 字符串，保持其中的中文字符不被转义编码。</li><li><code>json.loads(...)</code>：将上一步得到的 JSON 字符串解析回字典数据。</li></ol><p>电脑刘浏览器预览可见汉字,但是手机浏览器不可以</p><p>在JSON数据中，<code>\uXXXX</code> 形式的表示是 Unicode 字符的转义形式，其中 <code>\u</code> 表示 Unicode 转义，<code>XXXX</code> 是一个四位的十六进制 Unicode 编码。</p><p>浏览器会自动将这种转义形式的 Unicode 编码转换为对应的字符,手机浏览器可能不会自动将 Unicode 转义编码转换为对应字符</p><h3 id="json-load与-json-loads的区别"><a href="#json-load与-json-loads的区别" class="headerlink" title="json.load与 json.loads的区别"></a>json.load与 json.loads的区别</h3><ol><li><code>json.load</code>：<ul><li>用于从文件中加载 JSON 数据。</li><li>接收一个文件对象作为参数，将 JSON 数据从文件中读取并解析。</li><li>用法示例：<code>json.load(file_object)</code></li></ul></li><li><code>json.loads</code>：<ul><li>用于将 JSON 字符串解析为 Python 数据结构（通常是字典或列表）。</li><li>接收一个 JSON 字符串作为参数，将其解析成对应的 Python 数据结构。</li><li>用法示例：<code>json.loads(json_string)</code></li></ul></li></ol><h2 id="限制请求次数"><a href="#限制请求次数" class="headerlink" title="限制请求次数"></a>限制请求次数</h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NE555信号发生器</title>
      <link href="/2023/08/26/78h-ne555-xin-hao-fa-sheng-qi/"/>
      <url>/2023/08/26/78h-ne555-xin-hao-fa-sheng-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="信号发生器"><a href="#信号发生器" class="headerlink" title="信号发生器"></a>信号发生器</h2><p>用stm32也能做,就是浪费引脚,相当于只用了定时器</p><img src="/2023/08/26/78h-ne555-xin-hao-fa-sheng-qi/image-20230826093143661.png" class="" title="image-20230826093143661"><h2 id="NE555"><a href="#NE555" class="headerlink" title="NE555"></a>NE555</h2><p><a href="http://www.ndfweb.cn/news-774.html">3种NE555可调频率信号发生器电路图 (ndfweb.cn)</a></p><p><a href="https://www.ngui.cc/zz/1538223.html?action=onClick">基于NE555芯片设计占空比可调的方波信号发生器 (ngui.cc)</a></p><p><a href="https://item.taobao.com/item.htm?scm=1007.11837.279802.0&id=675362938000&pvid=e7b7b27d-7101-4789-81a2-7a0cf90cc1fe">(散件)NE555方波信号发生器 脉冲波形输出模块焊接套件 电子实训-淘宝网 (taobao.com)</a></p><p><a href="https://oshwhub.com/studingstudent/led-qu-dong">优雅的PWM调速器 - 嘉立创EDA开源硬件平台 (oshwhub.com)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>继电器模块</title>
      <link href="/2023/08/24/77h-ji-dian-qi-mo-kuai/"/>
      <url>/2023/08/24/77h-ji-dian-qi-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h2 id="继电器"><a href="#继电器" class="headerlink" title="继电器"></a>继电器</h2><h3 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h3><img src="/2023/08/24/77h-ji-dian-qi-mo-kuai/image-20230824173908001.png" class="" title="image-20230824173908001"><h3 id="工作参数"><a href="#工作参数" class="headerlink" title="工作参数"></a>工作参数</h3><img src="/2023/08/24/77h-ji-dian-qi-mo-kuai/image-20230824174027030.png" class="" title="image-20230824174027030"><p><strong>问题</strong>:</p><p>1.继电器有型号,5V,12V,24V之分,VCC输入</p><p>2.5V继电器低电平有效,单片机控制高低电平都有效</p><p>   原因:继电器内部是一个NPN三极管,集电极VCC,基极IO,当输出低电平时,三极管导通,当输出5V时,三极管截止</p><p>   BUT:STM32引脚拉高,只能拉高到3.3V,会导致继续导通,所以就是高低电平都导通</p><p>3.3.3V输入,灯亮,会有不吸合的现象</p><p>可能的原因:5V继电器的磁铁,3.3V吸力可能不够</p><p>新的5V继电器单片机可以正常驱动,兼容3.3v</p><p>上述问题是在比较旧的两路继电器上发生的,新的继电器可以使用,我想知道两种继电器电路的区别</p><img src="/2023/08/24/77h-ji-dian-qi-mo-kuai/image-20230824200904908.png" class="" title="image-20230824200904908"><h2 id="三极管原理链接"><a href="#三极管原理链接" class="headerlink" title="三极管原理链接"></a>三极管原理链接<a href=""></a></h2><h2 id="普通继电器"><a href="#普通继电器" class="headerlink" title="普通继电器"></a>普通继电器</h2><img src="/2023/08/24/77h-ji-dian-qi-mo-kuai/image-20230824210414714.png" class="" title="image-20230824210414714"><h2 id="光耦隔离继电器"><a href="#光耦隔离继电器" class="headerlink" title="光耦隔离继电器"></a>光耦隔离继电器</h2><h3 id="3-3v输入能驱动5v继电器原理"><a href="#3-3v输入能驱动5v继电器原理" class="headerlink" title="3.3v输入能驱动5v继电器原理"></a>3.3v输入能驱动5v继电器原理</h3><blockquote><p>这种继电器模块基本上都有<code>光耦隔离模块</code>,相当于一个三极管,就是之前有人提到过的,单片机接一个三极管之后在接继电器模块</p></blockquote><img src="/2023/08/24/77h-ji-dian-qi-mo-kuai/image-20230824205729966.png" class="" title="image-20230824205729966"><blockquote><p>加一个二极管同理也可以实现高电平截止的效果(这个好像不太行)</p></blockquote><p>2.二极管1N4148起到续流的作用。因为继电器电磁线圈是感性元件，继电器由开到关的瞬间会产生极大的反向电压，加上续流二极管可以使其形成回路（如图所示），从而保护其他元件。</p><p>3.光耦的作用：保护微控制器**，加上光耦进行<strong>隔离</strong>；此外，通过光耦还可以控制大电压，即光耦输入和输出端所连接的VCC可以不同，光耦输出端的VCC可以更大，如12V。</p><p>4.需要注意的是：光耦的输入端也相当于一个发光二极管（<strong>有正向导通压降，约1.2V</strong>），如果VCC为3.3V等较低的电压，当选用的LED1正向压降过大，<strong>即使输入为低电平也不会令光耦导通。</strong>（LED1选择时需注意：<strong>不同的颜色压降也不相同，相差甚至能达到2~3V</strong>，具体看元件参数）<br>例如：VCC&#x3D;+3.3V，LED1的正向导通电压&#x3D;3.2V，光耦输入端的正向导通电压&#x3D;1.2V。那么，VCC则不足以使输入电路导通。</p><p>当电压条件满足后，还需要考虑光耦的导通电流（<strong>一般为1~20mA</strong>），如果输入端电流过小，那么光耦输入端的发光二极管发光不足，也不能使光耦输出端三极管导通。<strong>而输入电流大小则由电阻R1控制</strong>。<br>例如：VCC&#x3D;3.3V，Vfled1&#x3D;1.8V，Vfpc&#x3D;1.2V，那么可以使光耦正常工作的最大电阻R1&#x3D;（3.3-1.8-1.2）&#x2F;0.001&#x3D;300Ω。</p><p>5.选用3V继电器时，“3V”是<strong>继电器额定电压</strong>，继电器还有个最小工作电压（又叫做<strong>吸合电</strong>压，一般为75~80%的额定电压），继电器输入端达到此电压即可吸合但可能不够稳定。</p><p>6.限流电阻R2的取值和前面三极管开关电路类似，即要考虑继电器的工作电流和三极管放大倍数。</p><p><a href="https://blog.csdn.net/chenhuanqiangnihao/article/details/119740727?ops_request_misc=%7B%22request_id%22:%22169284461416800211588628%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169284461416800211588628&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119740727-null-null.142%5Ev93%5Einsert_down28v1&utm_term=%E7%BB%A7%E7%94%B5%E5%99%A8%E6%A8%A1%E5%9D%97%E5%8E%9F%E7%90%86%E5%9B%BE&spm=1018.2226.3001.4187">【继电器模块的电路设计和分析】_继电器模块原理图</a></p><p><a href="https://blog.csdn.net/Dallin0408/article/details/49495933?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-49495933-blog-119740727.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-49495933-blog-119740727.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=7">继电器驱动电路设计题</a></p><p><a href="https://blog.csdn.net/OMGMac/article/details/124773569?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-124773569-blog-119740727.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-124773569-blog-119740727.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=3">常用继电器模块的PCB设计与实物分享</a></p><p><a href="https://www.zhihu.com/question/19998995">三极管是如何导通的？ - 知乎 (zhihu.com)</a></p><p><a href="https://it.cha138.com/mysql/show-3480383.html">三极管_stm32通过三极管驱动继电器电路详解 (cha138.com)</a></p><p><a href="https://betheme.net/dashuju/101898.html?action=onClick">【继电器】STM32驱动继电器常见问题汇总 (betheme.net)</a></p><p><a href="https://blog.csdn.net/lx123010/article/details/122967176">三极管开关作用_3极管的开关作用和工作原理</a></p><p><a href="https://blog.csdn.net/chenhuanqiangnihao/article/details/119740727?ops_request_misc=%7B%22request_id%22:%22169284461416800211588628%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169284461416800211588628&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119740727-null-null.142%5Ev93%5Einsert_down28v1&utm_term=%E7%BB%A7%E7%94%B5%E5%99%A8%E6%A8%A1%E5%9D%97%E5%8E%9F%E7%90%86%E5%9B%BE&spm=1018.2226.3001.4187">【继电器模块的电路设计和分析】_继电器模块原理图_学海无涯</a></p><p><a href="https://blog.csdn.net/qq_34118600/article/details/116272806?ops_request_misc=&request_id=&biz_id=102&utm_term=%E4%B8%89%E6%9E%81%E7%AE%A1%E7%9A%84%E5%BC%80%E5%85%B3%E4%BD%9C%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-116272806.142%5Ev93%5Einsert_down28v1&spm=1018.2226.3001.4187">电子电路基础 （9）——三极管的构造与工作原理及使用_csdn 三极管 电路</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Auto360与3D打印</title>
      <link href="/2023/08/24/76h-auto360-yu-3d-da-yin/"/>
      <url>/2023/08/24/76h-auto360-yu-3d-da-yin/</url>
      
        <content type="html"><![CDATA[<h2 id="3D建模"><a href="#3D建模" class="headerlink" title="3D建模"></a>3D建模</h2><p>善用阵列分布</p><h2 id="打印模型"><a href="#打印模型" class="headerlink" title="打印模型"></a>打印模型</h2><p>makerbot官网打印软件(要点魔法,并且需要注册)</p><p><a href="https://www.makerbot.com/3d-printers/cloudprint/">www.makerbot.com</a></p><p><a href="https://www.makerbot.com/3d-printers/apps/makerbot-print/download/">下载创客机器人打印 3D 打印软件 |创客机器人3D打印机 (makerbot.com)</a></p><p>选择的打印机并选择“打印”或“<strong>导出</strong>”按钮，该按钮将位于同一位置，具体取决于您向打印机发送<strong>打印</strong>件的方式。</p><p>如果您已连接到打印机，打印机将自动开始发热。如果要导出文件，则需要将文件导出（.makerbot）格式的文件(<code>文件名字不能有中文</code>)到 USB 跳转驱动器并将其带到打印机。</p><p>也就是说:export既是print又是export</p><p><a href="https://support.makerbot.com/s/article/MakerBot-Print-Quick-Guide">使用手册Quick Start Guide (MakerBot Print)</a></p><p>[手册](<a href="https://www.docin.com/p-1097912491.html">makerbot replicator桌面3D打印机5代 - 豆丁网 (docin.com)</a>)</p><p>[手册](<a href="https://www.docin.com/p-2154283814.html">MakerBot五代机使用指南手册 - 豆丁网 (docin.com)</a>)</p><p>[使用测评](<a href="http://www.360doc.com/content/12/0121/07/73087893_953465250.shtml">3D打印机MakerBot Replicator+使用评测 (360doc.com)</a>)</p><p><a href="https://www.bilibili.com/video/BV1nx41157n9/?spm_id_from=333.337.search-card.all.click">makerbot打印机使用教程</a></p><p>2024.3.14更新</p><h2 id="基操"><a href="#基操" class="headerlink" title="基操"></a>基操</h2><p>shift+鼠标中键</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><img src="/2023/08/24/76h-auto360-yu-3d-da-yin/image-20240315170117165.png" class="" title="image-20240315170117165"><img src="/2023/08/24/76h-auto360-yu-3d-da-yin/image-20240315170835322.png" class="" title="image-20240315170835322"><img src="/2023/08/24/76h-auto360-yu-3d-da-yin/image-20240315171509279.png" class="" title="image-20240315171509279"><p>原则上来讲只要建里的时候选合并就不会有线了</p><p>注意: 建模时, 一个实体一个实体建</p><img src="/2023/08/24/76h-auto360-yu-3d-da-yin/image-20240315181903188.png" class="" title="image-20240315181903188"><p>要在实体那面建草图拉出来才能合并</p><h2 id="关于误差"><a href="#关于误差" class="headerlink" title="关于误差"></a>关于误差</h2><p>M3螺丝,孔径3.2</p><h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><p>修改草图, 实体会跟着一块修改</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>矩阵按键</title>
      <link href="/2023/08/22/75h-ju-zhen-an-jian/"/>
      <url>/2023/08/22/75h-ju-zhen-an-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h2><h3 id="低电平触发按键"><a href="#低电平触发按键" class="headerlink" title="低电平触发按键"></a>低电平触发按键</h3><p>按键一端接GND,一端接IO口,低电平有效</p><h3 id="高电平触发按键"><a href="#高电平触发按键" class="headerlink" title="高电平触发按键"></a>高电平触发按键</h3><img src="/2023/08/22/75h-ju-zhen-an-jian/image-20230823121608901.png" class="" title="image-20230823121608901"><p>KEY0 和 KEY1 用作普通按键输入，并没有使用外部上拉电阻</p><p>KEY_UP键除了可以用作普通输入按键外，还可以用作STM32的唤醒输入</p><p>注意：这个按键是高电平触发的。当按键没按下时，CPU对应的I&#x2F;O接口由于内部有上拉电阻，其输入为高电平</p><p>下面这个,并联电容可以消抖<code>因为电容的电压不能突变(补充:电感的电流不能突变)</code>,按键未按下时，输入到STM32微控制器的电压为高电平,按键按下,电压全在电阻上,所以按下为低电平</p><p><strong>疑惑</strong>:直接接3.3v不可以吗,为什么非要上拉电阻呢? </p><blockquote><p><strong>上拉电阻</strong> 的本质是一种“弱驱动”拉高，它既给了线一个<strong>默认高电平</strong>，又在被拉低时<strong>限流保护</strong>。</p><p><strong>直接用导线拉高</strong> 相当于一个零欧姆的“强拉”，会在下拉时制造短路，瞬间毁坏元件或电源。——–2025.6.24</p></blockquote><img src="/2023/08/22/75h-ju-zhen-an-jian/image-20230823113758114.png" class="" title="image-20230823113758114"><p><a href="https://blog.csdn.net/weixin_56666706/article/details/128173648?spm=1001.2101.3001.6650.11&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-11-128173648-blog-106088238.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-11-128173648-blog-106088238.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=18">笔记（STM32篇）day6——按键控制_stm32按键原理图_NYMuggle的博客-CSDN博客</a></p><p><a href="https://www.elecfans.com/d/2004214.html">小编科普几种按键消抖电路的设计方案-电子发烧友网 (elecfans.com)</a></p><h1 id="矩阵按键"><a href="#矩阵按键" class="headerlink" title="矩阵按键"></a>矩阵按键</h1><p><strong>行线（Rows）</strong>：连接到 MCU 的若干个 GPIO 引脚，配置为输出（Output）。</p><p><strong>列线（Cols）</strong>：连接到 MCU 的若干个 GPIO 引脚，配置为输入（Input）并启用内部上拉（Pull-Up）或外部上拉电阻。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">for (i &#x3D; 0; i &lt; m; i++) &#123;    &#x2F;&#x2F; 1) 先将所有行拉高（不上）：    for (k &#x3D; 0; k &lt; m; k++)        digitalWrite(Row[k], HIGH);    &#x2F;&#x2F; 2) 再将当前行 Ri 拉低（下拉）：    digitalWrite(Row[i], LOW);    &#x2F;&#x2F; 3) 读取所有列：    for (j &#x3D; 0; j &lt; n; j++) &#123;        if (digitalRead(Col[j]) &#x3D;&#x3D; LOW) &#123;            &#x2F;&#x2F; 行 i、列 j 上有按键按下            key &#x3D; mapKey(i, j);            debounceAndReport(key);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：上拉输入时，未按下时读取为 HIGH，按下时行线拉低→列线被拉低，读取 LOW’</p><h2 id="基于中断的扫描"><a href="#基于中断的扫描" class="headerlink" title="基于中断的扫描"></a>基于中断的扫描</h2><p>基于中断的扫描（高级）</p><ul><li>将<strong>列线</strong>配置为外部中断（下降沿触发），当任何一列被拉低时触发中断；</li><li>中断服务程序中才执行“行扫描”来定位具体按键，大幅降低 MCU 的轮询负担，适合低功耗或多任务系统。</li></ul><h2 id="专用键盘扫描-IC"><a href="#专用键盘扫描-IC" class="headerlink" title="专用键盘扫描 IC"></a>专用键盘扫描 IC</h2><p>市面上有许多专门的矩阵键盘扫描器芯片（如 Holtek 的 HT16K33、Microchip 的 MCP23018 等），它们内部集成了行列驱动、消抖和多键检测。</p><ul><li><strong>接口</strong>：一般通过 I²C 或 SPI 与主控通信。</li><li><strong>优点</strong>：<ul><li>只需要 2 根总线线（I²C）或 4 根线（SPI）即可控制多达 8×8 或更大矩阵。</li><li>硬件消抖、抗鬼键、甚至带 LED 驱动。</li></ul></li><li><strong>缺点</strong>：增加了 BOM 成本，需要学习额外的芯片手册和寄存器操作。</li></ul><h2 id="GPIO-扩展器（I²C-SPI-I-O-Expander）"><a href="#GPIO-扩展器（I²C-SPI-I-O-Expander）" class="headerlink" title="GPIO 扩展器（I²C&#x2F;SPI I&#x2F;O Expander）"></a>GPIO 扩展器（I²C&#x2F;SPI I&#x2F;O Expander）</h2><p>如果项目中已有 I²C 总线或 SPI 总线，不想额外加专用键盘 IC，可以用通用 I&#x2F;O 扩展器（如 PCF8574、MCP23017、SX1509）。</p><ul><li><p><strong>原理</strong>：把行&#x2F;列接到扩展器，引脚上拉&#x2F;下拉同样能做矩阵扫描；有些扩展器还带中断引脚，可在任何输入状态改变时报警。</p></li><li><p><strong>典型接法</strong>：</p><pre class="line-numbers language-none"><code class="language-none">text复制编辑MCU ↔ I2C ↔ PCF8574             ┌───┐        P0 ──│   │── Row0        P1 ──│   │── Row1        …    │   │        P7 ──│   │── ColN             └───┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>特点</strong>：利用扩展器内部中断，可以混合“中断＋寄存器读扫描”方式，降低 MCU 轮询负担。</p></li></ul><hr><h2 id="3-模拟电压法（ADC-阶梯网络）"><a href="#3-模拟电压法（ADC-阶梯网络）" class="headerlink" title="3. 模拟电压法（ADC 阶梯网络）"></a>3. 模拟电压法（ADC 阶梯网络）</h2><p>将所有按键通过不同阻值接入同一个 ADC 通道，按下哪颗键就产生对应的电压值。</p><ul><li><strong>电路</strong>：在每个按键串联不同电阻，所有按键并联到 ADC 输入，另一端统一接地或 VCC。</li><li><strong>优点</strong>：只要一个 ADC 引脚即可检测 N×M 键；硬件极简。</li><li><strong>缺点</strong>：<ul><li>阶梯电阻值要精确，最多只能支持十几个键，一旦键数过多或多键同时按下，电压会叠加导致识别困难。</li><li>对电源噪声和 ADC 分辨率要求高，需要做软件滤波。</li></ul></li></ul><hr><h2 id="4-FPGA／CPLD-硬件扫描"><a href="#4-FPGA／CPLD-硬件扫描" class="headerlink" title="4. FPGA／CPLD 硬件扫描"></a>4. FPGA／CPLD 硬件扫描</h2><p>在资源充足的 FPGA 或 CPLD 设计中，把矩阵扫描逻辑写在可编程逻辑里：</p><ul><li><strong>优势</strong>：<ul><li>完全硬件实现，扫描周期可达几十纳秒级；</li><li>无需占用 MCU CPU 资源，也不受 MCU GPIO 数量限制；</li></ul></li><li><strong>局限</strong>：<ul><li>对学习曲线和板级设计有一定要求；</li><li>开发周期和成本相对较高，适合大批量或对实时性要求极高的场景。</li></ul></li></ul><hr><h2 id="5-DMA-定时器自动扫描（以-STM32-为例）"><a href="#5-DMA-定时器自动扫描（以-STM32-为例）" class="headerlink" title="5. DMA + 定时器自动扫描（以 STM32 为例）"></a>5. DMA + 定时器自动扫描（以 STM32 为例）</h2><p>部分高端 MCU（如 STM32 系列）支持将 GPIO 读写与 DMA、定时器联动：</p><ol><li>配置若干行口为定时器输出通道，每隔固定周期自动切换驱动行。</li><li>配置列口为普通输入，使用 DMA 将输入状态批量搬运到内存。</li><li>在 DMA 传输完成中断中解析哪个行列组合被按下。</li></ol><ul><li><strong>优点</strong>：<ul><li>扫描周期和时序由定时器&#x2F;DMA 硬件保证，抖动小；</li><li>CPU 只需在分析结果时参与，极大降低轮询开销。</li></ul></li><li><strong>缺点</strong>：<ul><li>需要对 MCU 的 DMA、定时器和 GPIO 复用有深入了解；</li><li>硬件资源占用较多。</li></ul></li></ul><hr><h2 id="6-电容式／电阻式触摸按键（Capacitive／Resistive-Touch）"><a href="#6-电容式／电阻式触摸按键（Capacitive／Resistive-Touch）" class="headerlink" title="6. 电容式／电阻式触摸按键（Capacitive／Resistive Touch）"></a>6. 电容式／电阻式触摸按键（Capacitive／Resistive Touch）</h2><p>如果不局限于机械按键，可以用电容或电阻触摸传感：</p><ul><li><strong>电容式</strong>：利用触摸引脚测量电容变化来判断是否触碰；通常单键，需要多路传感器或触摸控制 IC。</li><li><strong>电阻式</strong>：类似电位器，通过按压改变阻值；可接入模拟量采集或外部电路。</li><li><strong>场景</strong>：面板式触摸键、家电中高端触控界面。</li></ul><hr><h3 id="小结与选型建议"><a href="#小结与选型建议" class="headerlink" title="小结与选型建议"></a>小结与选型建议</h3><table><thead><tr><th>方法</th><th>硬件成本</th><th>MCU 占用</th><th>扩展性</th><th>实时性</th><th>适用场景</th></tr></thead><tbody><tr><td>专用键盘扫描 IC</td><td>中</td><td>极低</td><td>高</td><td>良好</td><td>大矩阵、抗鬼键、带背光键盘</td></tr><tr><td>I&#x2F;O 扩展器（PCF&#x2F;MCP）</td><td>低–中</td><td>低</td><td>中–高</td><td>良好</td><td>已有 I²C&#x2F;SPI 总线</td></tr><tr><td>模拟电压法（ADC）</td><td>低</td><td>低</td><td>低</td><td>一般</td><td>键数少、成本极限应用</td></tr><tr><td>FPGA&#x2F;CPLD 硬件扫描</td><td>高</td><td>零</td><td>极高</td><td>极好</td><td>高速、大型定制键盘</td></tr><tr><td>DMA + 定时器（MCU 内部）</td><td>零</td><td>很低</td><td>中</td><td>很好</td><td>STM32 等资源丰富 MCU</td></tr><tr><td>电容／电阻式触摸</td><td>中–高</td><td>视 IC 而定</td><td>中</td><td>良好</td><td>触摸面板、高端家电</td></tr></tbody></table><h2 id="四、消除“鬼键”（Ghosting）与“冲突键”（Masking）"><a href="#四、消除“鬼键”（Ghosting）与“冲突键”（Masking）" class="headerlink" title="四、消除“鬼键”（Ghosting）与“冲突键”（Masking）"></a>四、消除“鬼键”（Ghosting）与“冲突键”（Masking）</h2><p>当同时按下多个按键时，可能会出现错误识别。常用方法有：</p><ol><li><strong>二极管隔离</strong><br> 在每个按键上串联一个二极管，只允许电流单向流动，从根本上消除鬼键。</li><li><strong>软件检测</strong><ul><li><strong>简单策略</strong>：只允许单键扫描，检测到多键时丢弃或提示错误。</li><li><strong>扫描多次</strong>：记录多次扫描结果，取交集或最多的稳定结果。</li></ul></li></ol><hr><p>我的方法:</p><p>总共八个io,四个表示行,四个表示列,每个按键的左端接两根,一行一列引脚,然后按键另一端接地,这样就可以通过判断二进制值,来判断按键,比如,一行一列01110111</p><h3 id="ADC-按键"><a href="#ADC-按键" class="headerlink" title="ADC_按键"></a>ADC_按键</h3><h3 id="触摸按键"><a href="#触摸按键" class="headerlink" title="触摸按键"></a>触摸按键</h3><h2 id="摇杆"><a href="#摇杆" class="headerlink" title="摇杆"></a>摇杆</h2><p><a href="https://oshwhub.com/yuanzihao/TTP223chu-mo-an-jian-xin-pian-ya">TTP223触摸按键芯片验证板 - 嘉立创EDA开源硬件平台 (oshwhub.com)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Simulink</title>
      <link href="/2023/08/13/74s-simulink/"/>
      <url>/2023/08/13/74s-simulink/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1xQ4y1T7yv/?spm_id_from=333.337.search-card.all.click&vd_source=e33ad22b3d91cb180bef532ce5877b2e">【自动控制原理】12_PID控制器_Matlab&#x2F;Simulink仿真【开场三分钟闲话】_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1AK41157kE/?spm_id_from=333.337.search-card.all.click&vd_source=e33ad22b3d91cb180bef532ce5877b2e">快速入门Simulink的PID仿真_哔哩哔哩_bilibili</a></p><p><a href="https://blog.csdn.net/qq_45520617/article/details/123947163">MATLAB simulink 仿真步长_simulink仿真步长设置_北林白泽的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/xuoeigan/article/details/124560007">pid调节_一颗大椰子的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/viafcccy/article/details/107988093?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5-107988093-blog-77886668.235%5Ev38%5Epc_relevant_sort_base2&spm=1001.2101.3001.4242.4&utm_relevant_index=6">PID控制参数整定（调节方法）原理+图示+MATLAB调试_pid参数看曲线整定图解_viafcccy的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Simulink </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>73P_树莓派</title>
      <link href="/2023/08/12/73p-shu-mei-pai/"/>
      <url>/2023/08/12/73p-shu-mei-pai/</url>
      
        <content type="html"><![CDATA[<h3 id="更换固定ip后-无法联网"><a href="#更换固定ip后-无法联网" class="headerlink" title="更换固定ip后,无法联网"></a>更换固定ip后,无法联网</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言</title>
      <link href="/2023/08/08/72c-c/"/>
      <url>/2023/08/08/72c-c/</url>
      
        <content type="html"><![CDATA[<h2 id="多级菜单原理"><a href="#多级菜单原理" class="headerlink" title="多级菜单原理"></a>多级菜单原理</h2><p>数组查表法</p><p>实现数据向下滚动,实际上是另一个函数删除了第一行,加了最后一行,中间的数据y坐标向上移动2个</p><p><a href="https://www.bilibili.com/read/cv16469149">STM32简易多级菜单(数组查表法) - 哔哩哔哩 (bilibili.com)</a></p><h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><blockquote><p><strong>函数指针</strong>：首先它是一个指针，一个<a href="https://so.csdn.net/so/search?q=%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88&spm=1001.2101.3001.7020">指向函数的指针</a>，在内存空间中存放的是函数的地址；</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">int main()&#123;int a &#x3D; 10;int*pa &#x3D; &amp;a;char ch &#x3D; &#39;c&#39;;char* pc &#x3D; &amp;ch;int arr[10] &#x3D; &#123;0&#125;;int (*parr)[10] &#x3D; &amp;arr;&#x2F;&#x2F;取出数组的地址return 0;｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解析：parr是一个<a href="https://so.csdn.net/so/search?q=%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88&spm=1001.2101.3001.7020">指向数组的指针</a>，存放的是数组的地址；</p><blockquote><p>所以：</p><ul><li><strong>数组指针 —存放数组地址的指针；</strong></li><li><strong>&amp;数组名 —得到的就是数组的地址；</strong></li></ul></blockquote><p>那么我们可以不可以这么认为：</p><blockquote><ul><li><strong>函数指针 —存放函数地址的指针；</strong></li><li><strong>&amp;函数名 —得到的就是一个函数的地址；</strong></li></ul></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">int Add(int x，int y)&#123;return x+y; &#125;int main()&#123;printf(&quot;%p\n&quot;,&amp;Add);&#x2F;&#x2F;打印一下函数Add()的地址printf(&quot;%p\n&quot;,Add);&#x2F;&#x2F;数组名等于数组首元素地址，那函数名是等于函数地址吗？yesreturn 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数名是等于函数地址</strong></p><h3 id="函数指针的使用方法"><a href="#函数指针的使用方法" class="headerlink" title="函数指针的使用方法"></a>函数指针的使用方法</h3><p><strong>函数指针的定义</strong>： 函数的返回值类型（*指针名）（函数的参数列表类型）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int Add(int x, int y)&#123;return x+y;&#125;int main()&#123; int (*pf)(int, int) &#x3D; &amp;Add;&#x2F;&#x2F;函数指针定义，返回值类型和参数类型与函数Add（）相同&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">void Add(int x, int y)&#123;return x+y;&#125;int main()&#123;int (*pf)(int,int)&#x3D;&amp;Add;int ret&#x3D;(*pf)(3,5);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>解析：<br><code>int ret=(*pf)(3,5)</code>，此时就相当于通过函数名调用：<code> int ret=Add(3,5);&#125;</code>，我们又知道：<strong>函数名是等于&amp;函数名</strong>的，所以<code>int (*pf)(int,int)=&amp;Add</code>，可改成：<code>int (*pf)(int,int)=Add</code>;此时Add等价于pf，所以：<code>int ret=(*pf)(3,5)</code>;语句可改成：<code>int ret=pf(3,5)</code>;等价于<code>int ret=Add(3,5)</code>，故我们知道了对于：<code>int ret=(*pf)(3,5)</code>;语句来说，*是没有意义的，有一个或多个或者没有都不影响；</p></blockquote><ul><li>数组名 (arr) <strong>!&#x3D;</strong> &amp;数组名(&amp;arr)</li><li>函数名(Add) &#x3D; &amp;函数名(&amp;Add)</li></ul><h3 id="指针调用函数"><a href="#指针调用函数" class="headerlink" title="指针调用函数"></a>指针调用函数</h3><p>{1, 2, 5, (*show1)}</p><p>在 {1, 2, 5, (show1())} 这个结构体中，(show1()) 表示调用 show1 函数并将其返回值作为这个元素的值，而不是将 show1 函数本身的地址作为函数指针。因此，这种写法是不正确的，编译器会报错。</p><p>在 C 语言中，<code>函数名</code>本身就是一个<code>指向函数代码块</code>的指针，因此可以<code>直接</code>将<code>函数名赋值</code>给一个<code>函数指针变量</code>，或者通过指针变量来调用函数。而<code>在结构体或数组中定义函数指针</code>时，需要使用 (*show1) 这种方式来解引用指针，这是因为，在结构体或数组中定义的函数指针变量本身就是一个指针，需要使用解引用符号 * 来获取指向的函数代码块的地址。</p><p>因此，正确的写法应该是<code> &#123;1, 2, 5, (*show1)&#125;</code>，其中 (*show1) 表示指向 show1 函数的指针变量，通过解引用指针的方式来获取函数代码块的地址，并将其作为这个元素的值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct Menu &#123;    int menu_id;    int parent_id;    int operation_code;    void (*operation_func)();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>void (*current_operation)(void)并不是一个函数，而是一个函数指针变量的定义。在 C 语言中，函数名本身就是一个指向函数代码块的指针，因此可以用一个指针变量来存储函数的地址，然后通过这个指针变量来调用函数,这段代码定义了一个名为 current_operation 的函数指针变量，它可以指向一个没有参数和返回值的函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void show1() &#123;    printf(&quot;This is show1 function.\n&quot;);&#125;int main() &#123;    void (*current_operation)(void);  &#x2F;&#x2F; 定义一个函数指针变量    current_operation &#x3D; show1;  &#x2F;&#x2F; 将 show1 函数的地址赋值给函数指针变量    current_operation();  &#x2F;&#x2F; 通过指针变量调用 show1 函数    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">Menu_table table[26] &#x3D; &#123;    &#123;0, 0, 1, (*show0)&#125;,  &#x2F;&#x2F; 使用 (*show0) 来获取函数 show0 的地址    &#x2F;&#x2F; ...&#125;;&#x2F;&#x2F; 调用函数 show0table[0].current_operation();  &#x2F;&#x2F; 使用成员解引用运算符来调用成员函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先使用 <code>(*show0)</code> 来获取函数 <code>show0</code> 的地址，并将其赋值给 <code>current_operation</code>。然后，通过成员解引用运算符 <code>()</code> 来调用 <code>current_operation</code> 所指向的函数 <code>show0</code>。</p><h3 id="函数名不就是函数地址吗-为啥还用加-获取函数地址"><a href="#函数名不就是函数地址吗-为啥还用加-获取函数地址" class="headerlink" title="函数名不就是函数地址吗,为啥还用加*获取函数地址"></a>函数名不就是函数地址吗,为啥还用加*获取函数地址</h3><p>使用解引用运算符 <code>*</code> 来获取函数指针的地址。这是因为在 C 语言中，函数名被视为一个<code>指向函数的指针</code>，但是在结构体中定义函数指针类型的成员变量时，需要显式地<code>声明一个指向函数的指针变量</code>，然后把函数的地址赋值给这个指针变量。因此，需要使用解引用运算符 <code>*</code> 来获取函数的地址。</p><p><strong>不理解,弄了半天,不加*也是可以正常运行的,还是不能过于信任chatgpt,要跑一下看能不能跑,不能跑的话是报什么错</strong></p><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>声明结构体类型：<br>Struct 结构体名{<br>成员列表;<br>}变量名列表；<br>例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Struct U_TYPE &#123;Int BaudRateInt WordLength; &#125;usart1,usart2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在结构体申明的时候可以定义变量，也可以申明之后定义</p><p>方法是:</p><p>Struct 结构体名字 结构体变量列表 ;<br>例如：<code>struct U_TYPE usart1,usart2</code>;<br>结构体成员变量的引用方法是：<br>结构体变量名字.成员名<br>比如要引用 usart1 的成员 BaudRate,方法是：usart1.BaudRate;<br>结构体指针变量定义也是一样的，跟其他变量没有啥区别。<br>例如：struct U_TYPE *usart3；&#x2F;&#x2F;定义结构体指针变量 usart3;</p><p>结构体指针成员变量引用方法是通过“<code>-&gt;</code>”符号实现，比如要<code>访问 usart3 结构体指针</code>指向的<code>结 构体的成员变量</code> BaudRate</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">(*Usart3).BaudRateUsart3-&gt;BaudRate;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一种写法中，<code>.</code>的优先级高于<code>*</code>，<code>(*pointer)</code>两边的括号不能少。如果去掉括号写作<code>*pointer.memberName</code>，那么就等效于<code>*(pointer.memberName)</code>，这样意义就完全不对了。</p><p>第二种写法中，<code>-&gt;</code>是一个新的运算符，习惯称它为“箭头”，有了它，可以通过结构体指针直接取得结构体成员；这也是<code>-&gt;</code>在C语言中的唯一用途。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int main()&#123;    struct&#123;        char *name;  &#x2F;&#x2F;姓名        int num;  &#x2F;&#x2F;学号        int age;  &#x2F;&#x2F;年龄        char group;  &#x2F;&#x2F;所在小组        float score;  &#x2F;&#x2F;成绩    &#125; stu1 &#x3D; &#123; &quot;Tom&quot;, 12, 18, &#39;A&#39;, 136.5 &#125;, *pstu &#x3D; &amp;stu1;    &#x2F;&#x2F;读取结构体成员的值    printf(&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\n&quot;, (*pstu).name, (*pstu).num, (*pstu).age, (*pstu).group, (*pstu).score);    printf(&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\n&quot;, pstu-&gt;name, pstu-&gt;num, pstu-&gt;age, pstu-&gt;group, pstu-&gt;score);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-库函数-snprintf"><a href="#C-库函数-snprintf" class="headerlink" title="C 库函数 - snprintf()"></a>C 库函数 - snprintf()</h2><p>用来格式化输出字符串，并返回格式化后的字符数量，也就是整数的位数。你可以利用这个函数来获得整数的长度，并将结果写入到指定的缓冲区，与 sprintf() 不同的是，snprintf() 会限制输出的字符数，避免缓冲区溢出</p><h2 id="取余"><a href="#取余" class="headerlink" title="取余"></a>取余</h2><p>常见误区 1%4&#x3D;3</p><blockquote><p>1%4&#x3D;0……1</p></blockquote><h1 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a>strstr</h1><p><code>strstr</code> 是标准 C 库 <code>&lt;string.h&gt;</code>（C99 起）里提供的函数，用来在一个 <strong>以 \0 结尾</strong> 的字符串里查找另一个子串。它的原型是：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *strstr(const char *haystack, const char *needle);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>参数</strong><ul><li><code>haystack</code>：被搜索的“海”——目标字符串</li><li><code>needle</code>：要找的“针”——子串</li></ul></li><li><strong>返回值</strong><ul><li>如果在 <code>haystack</code> 中找到了第一次出现的 <code>needle</code>，则返回一个指向该子串开头的指针（<code>char *</code>）。</li><li>如果没找到，则返回 <code>NULL</code>。</li></ul></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 3. 自定义数据结构&#x2F;&#x2F; typedef struct &#123; ... &#125; drone_type_map_t;&#x2F;&#x2F; 定义一个名为 drone_type_map_t 的结构体类型。&#x2F;&#x2F; &#39;typedef&#39; 关键字用于为已有的数据类型创建一个新的别名。typedef struct &#123;    uint8_t type_code;         &#x2F;&#x2F; 结构体成员: type_code，一个8位无符号整数，存储无人机类型代码 (十六进制)。    const char* description;   &#x2F;&#x2F; 结构体成员: description，一个指向常量字符串的指针，存储类型描述文字。&#125; drone_type_map_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>K210</title>
      <link href="/2023/08/03/71h-k210/"/>
      <url>/2023/08/03/71h-k210/</url>
      
        <content type="html"><![CDATA[<h2 id="烧录出厂固件"><a href="#烧录出厂固件" class="headerlink" title="烧录出厂固件"></a>烧录出厂固件</h2><p>脱机运行,一连电脑串口助手就卡</p><p>要用外部串口</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Keil_仿真_逻辑分析仪器</title>
      <link href="/2023/07/27/70h-keil-fang-zhen-luo-ji-fen-xi-yi-qi/"/>
      <url>/2023/07/27/70h-keil-fang-zhen-luo-ji-fen-xi-yi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="unknow-signal"><a href="#unknow-signal" class="headerlink" title="unknow signal"></a>unknow signal</h2><p>原因:</p><p>四个箭头的部分都要改,我组织改了第二个和第四个</p><img src="/2023/07/27/70h-keil-fang-zhen-luo-ji-fen-xi-yi-qi/image-20230727003611985.png" class="" title="image-20230727003611985"><p>DARMSTM.DLL   -pSTM32F103RC</p><p>TARMSTM.DLL  -pSTM32F103RC</p><p><a href="https://blog.csdn.net/Jahol_Fan/article/details/78872988?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-78872988-blog-129688563.235%5Ev38%5Epc_relevant_sort_base2&spm=1001.2101.3001.4242.1&utm_relevant_index=1">keil的软件逻辑分析仪（ logic analyzer）使用教程_辣条boy的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/bean_business/article/details/116456981?ops_request_misc=&request_id=&biz_id=102&utm_term=KEIL%E7%9A%84%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA%E6%98%BE%E7%A4%BA%E6%9C%AA%E7%9F%A5%E7%9A%84%E4%BF%A1%E5%8F%B7&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-116456981.142%5Ev90%5Einsert_down28v1,239%5Ev3%5Einsert_chatgpt&spm=1018.2226.3001.4187">成功解决：MDK5逻辑分析窗口Unknown signal的问题_余府的博客-CSDN博客</a></p><h2 id="逻辑分析仪"><a href="#逻辑分析仪" class="headerlink" title="逻辑分析仪"></a>逻辑分析仪</h2><p>相当于示波器</p><h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p>首先要接好仿真器和板子,然后设置use simulator</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>查看变量数值没有变化</p><p>这个是编译器的问题，a定义的是局部变量，编译器把局部变量优化了,<code>并没有在内存中生成导致</code></p><p>定义成全局变量即可解决。</p><p><a href="http://lihuaxi.xjx100.cn/news/279775.html?action=onClick">stm32怎么用keil软件进行仿真？（必需掌握的技能） (xjx100.cn)</a>  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>舵机</title>
      <link href="/2023/07/25/69h-duo-ji/"/>
      <url>/2023/07/25/69h-duo-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="舵机"><a href="#舵机" class="headerlink" title="舵机"></a>舵机</h2><p>学名叫做伺服电机</p><p><strong>按照舵机的控制电路可以分为：</strong><br>1、模拟舵机<br>2、数字舵机</p><p><strong>按照外部接口和舵机的控制方式，又可分为：</strong><br>PWM 舵机和串行总线舵机。</p><blockquote><p>其工作原理：PWM信号由接收通道进入信号解调电路进行解调，</p><p>获得一个直流偏置电压直流偏置电压与电位器的电压比较，获得电压差并输出。</p><p>该输出送入电机驱动集成电路以驱动电机正反转。</p><p>当电机转动时，通过级联减速齿轮带动电位器旋转，直到电压差为O，电机停止转动。<br>舵机的控制信号是PWM信号，利用占空比的变化，改变舵机的位置</p></blockquote><p>舵机的控制一般需要一个20ms的时基脉冲(也就是周期是20ms)，该脉冲的高电平部分一般为0.5ms~2.5ms范围内的角度控制脉冲部分。以180度角度舵机为例，那么对应的控制关系是这样的</p><blockquote><p>0.5ms-0度:<br>1.0ms-45度;<br>1.5ms-90度;<br>2.0ms-135度;<br>2.5ms-180度;</p><p><img src="https://img-blog.csdnimg.cn/2fb9abab29f44aeba9942881dd77a486.png" alt="在这里插入图片描述"></p></blockquote><h2 id="如何精确控制舵机转向角度"><a href="#如何精确控制舵机转向角度" class="headerlink" title="如何精确控制舵机转向角度"></a>如何精确控制舵机转向角度</h2><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="pwm"><a href="#pwm" class="headerlink" title="pwm"></a>pwm</h3><p>定时器中断一次的时间为Tout（溢出时间）&#x3D;（ARR+1)(PSC+1)&#x2F;Tclk，tclk为时钟频率，一般为72000000，arr：自动重装值 psc：时钟预分频数</p><h3 id="舵机-1"><a href="#舵机-1" class="headerlink" title="舵机"></a>舵机</h3><p><a href="https://blog.csdn.net/weixin_44234294/article/details/114173000?ops_request_misc=%7B%22request_id%22:%22168886617416800188540469%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168886617416800188540469&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114173000-null-null.142%5Ev88%5Einsert_down38v5,239%5Ev2%5Einsert_chatgpt&utm_term=pwm%E6%8E%A7%E5%88%B6%E8%88%B5%E6%9C%BA&spm=1018.2226.3001.4187">STM32 PWM控制舵机_追兮兮的博客-CSDN博客</a></p><h3 id="TIM-SetCompare"><a href="#TIM-SetCompare" class="headerlink" title="TIM_SetCompare"></a>TIM_SetCompare</h3><p><img src="https://img-blog.csdnimg.cn/20200130103122170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bhc2Vk,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>第一个参数传入相应定时器，（定时器6,7除外）。使用的GPIO口位于哪个定时器那一列就传入哪个定时器。</p></li><li><p>第二个参数是输出PWM的高电平的时间。这个值如果大于周期的值，将会与周期保持一致。用第二个参数除以周期就得占空比。比如我想要使用PA1输出PWM，则应该这样写TIM_SetCompare2(TIM5,<a href="https://so.csdn.net/so/search?q=Compare&spm=1001.2101.3001.7020">Compare</a>)。Compare是输出高电平的时间。你想要在哪里使用PWM就在哪里调用这个函数</p></li></ul><p><a href="https://m.elecfans.com/article/675807.html">mg995舵机中文资料（参数_尺寸_控制程序）-电子发烧友网 (elecfans.com)</a></p><h2 id="精准控制舵机"><a href="#精准控制舵机" class="headerlink" title="精准控制舵机"></a>精准控制舵机</h2><h3 id="我的公式"><a href="#我的公式" class="headerlink" title="我的公式"></a>我的公式</h3><p>Pulse&#x3D;50+Angel&#x2F;180*(250-50)</p><p>Pulse&#x3D;150+Angel&#x2F;90*(250-50)</p><p>原理,占空比2.5-12.5%*2000&#x3D;50-&gt;250对应0-180度 </p><p>公式计算并没有问题就是不知道为什么,不能正常输出脉冲</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;void Sevor_move(int8_t Angel)&#x2F;&#x2F;&#123;&#x2F;&#x2F;    &#x2F;&#x2F; 计算PWM信号的占空比&#x2F;&#x2F;    float pulse_float &#x3D; 50.0+Angel&#x2F;180.0*(250.0-50.0);&#x2F;&#x2F;    uint16_t pulse &#x3D;(uint16_t)(pulse_float+0.5) ;&#x2F;&#x2F;    &#x2F;&#x2F; 设置PWM信号的占空比&#x2F;&#x2F;    TIM_SetCompare1(TIM1, pulse);&#x2F;&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>GPT写的正确的代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void Sevor_move(int8_t Angel)&#123;  uint16_t pulse;    &#x2F;&#x2F; 将角度限制在-90到90度之间    if (Angel &lt; -90) &#123;        Angel &#x3D; -90;    &#125; else if (Angel &gt; 90) &#123;        Angel &#x3D; 90;    &#125;    &#x2F;&#x2F; 计算PWM信号的脉冲宽度对应的计数值    pulse &#x3D; 50 + (uint16_t)((Angel + 90) &#x2F; 180.0 * 200); &#x2F;&#x2F; 50对应0.5ms, 250对应2.5ms    &#x2F;&#x2F; 设置PWM信号的脉冲宽度    TIM_SetCompare1(TIM1, pulse);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>在 0 到 180 度的范围内，将角度映射到 0.5ms 到 2.5ms 的脉冲宽度范围。为了实现这个映射，我们可以使用线性关系。</p><ul><li>角度 0 度对应脉冲宽度 1.5ms（90度对应的中间位置）；</li><li>角度 90 度对应脉冲宽度 2.5ms（舵机的最大角度）；</li><li>角度 -90 度对应脉冲宽度 0.5ms（舵机的最小角度）。</li></ul><p>我们使用线性关系进行映射，即脉冲宽度 &#x3D; (角度 + 90) &#x2F; 180.0 * (2.5 - 0.5) + 0.5。</p></li><li><p>最后，为了得到计数值范围在 50 到 250 的值（2.5ms 到 12.5ms 对应的范围），我们再将脉冲宽度乘以200（因为 250 - 50 &#x3D; 200）并四舍五入到最接近的整数。</p></li></ol><h3 id="更改后"><a href="#更改后" class="headerlink" title="更改后"></a>更改后</h3><p>我的代码更改后正常</p><p>我认为:是因为uint8_t是8位无符号的整型变量也就是一个字节,最大是256,Angel输入为0-180,,也没超啊</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void Sevor_move(int Angel)&#123;    &#x2F;&#x2F; 计算PWM信号的占空比    float pulse_float &#x3D; 50.0+Angel&#x2F;180.0*(250.0-50.0);    uint16_t pulse &#x3D;(uint16_t)(pulse_float+0.5) ;    &#x2F;&#x2F; 设置PWM信号的占空比    TIM_SetCompare1(TIM1, pulse);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>换成int之后又换回uint8_t了,好使了,好像是<code>玄学</code>啊</p><h3 id="更正"><a href="#更正" class="headerlink" title="更正"></a>更正</h3><p>是int8_t不可以</p><blockquote><p><code>int8_t</code>：</p><ul><li><code>int8_t</code> 是一个有符号的整数类型，表示范围为从 -128 到 127。</li><li>它占用 8 位（一个字节）内存空间。</li><li><code>int8_t</code> 在存储的时候使用 2 的补码表示，最高位表示符号位。</li></ul><p><code>uint8_t</code>：</p><ul><li><code>uint8_t</code> 是一个无符号的整数类型，表示范围为从 0 到 255。</li><li>它同样占用 8 位（一个字节）内存空间。</li><li><code>uint8_t</code> 表示的是正整数，没有符号位。</li></ul></blockquote><p><a href="https://blog.csdn.net/m0_73931287/article/details/130445572">舵机驱动代码及舵机控制原理（详解）_舵机驱动程序_小小_扫地僧的博客-CSDN博客</a></p><h2 id="类型转换的问题"><a href="#类型转换的问题" class="headerlink" title="类型转换的问题"></a>类型转换的问题</h2><p>int变量赋值给float变量,值会不对150变成10584545684什么的</p><h2 id="错误诊断"><a href="#错误诊断" class="headerlink" title="错误诊断"></a>错误诊断</h2><p>1.printf串口</p><p>2.c语言实现看结果</p><p>3.oled</p><h2 id="控制舵机的缓动算法"><a href="#控制舵机的缓动算法" class="headerlink" title="控制舵机的缓动算法"></a>控制舵机的缓动算法</h2><p>当控制舵机进行旋转时，普通的方式往往会直接指定舵机的目标角度，然后直接让舵机转动到目标角度。这种方式会导致舵机在转动时突然停下，可能会产生颤动或者不够平滑的效果。</p><p>为了实现丝滑旋转效果，我们可以采用缓动（Easing）方法。缓动是一种用于平滑过渡动画效果的数学算法，它可以让舵机在旋转过程中逐渐增加或减小角速度，从而使得旋转过程更加平滑和自然。</p><p>缓动算法的基本思想是通过线性插值来计算舵机的当前角度。假设舵机起始角度为 <code>start</code>，目标角度为 <code>target</code>，当前时间为 <code>t</code>，持续时间为 <code>duration</code>，那么可以使用如下的线性插值公式来计算舵机的当前角度：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">current_angle &#x3D; start + (target - start) * t &#x2F; duration<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个公式会根据当前时间 <code>t</code> 的变化，逐步将舵机的角度从起始角度 <code>start</code> 过渡到目标角度 <code>target</code>，从而实现平滑的旋转效果。</p><p>在示例代码中，我们定义了起始角度 <code>servo_start_angle</code> 为 0 度，目标角度 <code>servo_target_angle</code> 为 360 度（一圈），持续时间 <code>duration</code> 为 5000 毫秒（即 5 秒）。然后，我们使用一个循环来模拟整个缓动过程。在每次循环中，我们根据当前时间 <code>t</code> 使用缓动函数 <code>easing</code> 来计算舵机的当前角度 <code>servo_current_angle</code>，然后将舵机设置到当前角度，并等待一段时间（时间步长 <code>time_step</code>）再进行下一次循环。</p><p>缓动函数 <code>easing</code> 的计算公式非常简单，它就是我们之前提到的线性插值公式，用于计算舵机的当前角度。根据需要，你可以使用不同的缓动函数来实现不同的旋转效果，比如使用缓入缓出（Ease In, Ease Out）等缓动函数。不同的缓动函数会产生不同的角速度变化，从而使得旋转效果更加丰富和自然。</p><p>总结一下，通过使用缓动方法，我们可以让舵机在旋转过程中平滑过渡到目标角度，从而实现丝滑的旋转效果。你可以根据具体需求和舵机的特性来调整缓动函数和持续时间，以获得最佳的旋转效果。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>重学STM32</title>
      <link href="/2023/07/20/68h-chong-xue-stm32/"/>
      <url>/2023/07/20/68h-chong-xue-stm32/</url>
      
        <content type="html"><![CDATA[<h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p>上拉输入-&gt;拉到上面等待输入</p><img src="/2023/07/20/68h-chong-xue-stm32/image-20230720174755580.png" class="" title="image-20230720174755580"><h3 id="AFIO"><a href="#AFIO" class="headerlink" title="AFIO"></a>AFIO</h3><p>有的管脚不仅是作为普通IO的存在，更是作为外设IO的存在，这就是<strong>管脚复用现象</strong>。而普通管脚就是<strong>GPIO</strong>，复用管脚就是我们所说的<strong>AFIO</strong>。也就是说，如果要用到外设功能，则必须要用的到外设IO（即AFIO）。</p><h2 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h2><p>led需要设定一个初始值,当然初始化里面已经包括了<code>GPIO_SetBits(GPIOC, GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2);//set暗，reset亮</code></p><h2 id="KEY"><a href="#KEY" class="headerlink" title="KEY"></a>KEY</h2><p>与条件里面单反以偶一个设置错误程序就会无法正常执行,但是不会报错</p><p>上拉输入-&gt;低电平有效</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">u8 KEY_Scan(u8 mode)&#123; static u8 key_up&#x3D;1;&#x2F;&#x2F;按键按松开标志if(mode)key_up&#x3D;1;  &#x2F;&#x2F;支持连按  if(key_up&amp;&amp;(KEY0&#x3D;&#x3D;0||KEY1&#x3D;&#x3D;0||KEY2&#x3D;&#x3D;0))&#123;delay_ms(10);&#x2F;&#x2F;去抖动 key_up&#x3D;0;if(KEY0&#x3D;&#x3D;0)return KEY0_PRES;else if(KEY1&#x3D;&#x3D;0)return KEY1_PRES;else if(KEY2&#x3D;&#x3D;0)return KEY2_PRES;&#125;else if(KEY0&#x3D;&#x3D;1&amp;&amp;KEY1&#x3D;&#x3D;1&amp;&amp;KEY2&#x3D;&#x3D;1)key_up&#x3D;1;      return 0;&#x2F;&#x2F; 无按键按下&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h2><h3 id="外部中断不能能否内部拉高使用"><a href="#外部中断不能能否内部拉高使用" class="headerlink" title="外部中断不能能否内部拉高使用"></a>外部中断不能能否内部拉高使用</h3><p>不能</p><blockquote><p>首先,中断是输入模式的,因为要检测信号,你要内部把他拉高拉低,就会变成输出模式,冲突</p></blockquote><p>外部中断,边沿检测器,发生高低电平变化时即进入中断</p><p>例:</p><blockquote><p>mpu6050的int是10ms进入一次,意味着int10ms发生一次高低电平变化,正常外部中断是与时间无关的</p><p>外部中断的按键,按下即发生变化,即进入中断</p></blockquote><p>MSP432系列单片机没有编码器模式,所以可以用外部中断来测脉冲数进而测速</p><p>A,B相接一根线为二倍频,AB相各接两根线为四倍频</p><h2 id="编码器模式"><a href="#编码器模式" class="headerlink" title="编码器模式"></a>编码器模式</h2><p>编码器计数原理,就是码盘跟随电机转,霍尔传感器,一个发,一个收,码盘有几个孔,则转一圈需要多少个脉冲</p><p>但实际上不是这么算的,转一圈的脉冲数&#x3D;13线* 30减速比 * 4倍频&#x3D;1560个脉冲</p><p>霍尔元件检测输出若干脉冲信号，为判断转向，一般输出两组存在一定相位差的方波信号。</p><p><img src="https://img-blog.csdnimg.cn/20210119213847839.gif#pic_center" alt="在这里插入图片描述"></p><p>STM32读取编码器过程</p><p>编码器产生脉冲–&gt;单片机捕获脉冲边沿–&gt;单片机定时器计数、设置自动加载值（一般是编码器线束，或者是线束的2倍频或4倍频）、设置分频–&gt;当脉冲数量达到自动加载值时溢出一个事件（表示圈数）,记录一段事件内的脉冲个数（计算转速）</p><p><code>TIM_EncoderInterfaceConfig(TIM3,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising )</code></p><img src="/2023/07/20/68h-chong-xue-stm32/image-20230808123447491.png" class="" title="image-20230808123447491"><p><strong>三种模式：</strong></p><p>1）<strong>仅在TL1计数(A相)</strong></p><p>TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level. 2） </p><p><strong>仅在TL2计数（B相）</strong></p><p>TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level. 3）</p><p><strong>在TL1和TL2都计数(A相和B相都计数)</strong></p><p>TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending on the level of the other input<code>.一个脉冲信号周期完成4次跳变。精度提高</code>。</p><p>如下图 </p><p>1时刻：TI2为低电平，TI1上升沿跳变，计数器向上计数；</p><p>2时刻：TI1为高电平，TI2上升沿跳变，计数器仍然向上计数；</p><p>3时刻：TI2为高电平，TI1下降沿跳变，计数器仍然向上计数；</p><p>4时刻：TI1为低电平，TI2下降沿跳变，计数器仍然向上计数。 </p><p>毛刺：只有一个相位脉冲 过滤掉 编码器转动过程中可能产生的毛刺过滤掉</p><p><img src="https://pic2.zhimg.com/80/v2-58ab52e0d34ce9fcad744614c8773a3d_1440w.webp" alt="img"></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">转速: 用捕获值（即一秒内输出的脉冲数）*60/ 编码器线数（转速一圈输出脉冲数）/ 电机减数比（内部电机转动圈数与电机输出轴转动圈数比，即减速齿轮比，若没有则不用除） rmp运动距离： 编码器齿轮周长*（输出的总脉冲数/ 编码器线数）转动角度： 360 *（输出的总脉冲数 / 编码器线数 转动方向： 方向在定时器CR1的DIR位里   dir=(TIMX->CR1 &amp; 0x0010)>>4;//取方向标志位     if(dir > 0)  //向下计数   else//向上计数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>关于这个代码我有不理解:</p><blockquote><p>pid计算是通过理论值和实际值来计算的,实际速度,通过编码器的脉冲数得到的也是脉冲数,那么计算出来的结果怎么变成占空比了呢</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*赋值函数*&#x2F;                                                &#x2F;*入口参数：PID运算完成后的最终PWM值*&#x2F;void Load(int moto1,int moto2)&#x2F;&#x2F;moto1&#x3D;-200：反转200个脉冲&#123;&#x2F;&#x2F;1.研究正负号，对应正反转if(moto1&gt;0)Ain1&#x3D;1,Ain2&#x3D;0;&#x2F;&#x2F;正转else Ain1&#x3D;0,Ain2&#x3D;1;&#x2F;&#x2F;反转&#x2F;&#x2F;2.研究PWM值TIM_SetCompare1(TIM1,GFP_abs(moto1));if(moto2&gt;0)Bin1&#x3D;1,Bin2&#x3D;0;else Bin1&#x3D;0,Bin2&#x3D;1;TIM_SetCompare4(TIM1,GFP_abs(moto2));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ChatGPT回答</p><p>你的疑问是关于如何将从编码器得到的脉冲数转化为PWM占空比以控制电机速度</p><p>在这个代码中，虽然你从编码器得到的是脉冲数，但这些脉冲数实际上代表了电机的转动情况，进而与电机的速度直接相关。代码中的<code>Load</code>函数的目的是将电机的速度控制信息（即来自PID控制器的输出）转化为PWM信号，以控制电机的实际速度。</p><p>电机的转速通常是通过调整电机的供电电压或占空比来实现的，而PWM（脉冲宽度调制）信号就是一种可以调整电压的方式。这是因为PWM信号的高电平时间与脉冲数成正比，因此将脉冲数转化为PWM信号的占空比，可以间接控制电机的速度。</p><blockquote><p>实际上是通过,pid的参数,将他们量化成一种正比关系了是吗</p></blockquote><p>ChatGPT</p><p>是的，你理解得很正确。在电机控制中，PID控制器计算出的控制量（通常是一个控制误差的修正值）需要转化为一种电机能够理解的形式，例如PWM信号的占空比。这就需要将控制量量化成电机的控制输入，以实现你期望的电机运动。</p><p>PID控制器计算出的控制量通常与你希望电机实现的速度、位置等指标相关。通过将这个控制量与电机控制之间的关系建立起来，你可以将它转化为合适的电机控制参数，如PWM占空比。这种关系的建立和调整就是根据具体的系统特性、电机参数等来进行的。</p><p>因此，可以说你通过PID控制器计算出的参数，将其量化为电机控制参数，进而实现了一种正比关系，从而让电机以期望的方式运动。这个过程涉及到了系统建模、控制器调节和电机控制的一系列步骤。</p><blockquote><p>就相当于占空比与脉冲数都与速度有关系,pid就是找到他们关系的系数</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/592196163">STM32读取编码器读数 - 知乎 (zhihu.com)</a></p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenMV</title>
      <link href="/2023/07/05/67h-openmv/"/>
      <url>/2023/07/05/67h-openmv/</url>
      
        <content type="html"><![CDATA[<p><a href="https://book.openmv.cc/quick-starter.html">10分钟快速上手 · OpenMV中文入门教程</a></p><p><a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/machine.UART.html#machine.UART">UART类 – 双工串行通信总线 — MicroPython 1.9.2 文档 (singtown.com)</a></p><p><a href="https://blog.csdn.net/lihaotian111/article/details/116384913?ops_request_misc=%7B%22request_id%22:%22168854580016800215014509%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168854580016800215014509&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-116384913-null-null.142%5Ev88%5Einsert_down38v5,239%5Ev2%5Einsert_chatgpt&utm_term=openmv%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1&spm=1018.2226.3001.4187#2_5">超详细OpenMV与STM32单片机通信 (有完整版源码)_openmv和stm32_Wu__La的博客-CSDN博客</a></p><img src="/2023/07/05/67h-openmv/image-20230705163332838.png" class="" title="image-20230705163332838"><img src="/2023/07/05/67h-openmv/image-20230705163541604.png" class="" title="image-20230705163541604"><h2 id="OpenMV串口通信"><a href="#OpenMV串口通信" class="headerlink" title="OpenMV串口通信"></a>OpenMV串口通信</h2><h2 id="问题-oled不显示"><a href="#问题-oled不显示" class="headerlink" title="问题 oled不显示"></a>问题 oled不显示</h2><p>首先判断是串口中断的问题还是配置的问题,使用test文件检测串口是否能收发数据,如果不能则为配置错误,(我没有检测,因为我看了好几遍感觉没问题,最后还是有问题),我是,找一个能正常使用的,然后一步一步改成一样的,哪一步现象改变,就是那块的问题,或者最后剩下的就是问题</p><h3 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h3><p>自己写,发送方和接收方的一样就行</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void USART3_IRQHandler(void)                &#123;    static int i&#x3D;0;static u8 Rebuf[20]&#x3D;&#123;0&#125;;  if(USART_GetITStatus(USART3, USART_IT_RXNE) !&#x3D; RESET)  &#123;      Rebuf[i++] &#x3D; USART_ReceiveData(USART3);  &#x2F;&#x2F;接收数据  if(Rebuf[0]!&#x3D;0x2C) i&#x3D;0;                   &#x2F;&#x2F;判断第一个帧头0xa3  if((i&#x3D;&#x3D;2)&amp;&amp;(Rebuf[1]!&#x3D;0x12))i&#x3D;0;    &#x2F;&#x2F;判断第二个帧头0xb3  &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;方法一&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;      if(i&#x3D;&#x3D;5)                    &#x2F;&#x2F;共五个字节的数据   &#123;                 &#x2F;&#x2F;故rebuf[i++]&#x3D;[0,1,2,3,4],也就是rebuf[4]时,i&#x3D;5      if(Rebuf[4] &#x3D;&#x3D; 0x5B)    &#x2F;&#x2F;代表一组数据传输完毕     &#123;          &#x2F;&#x2F;!!!!判断帧尾0xc3,这个方法会多给一个0,比如65显示650,应该跟补位有关系                          memcpy(openmv_data,Rebuf,i);&#x2F;&#x2F;这个函数的具体作用 &#125;  i &#x3D; 0;             &#x2F;&#x2F;清空数组  &#125;   &#125;&#125;                &#x2F;&#x2F;[1]识别到的数字:    &#x2F;&#x2F;openmv_num &#x3D; openmv_data[2];    &#x2F;&#x2F;[2]数字的x、y坐标:    &#x2F;&#x2F;openmv_x &#x3D; openmv_data [2];    &#x2F;&#x2F;openmv_y &#x3D; openmv_data [3];    &#x2F;&#x2F;USART_ClearITPendingBit(USART3,USART_IT_RXNE);   &#x2F;&#x2F;清除中断标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是的，您发送的数据是5个字节，但第一段代码中的if判断条件是<code>if(i&gt;=10)</code>。这个判断条件并不准确，但实际上并不影响正确接收到数据。</p><p>在第一段代码中，当接收到完整的5个字节的数据包时，就将数据复制到openmv_data数组中进行进一步处理。而当接收到的数据长度大于等于10个字节时，虽然if条件不满足，但并不会影响接收到的数据。因为即使接收到的数据长度大于5个字节，也只有前5个字节是有效的数据，后面的字节会被忽略掉。</p><blockquote><p>我只传输五个字节的数据,这段代码能正常运行的原因是接收到了十个字节,然后取其中的两个字节,其他的不要,相当于发送方发两条,接收方接收两条在一条数据里,但是只读取一条完整的数据对嘛</p></blockquote><p>虽然这种实现方式可能会浪费一些接收缓冲区的空间，但由于数据包长度是固定的，因此在这种情况下也不会影响数据的正确接收。但是为了提高代码的可读性和可维护性，建议将if判断条件改为<code>if(i==5)</code>，这样可以更准确地判断接收到的数据是否完整，并避免浪费缓冲区的空间。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">  &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;方法二&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;          if(i&gt;&#x3D;10)&#123;memcpy(openmv_data,Rebuf,i);i &#x3D; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来解决的问题,if(i&#x3D;&#x3D;5)这个方法会导致65后面多个0的格式</p><p>串口失效</p><p>1.配置</p><p>2.接线</p><p>3.函数有错误</p><p>时钟</p><p>gpiob和usart3的时钟不是同一个,不能够一起使能</p><img src="/2023/07/05/67h-openmv/image-20230712164259761.png" class="" title="image-20230712164259761"><p>bytearray</p><h2 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h2><p>发送一个字节数据超过255</p><p>1.拆成个十百位</p><ol start="2"><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32+OLED多级菜单</title>
      <link href="/2023/07/01/66h-stm32-oled/"/>
      <url>/2023/07/01/66h-stm32-oled/</url>
      
        <content type="html"><![CDATA[<h2 id="c语言的地址"><a href="#c语言的地址" class="headerlink" title="c语言的地址"></a>c语言的地址</h2><h2 id="多级菜单原理"><a href="#多级菜单原理" class="headerlink" title="多级菜单原理"></a>多级菜单原理</h2><p>数组查表法</p><p>实现数据向下滚动,实际上是另一个函数删除了第一行,加了最后一行,中间的数据y坐标向上移动2个</p><p><a href="https://www.bilibili.com/read/cv16469149">STM32简易多级菜单(数组查表法) - 哔哩哔哩 (bilibili.com)</a></p><h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><blockquote><p><strong>函数指针</strong>：首先它是一个指针，一个<a href="https://so.csdn.net/so/search?q=%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88&spm=1001.2101.3001.7020">指向函数的指针</a>，在内存空间中存放的是函数的地址；</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">int main()&#123;int a &#x3D; 10;int*pa &#x3D; &amp;a;char ch &#x3D; &#39;c&#39;;char* pc &#x3D; &amp;ch;int arr[10] &#x3D; &#123;0&#125;;int (*parr)[10] &#x3D; &amp;arr;&#x2F;&#x2F;取出数组的地址return 0;｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解析：parr是一个<a href="https://so.csdn.net/so/search?q=%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88&spm=1001.2101.3001.7020">指向数组的指针</a>，存放的是数组的地址；</p><blockquote><p>所以：</p><ul><li><strong>数组指针 —存放数组地址的指针；</strong></li><li><strong>&amp;数组名 —得到的就是数组的地址；</strong></li></ul></blockquote><p>那么我们可以不可以这么认为：</p><blockquote><ul><li><strong>函数指针 —存放函数地址的指针；</strong></li><li><strong>&amp;函数名 —得到的就是一个函数的地址；</strong></li></ul></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">int Add(int x，int y)&#123;return x+y; &#125;int main()&#123;printf(&quot;%p\n&quot;,&amp;Add);&#x2F;&#x2F;打印一下函数Add()的地址printf(&quot;%p\n&quot;,Add);&#x2F;&#x2F;数组名等于数组首元素地址，那函数名是等于函数地址吗？yesreturn 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数名是等于函数地址</strong></p><h3 id="函数指针的使用方法"><a href="#函数指针的使用方法" class="headerlink" title="函数指针的使用方法"></a>函数指针的使用方法</h3><p><strong>函数指针的定义</strong>： 函数的返回值类型（*指针名）（函数的参数列表类型）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int Add(int x, int y)&#123;return x+y;&#125;int main()&#123; int (*pf)(int, int) &#x3D; &amp;Add;&#x2F;&#x2F;函数指针定义，返回值类型和参数类型与函数Add（）相同&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">void Add(int x, int y)&#123;return x+y;&#125;int main()&#123;int (*pf)(int,int)&#x3D;&amp;Add;int ret&#x3D;(*pf)(3,5);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>解析：<br><code>int ret=(*pf)(3,5)</code>，此时就相当于通过函数名调用：<code> int ret=Add(3,5);&#125;</code>，我们又知道：<strong>函数名是等于&amp;函数名</strong>的，所以<code>int (*pf)(int,int)=&amp;Add</code>，可改成：<code>int (*pf)(int,int)=Add</code>;此时Add等价于pf，所以：<code>int ret=(*pf)(3,5)</code>;语句可改成：<code>int ret=pf(3,5)</code>;等价于<code>int ret=Add(3,5)</code>，故我们知道了对于：<code>int ret=(*pf)(3,5)</code>;语句来说，*是没有意义的，有一个或多个或者没有都不影响；</p></blockquote><ul><li>数组名 (arr) <strong>!&#x3D;</strong> &amp;数组名(&amp;arr)</li><li>函数名(Add) &#x3D; &amp;函数名(&amp;Add)</li></ul><h3 id="指针调用函数"><a href="#指针调用函数" class="headerlink" title="指针调用函数"></a>指针调用函数</h3><p>{1, 2, 5, (*show1)}</p><p>在 {1, 2, 5, (show1())} 这个结构体中，(show1()) 表示调用 show1 函数并将其返回值作为这个元素的值，而不是将 show1 函数本身的地址作为函数指针。因此，这种写法是不正确的，编译器会报错。</p><p>在 C 语言中，<code>函数名</code>本身就是一个<code>指向函数代码块</code>的指针，因此可以<code>直接</code>将<code>函数名赋值</code>给一个<code>函数指针变量</code>，或者通过指针变量来调用函数。而<code>在结构体或数组中定义函数指针</code>时，需要使用 (*show1) 这种方式来解引用指针，这是因为，在结构体或数组中定义的函数指针变量本身就是一个指针，需要使用解引用符号 * 来获取指向的函数代码块的地址。</p><p>因此，正确的写法应该是<code> &#123;1, 2, 5, (*show1)&#125;</code>，其中 (*show1) 表示指向 show1 函数的指针变量，通过解引用指针的方式来获取函数代码块的地址，并将其作为这个元素的值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct Menu &#123;    int menu_id;    int parent_id;    int operation_code;    void (*operation_func)();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>void (*current_operation)(void)并不是一个函数，而是一个函数指针变量的定义。在 C 语言中，函数名本身就是一个指向函数代码块的指针，因此可以用一个指针变量来存储函数的地址，然后通过这个指针变量来调用函数,这段代码定义了一个名为 current_operation 的函数指针变量，它可以指向一个没有参数和返回值的函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void show1() &#123;    printf(&quot;This is show1 function.\n&quot;);&#125;int main() &#123;    void (*current_operation)(void);  &#x2F;&#x2F; 定义一个函数指针变量    current_operation &#x3D; show1;  &#x2F;&#x2F; 将 show1 函数的地址赋值给函数指针变量    current_operation();  &#x2F;&#x2F; 通过指针变量调用 show1 函数    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">Menu_table table[26] &#x3D; &#123;    &#123;0, 0, 1, (*show0)&#125;,  &#x2F;&#x2F; 使用 (*show0) 来获取函数 show0 的地址    &#x2F;&#x2F; ...&#125;;&#x2F;&#x2F; 调用函数 show0table[0].current_operation();  &#x2F;&#x2F; 使用成员解引用运算符来调用成员函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先使用 <code>(*show0)</code> 来获取函数 <code>show0</code> 的地址，并将其赋值给 <code>current_operation</code>。然后，通过成员解引用运算符 <code>()</code> 来调用 <code>current_operation</code> 所指向的函数 <code>show0</code>。</p><p><strong>函数名不就是函数地址吗,为啥还用加*获取函数地址</strong></p><p>使用解引用运算符 <code>*</code> 来获取函数指针的地址。这是因为在 C 语言中，函数名被视为一个<code>指向函数的指针</code>，但是在结构体中定义函数指针类型的成员变量时，需要显式地<code>声明一个指向函数的指针变量</code>，然后把函数的地址赋值给这个指针变量。因此，需要使用解引用运算符 <code>*</code> 来获取函数的地址。</p><p><strong>不理解,弄了半天,不加*也是可以正常运行的,还是不能过于信任chatgpt,要跑一下看能不能跑,不能跑的话是报什么错</strong></p><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>声明结构体类型：<br>Struct 结构体名{<br>成员列表;<br>}变量名列表；<br>例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Struct U_TYPE &#123;Int BaudRateInt WordLength; &#125;usart1,usart2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在结构体申明的时候可以定义变量，也可以申明之后定义</p><p>方法是:</p><p>Struct 结构体名字 结构体变量列表 ;<br>例如：<code>struct U_TYPE usart1,usart2</code>;<br>结构体成员变量的引用方法是：<br>结构体变量名字.成员名<br>比如要引用 usart1 的成员 BaudRate,方法是：usart1.BaudRate;<br>结构体指针变量定义也是一样的，跟其他变量没有啥区别。<br>例如：struct U_TYPE *usart3；&#x2F;&#x2F;定义结构体指针变量 usart3;</p><p>结构体指针成员变量引用方法是通过“<code>-&gt;</code>”符号实现，比如要<code>访问 usart3 结构体指针</code>指向的<code>结 构体的成员变量</code> BaudRate</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">(*Usart3).BaudRateUsart3-&gt;BaudRate;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一种写法中，<code>.</code>的优先级高于<code>*</code>，<code>(*pointer)</code>两边的括号不能少。如果去掉括号写作<code>*pointer.memberName</code>，那么就等效于<code>*(pointer.memberName)</code>，这样意义就完全不对了。</p><p>第二种写法中，<code>-&gt;</code>是一个新的运算符，习惯称它为“箭头”，有了它，可以通过结构体指针直接取得结构体成员；这也是<code>-&gt;</code>在C语言中的唯一用途。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int main()&#123;    struct&#123;        char *name;  &#x2F;&#x2F;姓名        int num;  &#x2F;&#x2F;学号        int age;  &#x2F;&#x2F;年龄        char group;  &#x2F;&#x2F;所在小组        float score;  &#x2F;&#x2F;成绩    &#125; stu1 &#x3D; &#123; &quot;Tom&quot;, 12, 18, &#39;A&#39;, 136.5 &#125;, *pstu &#x3D; &amp;stu1;    &#x2F;&#x2F;读取结构体成员的值    printf(&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\n&quot;, (*pstu).name, (*pstu).num, (*pstu).age, (*pstu).group, (*pstu).score);    printf(&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\n&quot;, pstu-&gt;name, pstu-&gt;num, pstu-&gt;age, pstu-&gt;group, pstu-&gt;score);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="oled-init-的引脚配置"><a href="#oled-init-的引脚配置" class="headerlink" title="oled_init()的引脚配置"></a>oled_init()的引脚配置</h3><p>PB6和PB7并没有占用jtag的引脚,我不明白为什么在oled_init()有这两句,也没复用</p><p>pb6和pb7本来就是scl和sda,并且pb4,pb5,pb8,pb9都要这么设置(<strong>因为jtag的引脚在别的地方被占用了</strong>&#96;)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_AFIO, ENABLE);GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>灵光乍现想到原因</strong>:PB6,PB7没有占用jtag,<strong>但是</strong>key使用的是PB3,PB4,PB5,所以要禁用jtag,释放gpio,但是这个禁用为啥不在key_init禁用,上oled_init禁用,误导</p><h3 id="禁用jtag"><a href="#禁用jtag" class="headerlink" title="禁用jtag"></a>禁用jtag</h3><p>PB3和PB4在系统复位时候，分别默认为SYS_JIDO和SYS_HJTRST；<br>所以需要通过用户自行禁止其功能；<br>也就是想要正常使用PB3和PB4的主功能的时候。<br>在初始化IO时候，增加代码如下：（这里使用J-Link的SWD模式烧录程序）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;打开时钟函数RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO,ENABLE);&#x2F;&#x2F;打开GPIO口时钟，先打开复用才能修改复用功能GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);&#x2F;&#x2F;要先开时钟，再重映射；这句表示关闭jtag，使能swd。  &#x2F;&#x2F;如果是HAL库，使用 __HAL_AFIO_REMAP_SWJ_NOJTAG();              &#x2F;&#x2F;禁用JTAG&#x2F;&#x2F;接下来按照自己需要配置IO的各种模式就行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/07/01/66h-stm32-oled/image-20230809193334152.png" class="" title="image-20230809193334152"><img src="/2023/07/01/66h-stm32-oled/image-20230809193258392.png" class="" title="image-20230809193258392"><p>默认复用功能应该是在一个时钟线上不用开启AFIO,重定义功能应该就是要开启AFIO,调用重映射函数进行重映射</p><p>我的理解:</p><blockquote><p>首先</p><p>使能被重新映射到的IO端口时钟</p><p>使能被重新映射到的外设时钟(比如USART2)</p><p>使能AFIO时钟</p><p>调用重映射函数GPIO_PinRemapConfig(GPIO_Remap_USART2, ENABLE);</p><p>(上文调用的是禁止jtag的重映射)</p></blockquote><p><strong>在使用复用功能的是时候，最少要使能 2 个时钟</strong>：</p><ul><li><p><strong>GPIO 时钟使能</strong></p></li><li><p>复用的<strong>外设时钟使能</strong></p><h3 id="重映射需要四步"><a href="#重映射需要四步" class="headerlink" title="重映射需要四步"></a>重映射需要四步</h3><img src="/2023/07/01/66h-stm32-oled/image-20230809194713735.png" class="" title="image-20230809194713735">[STM32入门笔记(02)：AFIO复用端口与重映射 、NVIC中断优先级管理、外部中断、串口通信及串口实验（SPL库函数版)_stm32f407 bug_Naiva的博客-CSDN博客](https://naiva.blog.csdn.net/article/details/123345468?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-123345468-blog-131213026.235^v38^pc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-123345468-blog-131213026.235^v38^pc_relevant_sort_base2&utm_relevant_index=9)</li></ul><p><a href="https://blog.csdn.net/weixin_37787043/article/details/82805561?ops_request_misc=%7B%22request_id%22:%22168835734616800185875520%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=168835734616800185875520&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~hot_rank-9-82805561-null-null.268%5Ev1%5Ekoosearch&utm_term=stm32%E7%9A%84pb6%E4%B8%8Epb7&spm=1018.2226.3001.4450">STM32 PB3或者PB4不能正常使用的讲解_pb3 pb4_夜星辰2014的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/u011198687/article/details/120817110">使用GPIO_Remap_SWJ_JTAGDisable后依然无法使用SWD进行调试解决办法_玩转智能机器人的博客-CSDN博客</a></p><h3 id="函数效果出现异常"><a href="#函数效果出现异常" class="headerlink" title="函数效果出现异常"></a>函数效果出现异常</h3><p>检查函数,是否if少写了else</p><h3 id="程序卡死"><a href="#程序卡死" class="headerlink" title="程序卡死"></a>程序卡死</h3><p>一堆语句放在一个函数里容易出现卡死,封装成函数,在函数里面调用就不会了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32+ESP8266+MQTT+ONENET</title>
      <link href="/2023/06/29/65h-stm32-esp8266-mqtt-onenet/"/>
      <url>/2023/06/29/65h-stm32-esp8266-mqtt-onenet/</url>
      
        <content type="html"><![CDATA[<h2 id="ONENET"><a href="#ONENET" class="headerlink" title="ONENET"></a>ONENET</h2><h3 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h3><p>导入常规图表时这里是有三个系列，复制程序后发现只有x轴更新，是因为这里的y轴字段名是y1，而程序赋值的是y，修改此处就好了</p><p><img src="https://img-blog.csdnimg.cn/654b6b4539e34a73be4dc1655ddf325b.png" alt="img"></p><h2 id="esp8266"><a href="#esp8266" class="headerlink" title="esp8266"></a>esp8266</h2><p>01与01s的区别,不通用的原因</p><p><a href="https://blog.csdn.net/qq_41954556/article/details/123878277">手把手教你OneNET数据可视化_小向是个Der的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_31366371/article/details/124751326?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-124751326-blog-130666429.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-124751326-blog-130666429.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=4">仪表盘，折线图、地图，ONENET应用编辑器2.0（View 2.0）控件使用_goview大屏对接_记录学习顺便写写的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_45998204/article/details/124716864?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-124716864-blog-123878277.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-124716864-blog-123878277.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=3#%E6%9B%B2%E7%BA%BF%E4%BB%A3%E7%A0%81%E6%AE%B5">（超详细二）onenet数据可视化详解,如何用截取数据流绘图_onenet 数据流_麓南的风的博客-CSDN博客</a></p><p><a href="https://open.iot.10086.cn/doc/v5/fuse/detail/1134">onenet官方文档</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32的BOOt引脚</title>
      <link href="/2023/06/11/64h-stm32-de-boot-yin-jiao/"/>
      <url>/2023/06/11/64h-stm32-de-boot-yin-jiao/</url>
      
        <content type="html"><![CDATA[<h2 id="STM32的boot引脚"><a href="#STM32的boot引脚" class="headerlink" title="STM32的boot引脚"></a>STM32的boot引脚</h2><p><img src="https://img-blog.csdnimg.cn/f59aab7a73b44b86939ca05cf7349db4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARFJfQ0FO,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><img src="/2023/06/11/64h-stm32-de-boot-yin-jiao/image-20230611220035676.png" class="" title="image-20230611220035676"><p><code>最常用</code>个人理解,BOOT0接地(通常接个10k电阻),BOOT1x就是可以不接,对比原理图给x,是STM32内置的Flash，一般我们使用JTAG或者SWD模式下载程序时，就是下载到这个里面，重启后也直接<strong>从这启动程序</strong>。</p><p>1、主闪存存储器<br>是STM32内置的Flash，一般我们使用JTAG或者SWD模式下载程序时，就是下载到这个里面，重启后也直接<strong>从这启动程序</strong>。</p><p>2、系统存储器<br>从系统存储器启动，这种模式启动的程序功能是由厂家设置的。一般来说，这种启动方式用的比较少。系统存储器是芯片内部一块特定的区域，STM32在出厂时，由ST在这个区域内部预置了一段BootLoader，也就是我们常说的<strong>ISP程序</strong>，这是一块ROM，出厂后无法修改。一般来说，我们选用这种启动模式时，是为了从串口下载程序，因为在厂家提供的BootLoader中，<strong>提供了串口下载程序的固件</strong>，可以通过这个BootLoader将程序下载到系统的Flash中。但是这个下载方式需要以下步骤：</p><p>Step1:将BOOT0设置为1，BOOT1设置为0，然后按下复位键，这样才能从系统存储器启动BootLoader<br>Step2:最后在BootLoader的帮助下，通过串口下载程序到Flash中<br>Step3:程序下载完成后，又有需要将BOOT0设置为GND，<strong>手动复位</strong>，这样，STM32才可以从Flash中启动。</p><p>3、内置SRAM<br>内置SRAM，既然是SRAM，自然也就没有程序存储的能力了，这个模式一般用于程序调试。假如我只修改了代码中一个小小的地方，然后就需要重新擦除整个Flash，比较的费时，可以考虑从这个模式启动代码（也就是STM32的内存中），用于快速的程序调试，等程序调试完成后，再将程序下载到Flash中。</p><p><a href="https://blog.csdn.net/a919964703/article/details/124072915?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-124072915-blog-130460236.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-124072915-blog-130460236.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=3">STM32—BOOT0和BOOT1_stm32boot0和boot1接线图_bit er的博客-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>51单片机驱动数码管</title>
      <link href="/2023/06/03/63h-51-dan-pian-ji-qu-dong-shu-ma-guan/"/>
      <url>/2023/06/03/63h-51-dan-pian-ji-qu-dong-shu-ma-guan/</url>
      
        <content type="html"><![CDATA[<h3 id="共阳极数码管"><a href="#共阳极数码管" class="headerlink" title="共阳极数码管"></a>共阳极数码管</h3><img src="/2023/06/03/63h-51-dan-pian-ji-qu-dong-shu-ma-guan/image-20230603224630917.png" class="" title="image-20230603224630917"><pre class="line-numbers language-c" data-language="c"><code class="language-c">0x82,0xf8,0x80,0x90&#125;;&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="共阴极数码管"><a href="#共阴极数码管" class="headerlink" title="共阴极数码管"></a>共阴极数码管</h3><img src="/2023/06/03/63h-51-dan-pian-ji-qu-dong-shu-ma-guan/image-20230603224657362.png" class="" title="image-20230603224657362"><pre class="line-numbers language-c" data-language="c"><code class="language-c">unsigned char code seven_seg[9] &#x3D; &#123;                            0x3f , 0x06 , 0x5b ,                             0x4f , 0x66 , 0x6d ,                             0x7d ,0x07 , 0x7f  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小小坑"><a href="#小小坑" class="headerlink" title="小小坑"></a>小小坑</h2><ul><li><p>如果发现if语句失灵,请检查括号是否括对了</p></li><li><p>P2&#x3D;0x18不知道为什么上面那种写法(D1&#x3D;1),会使数码管一直闪,显示不出数字,至于为什么是0x18而不是0x10,因为p2.3有个蜂鸣器低电平老响</p><blockquote><p>对于8051单片机的端口寄存器，如果某个引脚的值没有被显式地赋值，那么该引脚的值会保持不变，即保持上一次的状态。<br>意思就是我先给d1,d2,d3,d4都给1,都亮,然后给d1为1,其他不给,还是都亮*&#x2F;</p></blockquote></li><li><p>共阴极数码管的段码是1有效，所有的段码的最高位都是0，当需要显示小数点时，在当前的段码加上0x80即可。<br>  举个例了吧，段码从P0口输出，在变量gewei（个位数）上显示小数点<br>  P0&#x3D;tab[gewei]+0x80;<br>  不显示小数点时是：<br>  P0&#x3D;tab[gewei];</p></li><li><p>delay会降低刷新率,会一直闪</p></li></ul><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="时钟周期、时钟频率、状态周期、机器周期"><a href="#时钟周期、时钟频率、状态周期、机器周期" class="headerlink" title="时钟周期、时钟频率、状态周期、机器周期"></a>时钟周期、时钟频率、状态周期、机器周期</h3><blockquote><p>在 8051 微控制器中，时钟周期(Clock Cycle)是晶振震荡一次的时间长度，是时钟频率的倒数,即：时钟周期 &#x3D; 1 &#x2F; 时钟频率,即时钟周期&#x3D;1&#x2F;(12M) (s)&#x3D; 1&#x2F;12&#x2F;1000&#x2F;1000 (s) &#x3D; 1&#x2F;12 us</p></blockquote><p>时钟频率是晶振震荡的次数每秒钟的数量，单位为赫兹（Hz），一个 12 MHz 的晶振频率表示晶振每秒钟震荡 1200 万次。所以12 MHz 的晶振频的时钟周期长度为： 1 &#x2F; 12000000</p><blockquote><p>一秒钟震荡1200000次,所以一次需要1&#x2F;12000000的时间,即时钟周期</p></blockquote><p>机器周期是计算机执行一条指令的时间长度</p><blockquote><p>51单片机一个指令周期是12个时钟周期</p><p>即指令周期&#x3D;12*1&#x2F;12 us &#x3D; 1us,机器周期 &#x3D; 12 &#x2F; 晶振频率</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>步进电机</title>
      <link href="/2023/05/24/62h-bu-jin-dian-ji/"/>
      <url>/2023/05/24/62h-bu-jin-dian-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="42步进电机"><a href="#42步进电机" class="headerlink" title="42步进电机"></a>42步进电机</h2><h3 id="1-步进电机的基本知识"><a href="#1-步进电机的基本知识" class="headerlink" title="1.步进电机的基本知识"></a>1.步进电机的基本知识</h3><p>（1）拍数——每一次循环所包含的通电状态数（电机转过一个齿距角所需脉冲数）<br>（2）单拍制分配方式——状态数&#x3D;相数<br>（3）双拍制分配方式——状态数&#x3D;相数的两倍<br><strong>（4）步距角 ——步进机通过一个电脉冲转子转过的角度</strong>,电机上一般会给出</p><p><img src="https://img-blog.csdnimg.cn/20190504174146766.png#pic_center" alt="计算公式"></p><ul><li>N:一个周期的运行拍数<br>Zr：转子齿数<br>拍数：N&#x3D;km<br>m:相数<br>k&#x3D;1单拍制<br>k&#x3D;2双拍制</li></ul><p>（5）转速<br><img src="https://img-blog.csdnimg.cn/20190504184912141.png#pic_center" alt="转速"></p><p>（6）角度细分的原理</p><ul><li>电磁力的大小与绕组通电电流的大小有关。</li><li>当通电相的电流并不马上升到位，而断电相的电流也非立即降为0时，它们所产生的磁场合力，会使转子有一个新的平衡位置，这个新的平衡位置是在原来的步距角范围内。</li></ul><h3 id="3-42步进电机速度与角度控制"><a href="#3-42步进电机速度与角度控制" class="headerlink" title="3. 42步进电机速度与角度控制"></a>3. 42步进电机速度与角度控制</h3><p>电机的转速与脉冲频率成正比，电机转过的角度与脉冲数成正比。所以控制脉冲数和脉冲频率就可以精确调速。<br>理论上步进电机转速 &#x3D; 频率 * 60 &#x2F;((360&#x2F;T)<em>x)<br>w &#x3D; f ∗ 60 ( 360 ° T × x ) w&#x3D; \frac{f</em>60}{(\frac {360°}{T}\times x)}w&#x3D;(T360°​×x)f∗60​</p><ul><li>转速单位： 转&#x2F; 分</li><li>频率单位：赫兹</li><li>x 细分倍数</li><li>T 步距角<br>例如，在本实验中，32细分；频率72000 赫兹；步距角1.8°；套用公式72000 ∗ 60 ( ( 360 &#x2F; 1.8 ) ∗ 32 ) &#x3D; 112.5 \frac{72000*60}{((360&#x2F;1.8)*32)}&#x3D;112.5((360&#x2F;1.8)∗32)72000∗60​&#x3D;112.5rad&#x2F; min，即1.875 rad&#x2F;s.</li></ul><img src="/2023/05/24/62h-bu-jin-dian-ji/image-20230525191834700.png" class="" title="image-20230525191834700"><img src="/2023/05/24/62h-bu-jin-dian-ji/image-20230525191852684.png" class="" title="image-20230525191852684"><p><strong>接口</strong><br>步进驱动器可分为两部分：环形分配器、功率放大器。<br><strong>环形分配器</strong>：接收3种信号分别为：脉冲信号（PUL&#x2F;CLK），方向信号（DIR&#x2F;CW），脱机信号（ENA）。<br><strong>脉冲信号</strong>：环形分配器对脉冲信号进行分配，去控制功率放大器相应的晶体管，使步进电机的线圈得电。所以，步进电机要运转就必须有脉冲输入，所以需要一个驱动器来给步进电机的各项绕组依次通电。<br><strong>方向信号</strong>：控制AB通电的相序，A-B顺时针，B-A逆时针<br><strong>脱机信号</strong>：步进电机停止时，AB线圈有一相得电，得电的功能使转子锁住，使转子不能动，需要收去拨动转子的时候，需要给脱机信号，使AB相绕组完全断电，转子处于自由转动状态。（也就是说控制电机停止除了不给脉冲之外，还可以控制脱机信号来锁死电机，此处用不着脱机信号）</p><h2 id="不转-尖叫-啸叫"><a href="#不转-尖叫-啸叫" class="headerlink" title="不转,尖叫,啸叫"></a>不转,尖叫,啸叫</h2><p>之前同样的代码可以正常使用,现在更换驱动器和步进电机之后仍然不好使</p><p>下一步准备更换主控</p><p>我先换线,后面所有的线都换了,依然不行</p><p>也有可能是电池没电了(自己的笔记还是要及时看的,不然思路会忘掉)</p><blockquote><p><code>确实是电池没电了,电压变成9v多,不够了</code>,而驱动器的电源范围为9-40V</p></blockquote><h2 id="步进电机不转并出现尖叫啸叫的原因"><a href="#步进电机不转并出现尖叫啸叫的原因" class="headerlink" title="步进电机不转并出现尖叫啸叫的原因"></a>步进电机不转并出现尖叫啸叫的原因</h2><p>1.供电问题</p><p>电源电压过低或不稳定-&gt;更换电源</p><p>2.驱动器故障</p><p>上电后,绿灯常亮,蓝灯不亮(这个蓝灯状态我不确定)</p><p>我认为驱动时蓝绿两个灯都亮着,驱动器就是正常的</p><p>另一种方法是,pul+接电源24v,pul-与电源地线一下一下触动,电机轻微转动,则驱动器没有问题</p><p><a href="https://www.jiangtexs.net/hynews/2067.html">步进电机尖叫而不转的原因是什么（详解步进电机故障排查）-江西电机 (jiangtexs.net)</a></p><p>3.步进电机故障</p><p>此时可以将一相的两根线拧在一起然后,转动电机有阻力,再将另外两根线接在一起,阻力加大-&gt;电机未故障</p><p><a href="https://blog.csdn.net/qq_35858902/article/details/124069845?ops_request_misc=%7B%22request_id%22:%22168887086916800182114140%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=168887086916800182114140&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~hot_rank-6-124069845-null-null.268%5Ev1%5Ekoosearch&utm_term=stm32%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA&spm=1018.2226.3001.4450">stm32控制步进电机_司徒法克的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_44041987/article/details/88254493?ops_request_misc=%7B%22request_id%22:%22168885611916800180640001%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168885611916800180640001&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-88254493-null-null.142%5Ev88%5Einsert_down38v5,239%5Ev2%5Einsert_chatgpt&utm_term=stm32f407%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA&spm=1018.2226.3001.4187">基于STM32F407ZGT6对步进电机的控制（单脉冲+重复计数）有代码_stm32f407igt6 步进电机模块代码编程_weixin_44041987的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/wxc971231/article/details/82086392?ops_request_misc=%7B%22request_id%22:%22168885691916800185829953%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=168885691916800185829953&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~hot_rank-7-82086392-null-null.268%5Ev1%5Ekoosearch&utm_term=stm32f407%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA&spm=1018.2226.3001.4450">利用stm32控制步进电机 速度&amp;&amp;加速度控制_步进电机2相驱动控制方向与速度程序代码_云端FFF的博客-CSDN博客</a></p><h3 id="步进电机的驱动"><a href="#步进电机的驱动" class="headerlink" title="步进电机的驱动"></a>步进电机的驱动</h3><h3 id="驱动原理"><a href="#驱动原理" class="headerlink" title="驱动原理"></a>驱动原理</h3><h3 id="驱动方法"><a href="#驱动方法" class="headerlink" title="驱动方法"></a>驱动方法</h3><ul><li>GPIO翻转+delay</li><li>GPIO翻转+外部中断</li><li>PWM+定时器中断</li><li>PWM+主从定时器</li><li>定时器输出比较</li><li>定时器输出比较_IO口翻转模式</li></ul><h3 id="脉冲宽度-即ccr-对步进电机的影响"><a href="#脉冲宽度-即ccr-对步进电机的影响" class="headerlink" title="脉冲宽度(即ccr)对步进电机的影响"></a>脉冲宽度(即ccr)对步进电机的影响</h3><p>如果你是用驱动器来驱动步进电机的话，那脉冲的占空比跟步进电机的步进数是没关系的，只要脉冲宽度大于驱动器的要求就好了，因为决定步进电机的步进数是脉冲个数，跟脉冲宽度无关。另外要注意的是脉冲频率，不能超过驱动器可接受的脉冲频率和电机响应频率。另外楼上说的电机扭矩的话跟脉冲宽度也没多大关系，决定扭矩的是驱动电流</p><p><a href="https://www.bilibili.com/video/BV1Ng4y1w7oT/?spm_id_from=333.788&vd_source=e33ad22b3d91cb180bef532ce5877b2e">梯形加减速_哔哩哔哩_bilibili</a></p><h2 id="定时器时钟"><a href="#定时器时钟" class="headerlink" title="定时器时钟"></a>定时器时钟</h2><img src="/2023/05/24/62h-bu-jin-dian-ji/image-20230710151905256.png" class="" title="image-20230710151905256"><p>CNT-&gt;ARR 影像周期,进而影响频率,频率计算公式:f&#x3D;1&#x2F;T</p><p>CNT自增到ARR的时间&#x3D;PWM周期时间</p><p>CCR-&gt;影响占空比</p><p>晶振(CK-PSC)-&gt;分频器分频后-&gt;作为PWM波的频率</p><img src="/2023/05/24/62h-bu-jin-dian-ji/image-20230710152415736.png" class="" title="image-20230710152415736"><p>因为arr和psc都是从0开始所以计算式要+1</p><img src="/2023/05/24/62h-bu-jin-dian-ji/image-20230710152520300.png" class="" title="image-20230710152520300"><img src="/2023/05/24/62h-bu-jin-dian-ji/image-20230710152635959.png" class="" title="image-20230710152635959"><p>配置成复用推挽输出的原因</p><img src="/2023/05/24/62h-bu-jin-dian-ji/image-20230710152810574.png" class="" title="image-20230710152810574"><img src="/2023/05/24/62h-bu-jin-dian-ji/image-20230710152946501.png" class="" title="image-20230710152946501"><img src="/2023/05/24/62h-bu-jin-dian-ji/image-20230710153130548.png" class="" title="image-20230710153130548"><p>定时器中断,先写一个串口发送控制速度,角度,按键控制,然后oled显示,然后画板子,确定电源接口</p><h3 id="梯形加减速"><a href="#梯形加减速" class="headerlink" title="梯形加减速"></a>梯形加减速</h3><p>原理:定时器输出比较_io口翻转</p><p>弧长&#x3D;半径对应的角度,360&#x2F;2π&#x3D;180&#x2F;π</p><ul><li>rad 为弧度单位 (1rad &#x3D; (180&#x2F;π)° ≈ 57.3°)</li></ul><p>摆放顺序由比赛现场抽签确定</p><h2 id="通电发热-且有电流声"><a href="#通电发热-且有电流声" class="headerlink" title="通电发热,且有电流声"></a>通电发热,且有电流声</h2><p><del>步进电机电流过大,驱动器没有对电流进行细分</del>,</p><p>细分之后没有电流声,但是通电时间长了之后依然会发热,,我觉得的是EN的问题</p><p>sscanf</p><p>使用 <code>sscanf()</code> 函数从字符串中提取两个整数。但是，由于字符串中只有一个整数，因此会导致提取错误的结果。</p><p>修正该代码的方法是，使用 <code>%c%d</code> 的格式字符串，将第一个字符作为符号位，第二个字符作为整数部分，然后使用 <code>sscanf()</code> 函数从字符串中提取这两个值。以下是修正后的代码：</p><p><code>steps = atoi((char const *)Rebuf)</code>;</p><p> 将 <code>Rebuf</code> 缓冲区中的字符串转换为整型数据，并将其赋值给 <code>steps</code> 变量</p><p>我有很多的事情想不明白</p><h2 id="关于串口通信出现的问题"><a href="#关于串口通信出现的问题" class="headerlink" title="关于串口通信出现的问题"></a>关于串口通信出现的问题</h2><h3 id="电机只能转一次"><a href="#电机只能转一次" class="headerlink" title="电机只能转一次"></a>电机只能转一次</h3><p>我遇到的问题有发送+5,电机不转,加了判断之后,电机只能转一次,后面再发送就没反应了,但是我写了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">memset(Rebuf, 0, sizeof(Rebuf));steps&#x3D;0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>清空步数和缓存区</p><p>下面这个代码可以完成10以内的圈数,但是他清的是buf_len,但我认为不是清空的事,而是转换成整数的事<code>steps = steps * 10 + (Rebuf[i] - &#39;0&#39;);</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int16_t BUFFER_SIZE &#x3D;200;void USART3_IRQHandler(void)&#123;char res;&#x2F;&#x2F;无符号,所以会导致没有+-static int i&#x3D;0;char Rebuf[BUFFER_SIZE];uint8_t buf_len &#x3D; 0;  &#x2F;&#x2F; 接收缓冲区当前长度uint8_t digit_count &#x3D; 0;int32_t steps&#x3D;0 ; &#x2F;&#x2F; 存储步数变量if(USART_GetITStatus(USART3,USART_IT_RXNE)!&#x3D; RESET)&#123;    Rebuf[buf_len++]&#x3D;USART_ReceiveData(USART3); &#x2F;&#x2F;既然是一个字符一个中断,那为什么我看到的是&quot;哈哈哈&quot;是连着的,是因为串口助手规范的吗    &#x2F;*在你的代码中，如果接收到的数据是负数，则转换后会出现错误。    这是因为负数的ASCII码值大于127，而你使用的uint8_t类型的变量无法表示大于127的数值。*&#x2F;    &#x2F;&#x2F; 遍历接收缓冲区中的每个字符    for( i &#x3D; 0; i &lt; buf_len; i++)    &#123;        if (Rebuf[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; Rebuf[i] &lt;&#x3D; &#39;9&#39;)        &#123;            &#x2F;&#x2F; 如果当前字符是数字，则将其转换为整数并累加到步数中            steps &#x3D; steps * 10 + (Rebuf[i] - &#39;0&#39;);            digit_count++;        &#125;    &#125;          MOTOR_Move(1600 * steps, step_accel, step_decel, set_speed);  &#x2F;&#x2F; 需要时调          buf_len &#x3D; 0;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为这样的代码同样可以用,但是只能是个位数,甚至还有正负,所以应该是<code>steps = atoi((const char *)Rebuf);</code>这个转换的问题</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int16_t BUFFER_SIZE &#x3D;200;void USART3_IRQHandler(void)&#123;char res;&#x2F;&#x2F;无符号,所以会导致没有+- &#x2F;&#x2F;char res;  &#x2F;&#x2F; 将数据类型修改为有符号的int8_t static int i&#x3D;0;char Rebuf[BUFFER_SIZE];   uint8_t buf_len &#x3D; 0;  &#x2F;&#x2F; 接收缓冲区当前长度     uint8_t digit_count &#x3D; 0; int32_t steps&#x3D;0 ; &#x2F;&#x2F; 存储步数变量if(USART_GetITStatus(USART3,USART_IT_RXNE)!&#x3D; RESET)&#123;    Rebuf[buf_len++]&#x3D;USART_ReceiveData(USART3);       &#x2F;&#x2F;int steps &#x3D; res - &#39;000&#39;; &#x2F;&#x2F; 将字符转换为数字,   这样会以最大速度一直转        int steps &#x3D; Rebuf[0] - &#39;0&#39;;&#x2F;&#x2F;这个有符号,但是只能识别一位      MOTOR_Move((1600 * steps), step_accel, step_decel, set_speed);  &#x2F;&#x2F; 需要时调       &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>他们说串口发送数据是一个字节一个字节发送的,又说是一个字符一个字符发送的,所以我最开始写的代码是这样的,当输入+5的时候,这个判断可以进来,</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">if(rebuf[0]&#x3D;&#x3D;&#39;+&#39;)&#123;&#x2F;&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是这个输入+5也可以正常执行,<del>c所以有没有可能一个字节是八位,而一个字符只是一位</del></p><p>串口发送数据的方式可以是一个字节一个字节发送，也可以是一次发送多个字节,因为一个字符的 ASCII 码值可以用一个字节表示，所以一个字符只占用一个字节的空间。而一个整数通常需要多个字节来表示，所以将字符转换为整数时只能转换为一位数字</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int steps &#x3D; Rebuf[0] - &#39;0&#39;;&#x2F;&#x2F;这个有符号,但是只能识别一位<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">Rebuf[buf_len++]&#x3D;USART_ReceiveData(USART3); &#x2F;&#x2F;既然是一个字符一个中断,那为什么我看到的是&quot;哈哈哈&quot;是连着的,是因为串口助手规范的吗    &#x2F;*在你的代码中，如果接收到的数据是负数，则转换后会出现错误。    这是因为负数的ASCII码值大于127，而你使用的uint8_t类型的变量无法表示大于127的数值。*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="switch判断方法-不能自由控制"><a href="#switch判断方法-不能自由控制" class="headerlink" title="switch判断方法,不能自由控制"></a>switch判断方法,不能自由控制</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">switch(res)&#123;  case &#39;1&#39;:       MOTOR_Move(1600 * 1, step_accel, step_decel, set_speed);  &#x2F;&#x2F; 需要时调       break;      case &#39;2&#39;:       MOTOR_Move(-1600 * 5, step_accel, step_decel, set_speed);  &#x2F;&#x2F; 需要时调       break; &#125;       <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="error-42-operand-types-are-incompatible-“char”-and-“char-”"><a href="#error-42-operand-types-are-incompatible-“char”-and-“char-”" class="headerlink" title="error: #42: operand types are incompatible (“char” and “char *”)"></a>error: #42: operand types are incompatible (“char” and “char *”)</h2><p>if (Rebuf[0]&#x3D;&#x3D;”+”||Rebuf[0]&#x3D;&#x3D;” “)sign&#x3D;1;</p><p>这个错误是因为你在代码中将一个字符（<code>char</code> 类型）与一个字符串（<code>char*</code> 类型）进行了比较。具体而言，在第 75 行代码中，你将 <code>Rebuf[0]</code> 的值与字符串 <code>&quot;+&quot;</code> 和 <code>&quot; &quot;</code> 进行了比较，这是不允许的。因为 <code>Rebuf[0]</code> 是一个字符，而 <code>&quot;+&quot;</code> 和 <code>&quot; &quot;</code> 都是字符串常量，是由多个字符组成的字符数组。</p><blockquote><p>将””换成’’,将字符串常量改为字符常量\</p></blockquote><h2 id="我不明白这个代码为什么我发送r12-不应该是rrbuf-0-rebuf-1-1-rebuf-2-2而不是rebuf-0-r12"><a href="#我不明白这个代码为什么我发送r12-不应该是rrbuf-0-rebuf-1-1-rebuf-2-2而不是rebuf-0-r12" class="headerlink" title="我不明白这个代码为什么我发送r12,不应该是rrbuf[0]&#x3D;,rebuf[1]&#x3D;1,rebuf[2]&#x3D;2而不是rebuf[0]&#x3D;r12"></a>我不明白这个代码为什么我发送r12,不应该是rrbuf[0]&#x3D;,rebuf[1]&#x3D;1,rebuf[2]&#x3D;2而不是rebuf[0]&#x3D;r12</h2><p>​           <code> if (res == &#39;\n&#39;)</code></p><p>如果接收到回车符,这个判断很重要,有这个可以正常按数组接收数据,没有的话,可能就与变量接收没有区别</p><p>原因:</p><h3 id="关于steps无法算两位数以上"><a href="#关于steps无法算两位数以上" class="headerlink" title="关于steps无法算两位数以上"></a>关于steps无法算两位数以上</h3><h3 id="并且代码的公式没问题-for循环的括号-要把for循环结束后step才是我想要的值"><a href="#并且代码的公式没问题-for循环的括号-要把for循环结束后step才是我想要的值" class="headerlink" title="并且代码的公式没问题,for循环的括号,要把for循环结束后step才是我想要的值"></a>并且代码的公式没问题,for循环的括号,要把for循环结束后step才是我想要的值</h3><h3 id="steps无法计算小数"><a href="#steps无法计算小数" class="headerlink" title="steps无法计算小数"></a>steps无法计算小数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"> for ( i &#x3D; 0; i &lt; buf_len; i++)                  &#123;                                          if (Rebuf[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; Rebuf[i] &lt;&#x3D; &#39;9&#39;)&#x2F;&#x2F;1.5                       &#123;    &#x2F;&#x2F; 如果当前字符是数字，则将其转换为整数并累加到步数中                          steps &#x3D; steps * 10 + (Rebuf[i] - &#39;0&#39;);                      &#125;                       else if(Rebuf[i]&#x3D;&#x3D;&#39;.&#39;)&#x2F;&#x2F;12.5,1.25                      &#123; &#x2F;&#x2F;                      float steps &#x3D; atof(Rebuf + 1); &#x2F;&#x2F; 将字符串转换为浮点数                        steps &#x3D; steps * 10 + (Rebuf[i+1] - &#39;0&#39;);                                             float ff &#x3D; steps*0.1;                         steps&#x3D;ff;                        break;                       &#125;                     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题:小数点无效,比如r0.5会正转5圈</p><p>原因:</p><p><code>作用域问题</code></p><p>因为在 <code>else if(Rebuf[i]==&#39;.&#39;)</code> 分支中重新定义了 <code>steps</code> 变量，而且这个新定义的 <code>steps</code> 变量的作用域仅限于该分支中，不会影响到外部的 <code>steps</code> 变量。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define BUFFER_SIZE 200char Rebuf[BUFFER_SIZE];uint8_t buf_len &#x3D; 0;  &#x2F;&#x2F; 接收缓冲区当前长度uint8_t digit_count &#x3D; 0;int32_t steps &#x3D; 0; &#x2F;&#x2F; 存储步数变量int sign;void USART3_IRQHandler(void)&#123;    if (USART_GetITStatus(USART3, USART_IT_RXNE) !&#x3D; RESET)    &#123;        char res &#x3D; USART_ReceiveData(USART3);        if (buf_len &lt; BUFFER_SIZE - 1) &#x2F;&#x2F; 如果接收缓冲区未满        &#123;            Rebuf[buf_len++] &#x3D; res; &#x2F;&#x2F; 存储接收到的字符            if (res &#x3D;&#x3D; &#39;\n&#39;) &#x2F;&#x2F; 如果接收到回车符,这个判断很重要,有这个可以正常按数组接收数据,没有的话,可能就与变量接收没有区别            &#123;                &#x2F;&#x2F;Rebuf[buf_len] &#x3D; &#39;\0&#39;; &#x2F;&#x2F; 在最后一个字符后添加字符串结束符                if (Rebuf[0] &#x3D;&#x3D; &#39;r&#39;)                &#123;                    steps &#x3D; atoi((char const *)(Rebuf + 1));                    MOTOR_Move(1600 * steps, step_accel, step_decel, set_speed); &#x2F;&#x2F; 需要时调                &#125;                buf_len &#x3D; 0; &#x2F;&#x2F; 清空接收缓冲区                steps &#x3D; 0; &#x2F;&#x2F; 清空步数变量            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>明天的任务</p><p>0.5.找到电机发热问题 </p><p>1.封装xx,y,z电机</p><p>2.电赛准备</p><p>3.数学原理很重要,可以系统学习一下,步进电机梯形加减速的原理</p><p>4.不知道为什么f4的例程里面没有出现这个\n的问题,不知道是不是因为hal库封装好了</p><p>5.树莓派使用串口要先打开,奶奶滴,那个人没给我ip,没给我热点,我连个JQK</p><h2 id="串口控制xxyz四个电机"><a href="#串口控制xxyz四个电机" class="headerlink" title="串口控制xxyz四个电机"></a>串口控制xxyz四个电机</h2><h3 id="问题四分之一"><a href="#问题四分之一" class="headerlink" title="问题四分之一"></a>问题四分之一</h3><p>现在就是我之前使用tim3的通道一,控制一个电机,现在我爸四个通道都打开了,不知道为什么会变成原来的四分之一,因为计算公式都没变</p><h2 id="换四个定时器-参考四轴步进电机"><a href="#换四个定时器-参考四轴步进电机" class="headerlink" title="换四个定时器,参考四轴步进电机"></a>换四个定时器,参考四轴步进电机</h2><p>在定时器中断处理函数中，每次中断发生时会检测定时器的中断标志位，并根据标志位来执行相应的代码。如果您在中断处理函数中多次检测定时器中断标志位，并且每次都处理一个脉冲信号，那么每次中断发生时就会处理多个脉冲信号，导致总的脉冲信号数量增加。</p><blockquote><p>例如，如果您多写了一个处理脉冲信号的代码，那么每次中断发生时会处理两个脉冲信号，导致总的脉冲信号数量增加一倍，因此电机的转速也会增加一倍。同样地，如果您多写了三个处理脉冲信号的代码，那么每次中断发生时会处理四个脉冲信号，导致总的脉冲信号数量减少四分之三，因此电机的转速也会减少四分之三。</p></blockquote><h3 id="单开oc1可-oc2-03-oc4都不行"><a href="#单开oc1可-oc2-03-oc4都不行" class="headerlink" title="单开oc1可,oc2,03,oc4都不行"></a>单开oc1可,oc2,03,oc4都不行</h3>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三极管</title>
      <link href="/2023/05/24/61h-san-ji-guan/"/>
      <url>/2023/05/24/61h-san-ji-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="自锁开关6脚"><a href="#自锁开关6脚" class="headerlink" title="自锁开关6脚"></a>自锁开关6脚</h2><p>六脚开关（六脚自锁开关）也就是我们说的双刀双掷开关，引脚共2排，每排3个引脚，中间一根是公共端，对应他左右2个脚一个常开一个常闭，另外一排和这个一样，常开对常开，公共点对公共点，常闭对常闭，但是是完全独立的2组，除非你在PCB上将他们连接起来才是通的。</p><p><img src="/61H-%E4%B8%80%E4%BA%9B%E5%85%83%E5%99%A8%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230524153941245.png" alt="image-20230524153941245"></p><blockquote><p>不同规格的六脚自锁开关不同</p><ul><li>5.8*5.8 原理底下凹槽是常开(两个两个的)</li><li>7*7 靠近凹槽常开</li><li>8.5*8.5靠近凹槽常开</li><li>8*8左上右下常开,旋转180°也一样</li></ul></blockquote><p><strong>费劲死了,电压表蜂鸣档直接测</strong></p><blockquote><p>确实费劲———————————————2025&#x2F;6&#x2F;13</p></blockquote><p><a href="https://detail.tmall.com/item.htm?ali_trackid=2:mm_50570328_39070332_145428725:1684914191_026_477441657&bxsign=tbk4CjUu0VKiy6pgKc5NXCeGntgjFGlrlH0o4q57jjAgHBLTi-VROloECI7kUICD5dEgyj2SdysJccMa53Ljd_FEZRfl6OPYUwl5u5SCicHIhzEsLQQeKI_GUEAPW08w3zHuZsQuLKWuYx1_KtW-N5l5w&id=619450836896&spm=a2e1u.27655827.d1661933647166.20&union_lens=lensId:OPT@1684913782@213e7f1b_0ac4_1884caffd34_44f6@01@eyJmbG9vcklkIjo2MTc4NH0ie;recoveryid:201_33.43.202.19_13111709_1684913724229;prepvid:201_33.50.201.183_13093957_1684913779022">自锁无锁开关视频介绍</a></p><h2 id="三极管"><a href="#三极管" class="headerlink" title="三极管"></a>三极管</h2><p>半导体三极管(Bipolar Junction Transistor)，也称双极型晶体管、晶体三极管，英文缩写BJT。<br>它是由两个PN结构成，三条引线分别称为 发射极e （Emitter）、 基极b (Base)和 集电极c (Collector)<br>类型分为NPN型与PNP型，如下图,p指向n,即p流向</p><h3 id="三极管有哪三极"><a href="#三极管有哪三极" class="headerlink" title="三极管有哪三极"></a>三极管有哪三极</h3><ul><li><strong>基极</strong>：用于激活晶体管。（名字的来源，最早的点接触晶体管有两个点接触放置在基材上，而这种基材形成了底座连接。）</li><li><strong>集电极</strong>：三极管的正极。（因为收集电荷载体）</li><li><strong>发射极</strong>：三极管的负极。（因为发射电荷载流子）</li></ul><p><a href="https://zhuanlan.zhihu.com/p/519072786">三极管的工作原理详解，图文+案例，立马教你搞懂 - 知乎</a></p><h2 id="放大状态"><a href="#放大状态" class="headerlink" title="放大状态"></a>放大状态</h2><p>放大状态下，基极的电流大一点，集电极的电流也会跟着变大！并且ic与ib存在一定比例关系，ic &#x3D; β ib，β是直流电流放大系数，表示三极管放大能力的大小。</p><h2 id="截止状态"><a href="#截止状态" class="headerlink" title="截止状态"></a>截止状态</h2><h2 id="饱和状态"><a href="#饱和状态" class="headerlink" title="饱和状态"></a>饱和状态</h2><p>就是达到一定程度后,继续增大基极电流也无法增到集电极的电流了</p><h1 id="三极管的3接线类型"><a href="#三极管的3接线类型" class="headerlink" title="三极管的3接线类型"></a>三极管的3接线类型</h1><p>这里主要有三种类型：共基极 (CB)、共集电极 (CC) 和共发射极 (CE)。</p><h2 id="NPN"><a href="#NPN" class="headerlink" title="NPN"></a>NPN</h2><h2 id="PNP"><a href="#PNP" class="headerlink" title="PNP"></a>PNP</h2><h3 id="8550三极管"><a href="#8550三极管" class="headerlink" title="8550三极管"></a>8550三极管</h3><p><img src="/61H-%E4%B8%80%E4%BA%9B%E5%85%83%E5%99%A8%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.jpg" alt="image-20230524151959362"></p><p>（文字朝自己，引脚朝下）从左到右数如下:</p><p>1脚&#x3D;E（<a href="https://baike.baidu.com/item/%E5%8F%91%E5%B0%84%E6%9E%81/5957463?fromModule=lemma_inlink">发射极</a>，带箭头的那个），</p><p>2脚&#x3D;B（<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9E%81/763327?fromModule=lemma_inlink">基极</a>），</p><p>3脚&#x3D;C（集电极）.</p><p>8550<a href="https://baike.baidu.com/item/%E4%B8%89%E6%9E%81%E7%AE%A1?fromModule=lemma_inlink">三极管</a>（SOT-23封装）管脚图</p><p>1、B（基极)　2、E（发射极)　3、C（集电极)</p><h3 id="s8050三极管"><a href="#s8050三极管" class="headerlink" title="s8050三极管"></a>s8050三极管</h3><p>SOT封装的s8050三极管</p><p>基级,发射集,集电极,对应引脚1,2,3</p><p><img src="https://pics6.baidu.com/feed/2e2eb9389b504fc2a2720fc828b2501a91ef6d4d.png@f_auto?token=09351f9bce6acc8467384f8ca7c7c4ff" alt="img"></p><p><img src="/61H-%E4%B8%80%E4%BA%9B%E5%85%83%E5%99%A8%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230722181609855.png" alt="image-20230722181609855"></p><h3 id="三极管的作用"><a href="#三极管的作用" class="headerlink" title="三极管的作用"></a>三极管的作用</h3><p>三极管更多的是做一个开关管来使用，且只有截止、饱和两个状态。截止状态看作是“关”，饱和状态看作是“开”</p><h4 id="开关作用"><a href="#开关作用" class="headerlink" title="开关作用"></a>开关作用</h4><p>三极管作为开关时,要么是工作在饱和区,即导通,要么是工作在截至区,即截止</p><p>不能工作再放大区(由于Vce电压难以确定,无法区分高低电平)</p><p><strong>导通</strong></p><blockquote><p><strong>NPN</strong>:导通条件:(Vbe)大于某个阈值(通常约为0.7V),即VB&gt;VE</p><p><strong>PNP</strong>:与NPN相反</p></blockquote><p><strong>截止</strong>*</p><p><strong>NPN</strong>:(Vbe)小于阈值时,一般小于0</p><p>三极管可靠截止条件是:uBE ≤ 0 饱和导通条件是:iB≥IB(sat)</p><p><strong>PNP</strong>:与NPN相反</p><p><a href="https://blog.csdn.net/lx123010/article/details/122967176">三极管开关作用_3极管的开关作用和工作原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/501215906">三极管的工作原理</a></p><img src="/2023/05/24/61h-san-ji-guan/image-20230722202242360.png" class="" title="image-20230722202242360"><h4 id="放大作用"><a href="#放大作用" class="headerlink" title="放大作用"></a>放大作用</h4><p>我不明白为什么不能集电极接3.3v接蜂鸣器,发射极接地</p><blockquote><p>因为蜂鸣器是因为需要放大电流才会使用三极管,如果将三极管接在发射极,就会失去放大作用</p><p>npn型三极管如8050,当be通电时,会吸引电子,有空穴,但是左边N的电子密度大于空穴</p><p>所以一个空穴会有多个电子去抢,左边的电子浓度大于右边,使电子穿过中间的P区到达C,也就是说</p><p>BE每吸引一个电子到E,就会有一堆,也就是<code>β倍的电子流向c</code></p><img src="/2023/05/24/61h-san-ji-guan/image-20230722210429336.png" class="" title="image-20230722210429336"><img src="/2023/05/24/61h-san-ji-guan/image-20230722210821202.png" class="" title="image-20230722210821202"></blockquote><p>也就是说三极管的放大作用Ic&#x3D;β*Ib只在c极放大，放下面仅仅是开关作用——————–2025&#x2F;6&#x2F;6</p><p>**PNP</p><p>先给CE通电使E极将正电空穴推往中间,C极释放电子填补中间空穴,</p><p>此时耗尽层仍然很大,无法通过,然后给BE施加电压,B极发送一个电子,顶掉P填补P的空穴,</p><p>这一瞬间左侧空穴和中间空穴都显正电,吸引右侧P倍的电子通过耗尽层</p><img src="/2023/05/24/61h-san-ji-guan/image-20230723071532924.png" class="" title="image-20230723071532924"><img src="/2023/05/24/61h-san-ji-guan/image-20230723070424558.png" class="" title="image-20230723070424558"><img src="/2023/05/24/61h-san-ji-guan/image-20230723070617985.png" class="" title="image-20230723070617985"><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>硅晶体不导电,硅原子四个电子,硅晶体周围八个电子四个共价键,稳定,电子不动</p><p>掺B,      3+4形成7电子机啊一个空穴,正电,负极输入负电荷填充到空穴再被正极吸引-&gt;P型半导体</p><p>掺P,,五个电子+4形成八电子加一自由电子,导电了,因为自由电子会移动-&gt;N型半导体</p><p>二极管具有单向导电性,腹肌推动电子前进,&gt;0.7v即可穿过p区域</p><img src="/2023/05/24/61h-san-ji-guan/image-20230722211013917.png" class="" title="image-20230722211013917"><p>反向截止,因为耗尽层(pn结)增大,个人理解,两边距离变大了,为什么叫耗尽层,我理解的是+-,电子-&gt;,走不动</p><img src="/2023/05/24/61h-san-ji-guan/image-20230722212300595.png" class="" title="image-20230722212300595"><img src="/2023/05/24/61h-san-ji-guan/image-20230722211130400.png" class="" title="image-20230722211130400"><p><a href="https://www.bilibili.com/video/BV1fB4y147Gn/?spm_id_from=333.788&vd_source=e33ad22b3d91cb180bef532ce5877b2e">终于有人讲了，凭什么三极管能放大?_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1js4y1A7GU/?buvid=XXBDF84B608D26441D57DCC92DCF748F1B01A&is_story_h5=false&mid=ige4SFfjyP88bhZMDXpf6g==&p=1&plat_id=114&share_from=ugc&share_medium=android&share_plat=android&share_session_id=ac455019-b821-4d6f-8733-31372cf7a6e9&share_source=COPY&share_tag=s_i&timestamp=1682047526&unique_k=LjVL2ks&up_id=677486623&vd_source=e33ad22b3d91cb180bef532ce5877b2e">没人讲PNP三极管是吧?我讲!_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/read/cv22690611/">3.3V 蜂鸣器电路设计 - 哔哩哔哩 (bilibili.com)</a></p><p>[三极管工作原理介绍(动画图解)]<a href="https://blog.csdn.net/qq_40907156/article/details/125163969?ops_request_misc=%7B%22request_id%22:%22168576074216800222849050%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168576074216800222849050&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-125163969-null-null.142%5Ev88%5Einsert_down38v5,239%5Ev2%5Einsert_chatgpt&utm_term=%E4%B8%89%E7%BA%A7%E7%AE%A1&spm=1018.2226.3001.4187">https://blog.csdn.net/qq_40907156/article/details/125163969?ops_request_misc=%7B%22request%5Fid%22%3A%22168576074216800222849050%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168576074216800222849050&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-125163969-null-null.142^v88^insert_down38v5,239^v2^insert_chatgpt&amp;utm_term=三级管&amp;spm=1018.2226.3001.4187</a>)</p><p><strong>注意：三极管饱和导通的条件：在电路中ce两端电压接近0V且小于eb电压。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TPS54560DDAR降压模块</title>
      <link href="/2023/05/12/60h-tps54560ddar-jiang-ya-mo-kuai/"/>
      <url>/2023/05/12/60h-tps54560ddar-jiang-ya-mo-kuai/</url>
      
        <content type="html"><![CDATA[<p>在TPS54560DDAR模块中，输出电压的反馈电路是由一个电阻分压器组成的。这个电阻分压器包括两个固定阻值电阻 R1 和 R2，以及一个反馈电阻 RF，如下图所示：</p><pre class="line-numbers language-none"><code class="language-none">+Vin  |  |  | &#x2F; \R1 R2|   ||   ||   |--- |  | |RF|_| Vout  |----------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反馈电路的基本原理是，通过调整反馈电路的电阻值，使得反馈电压等于参考电压（通常为0.8V），从而实现稳定的输出电压。在TPS54560DDAR中，输出电压的公式为：</p><p>Vout &#x3D; Vref x (1 + R1&#x2F;R2) + RF x I(RF)</p><p>其中，Vref 是参考电压（通常为0.8V），R1 和 R2 是电阻分压器的两个固定电阻，RF 是反馈电阻，I(RF) 是通过反馈电阻 RF 流过的电流。</p><p>如果假设 TPS54560DDAR 的参考电压 Vref 为 0.8V，反馈电阻 RF 的阻值为 10 kΩ，那么输出电压 Vout 可以通过以下公式计算：<br>Vout &#x3D; Vref x (1 + R1&#x2F;R2) + RF x I(RF)<br>其中，R1 和 R2 是电阻分压器中的两个电阻，I(RF) 是通过反馈电阻 RF 流过的电流。<br>代入您提供的电阻值和参考电压，可以计算出：<br>Vout &#x3D; 0.8V x (1 + 86.6&#x2F;5.22) + 10 kΩ x I(RF)<br>Vout &#x3D; 14.7V + 10 kΩ x I(RF)<br>需要注意的是，反馈电流 I(RF) 的大小取决于输出电压 Vout 和反馈电阻 RF 的阻值。如果您想要计算出具体的输出电压值，需要进一步确定反馈电流的大小。通常情况下，可以根据所需的输出电压和反馈电阻的阻值，使用欧姆定律计算出反馈电流的大小，然后代入上述公式中计算出输出电压的值。</p><h3 id="4-7m是指电阻475吗"><a href="#4-7m是指电阻475吗" class="headerlink" title="4.7m是指电阻475吗"></a>4.7m是指电阻475吗</h3><p>是。电阻的命名方法一般采用颜色环带标记法，其中包括了电阻的阻值、精度、温度系数等信息。475电阻的阻值为47 × 10^5Ω，即475kΩ，4.7MΩ</p><p>例如:</p><p>330欧姆.这个很好计算的,前两位是有效数字,第三位是指数.331表示为33乘以10的1次方,即为330欧姆.如472即为47乘以10的2次方,即4.7K欧.</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>没有效果,即输入电压等于输出电压,r5,6,7,8,均没有电压</p><ul><li>原因:电路画错了<img src="/2023/05/12/60h-tps54560ddar-jiang-ya-mo-kuai/image-20230524152755308.png" class="" title="image-20230524152755308"></li><li>至于错哪里了,电路没学好,暂时不明白……</li><li><img src="/2023/05/12/60h-tps54560ddar-jiang-ya-mo-kuai/image-20230524152614852.png" class="" title="image-20230524152614852"></li></ul><h2 id="光耦测速器"><a href="#光耦测速器" class="headerlink" title="光耦测速器"></a>光耦测速器</h2><p>需求:利用光耦传感器,计算通过光耦的时间,显示在数码管上,主控芯片stc89c52(便宜)</p><p>预期问题:数码管驱动芯片,以及相关芯片的驱动代码</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy框架</title>
      <link href="/2023/04/26/59p-scrapy-kuang-jia/"/>
      <url>/2023/04/26/59p-scrapy-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p>类里面会默认传递self参数,措意使用i.get时会报错,说你给了两个参数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import scrapyclass WangyiSpider(scrapy.Spider):    name &#x3D; &quot;wangyi&quot;    allowed_domains &#x3D; [&quot;163.com&quot;]    start_urls &#x3D; [&quot;https:&#x2F;&#x2F;news.163.com&#x2F;&quot;]    def parse(self, response):        selector&#x3D;response.xpath(&#39;&#x2F;&#x2F;div[contains(@ne-if, &quot;&#123;&#123;&quot; )]&#x2F;div&#x2F;a&#39;)        for i in selector:            # print(i.get(&quot;href&quot;))            print(i.xpath(&#39;@href&#39;).get())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>selector是一个选择器,相当于一个大列表里面放下全部,使用extract()相当于,提出来每个a标签</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">category_list &#x3D;response.xpath(&#39;&#x2F;&#x2F;div[contains(@ne-if, &quot;&#123;&#123;&quot; )]&#x2F;@ne-if&#39;).extract()        for cate in category_list:            print(cate)            &#123;&#123;__i &#x3D;&#x3D; 5&#125;&#125;&#123;&#123;__i &#x3D;&#x3D; 6&#125;&#125;&#123;&#123;__i &#x3D;&#x3D; 7&#125;&#125;&#123;&#123;__i &#x3D;&#x3D; 8&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>序号问题不用管,主要是看一下这个区别</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">category_list &#x3D;response.xpath(&#39;&#x2F;&#x2F;div[contains(@ne-if, &quot;&#123;&#123;&quot; )]&#x2F;@ne-if&#39;)        for cate in category_list:            print(cate)             &lt;Selector xpath&#x3D;&#39;&#x2F;&#x2F;div[contains(@ne-if, &quot;&#123;&#123;&quot; )]&#x2F;@ne-if&#39; data&#x3D;&#39;&#123;&#123;__i &#x3D;&#x3D; 0&#125;&#125;&#39;&gt;&lt;Selector xpath&#x3D;&#39;&#x2F;&#x2F;div[contains(@ne-if, &quot;&#123;&#123;&quot; )]&#x2F;@ne-if&#39; data&#x3D;&#39;&#123;&#123;__i &#x3D;&#x3D; 1&#125;&#125;&#39;&gt;&lt;Selector xpath&#x3D;&#39;&#x2F;&#x2F;div[contains(@ne-if, &quot;&#123;&#123;&quot; )]&#x2F;@ne-if&#39; data&#x3D;&#39;&#123;&#123;__i &#x3D;&#x3D; 2&#125;&#125;&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以,相当于是,返回了一个selector的选择器列表,然后我for循环提出单个的选择器,然后得用get或者extract提出具体值,那为什么以前我都没用过get,还是说,只是scrapy的xpath是这样的,lxml模块并不是这样的</p><blockquote><p>不对,是因为你提取的是属性,就需要get()或者extract()</p></blockquote><p>在Scrapy中，<code>extract()</code>和<code>get()</code>方法都可以用于从<code>Selector</code>对象中提取文本或属性的值。它们的主要区别在于：</p><ol><li>返回类型：<code>extract()</code>方法返回一个字符串列表，而<code>get()</code>方法返回一个字符串。</li><li>默认值：如果<code>extract()</code>方法无法找到匹配的元素或属性，则返回一个空列表。如果<code>get()</code>方法无法找到匹配的元素或属性，则返回一个<code>None</code>值。</li><li>参数：<code>get()</code>方法可以接受一个默认值作为参数，在找不到匹配的元素或属性时返回该默认值。而<code>extract()</code>方法没有这个参数，如果需要使用默认值，需要通过Python的条件表达式来实现。</li></ol><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>download中间件和spider中间件是两个,这两个中间件所处的环节不一样,所以如果出现,中间件没起作用的现象,有可能是setting里设置错了中间件</p><p>,中间件是如何被调用的</p><h2 id="全站爬虫"><a href="#全站爬虫" class="headerlink" title="全站爬虫"></a>全站爬虫</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">start_urls &#x3D; [&#39;http:&#x2F;&#x2F;www.daimg.com&#x2F;pic&#x2F;%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87&#39;] link &#x3D; LinkExtractor(tags&#x3D;[&#39;img&#39;], attrs&#x3D;&#39;src&#39;, deny_extensions&#x3D;[&#39;&#39;], )link2&#x3D;LinkExtractor(allow&#x3D;r&#39;pic&#x2F;%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87&#39;) rules &#x3D; (     Rule(link, callback&#x3D;&quot;parse_item&quot;, follow&#x3D;False, ),       Rule(link2, follow&#x3D;True), )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><h3 id="AttributeError"><a href="#AttributeError" class="headerlink" title="AttributeError"></a>AttributeError</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">title&#x3D;li.xpath(&quot;.&#x2F;a&#x2F;img&#x2F;@title&quot;).extract_first() AttributeError: &#39;str&#39; object has no attribute &#39;xpath&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个错误常常是由于XPath表达式的错误所引起的。在这个问题中，变量<code>li</code>是一个字符串，而不是一个Selector对象，因此你无法使用XPath表达式在它上面调用<code>xpath()</code>函数。</p><p>同时，你还需要确保在XPath表达式中使用的元素一定是存在的，否则，<code>extract_first()</code>方法将抛出<code>AttributeError</code>异常。</p><h3 id="新建项目后容易出现的问题"><a href="#新建项目后容易出现的问题" class="headerlink" title="新建项目后容易出现的问题"></a>新建项目后容易出现的问题</h3><p>1.类名没有更改</p><p>2.模块没有导入,导入的时候注意名字的更改</p><p>3.如果没有返回你想要的结果,但是程序还没有结束,不妨多等一会</p><h2 id="CrawlSpider"><a href="#CrawlSpider" class="headerlink" title="CrawlSpider"></a>CrawlSpider</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">start_urls &#x3D; [&#39;http:&#x2F;&#x2F;www.daimg.com&#x2F;photo&#x2F;people&#x2F;&#39;] link &#x3D; LinkExtractor(tags&#x3D;[&#39;img&#39;], attrs&#x3D;&#39;src&#39;, deny_extensions&#x3D;[&#39;&#39;], ) link2 &#x3D; LinkExtractor(allow&#x3D;r&#39;&#x2F;photo&#x2F;people&#x2F;&#39;) rules &#x3D; (     Rule(link, callback&#x3D;&quot;parse_item&quot;, follow&#x3D;False, ),     Rule(link2, follow&#x3D;True), )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码是一个 scrapy 的爬虫规则（<code>rules</code>），其中爬虫起始网址为 <code>http://www.daimg.com/pic/%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87</code>，也就是美女图片的网站，后面的 <code>%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87</code> 是 url 编码后的中文字符，实际上对应的就是 “美女图片” 这个词。这个起始网址是个列表，意味着可以包含多个值。</p><p>使用了两个 <code>LinkExtractor</code>，第一个用于提取网页中的图像链接，第二个则是用于在满足特定正则表达式规则的链接上递归爬取。第一行中，<code>deny_extensions=[&#39;&#39;]</code> 表示排除文件扩展名为空的链接，因为这些链接通常是指向网页本身或者跳转链接的。<code>tags=[&#39;img&#39;], attrs=&#39;src&#39;</code> 表示只提取 img 标签中的 src 属性。在第二行中，<code>allow=r&#39;pic/%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87&#39;</code> 表示只递归匹配链接中包含 “pic&#x2F;美女图片” 这个字符串的链接。</p><p>定义了两个规则，第一个规则对应 <code>link</code> 变量，即只爬取当前网页中的所有图像链接并调用解析函数 <code>parse_item</code> 进行处理；第二个规则对应 <code>link2</code> 变量，即用于递归爬取在当前网页中包含 “pic&#x2F;美女图片” 的链接。<code>follow=False</code> 则表示对第一个规则提取到的链接不进行递归爬取。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>类实现爬取小说存储到mysql遇到的问题</title>
      <link href="/2023/04/14/58p-pa-qu-xiao-shuo-yu-dao-de-error/"/>
      <url>/2023/04/14/58p-pa-qu-xiao-shuo-yu-dao-de-error/</url>
      
        <content type="html"><![CDATA[<h2 id="类实现"><a href="#类实现" class="headerlink" title="类实现"></a>类实现</h2><h3 id="参数个数一致却报错"><a href="#参数个数一致却报错" class="headerlink" title="参数个数一致却报错"></a>参数个数一致却报错</h3><p>TypeError: get_chapters() takes 3 positional arguments but 4 were given</p><p> get_chapters()需要3个位置参数，但给出的是4个</p><p>报错原因:调用函数的时候把self也当做参数给了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#错误写法def get_bookname(self):    self.get_chapters(self,bookName,bookId, book_path)def get_chapters(self,bookName, bookId, book_path):<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在类方法中，第一个参数通常是 <code>self</code>，它表示对该类实例的引用。当你调用类方法时，Python 会自动将该类实例传递给 <code>self</code> 参数。因此，在调用类方法时，不需要显式传递 <code>self</code> 参数。</p><h3 id="for循环失效"><a href="#for循环失效" class="headerlink" title="for循环失效"></a>for循环失效</h3><p>原因:for循环里面有<code>return</code></p><pre class="line-numbers language-none"><code class="language-none">&quot;&quot;&quot;切记return执行后函数不会在继续执行了如果在函数for循环后面return,则for循环只执行一次&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建多级目录"><a href="#创建多级目录" class="headerlink" title="创建多级目录"></a>创建多级目录</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import osbook_path &#x3D; os.path.join(&quot;我的书架&quot;, bookName)if not os.path.exists(book_path):    os.makedirs(os.path.join(&quot;我的书架&quot;, bookName))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>os.makedirs()</code> 函数可以递归地创建多级目录。在这个例子中，如果 “我的书架” 目录不存在，则 <code>os.makedirs()</code> 会自动创建 “我的书架” 目录，然后在 “我的书架” 目录下创建 <code>bookName</code> 子目录。</p><h2 id="存储到mysql数据库"><a href="#存储到mysql数据库" class="headerlink" title="存储到mysql数据库"></a>存储到mysql数据库</h2><h3 id="报错AttributeError-‘NoneType’-object-has-no-attribute-‘encoding’"><a href="#报错AttributeError-‘NoneType’-object-has-no-attribute-‘encoding’" class="headerlink" title="报错AttributeError: ‘NoneType’ object has no attribute ‘encoding’"></a>报错AttributeError: ‘NoneType’ object has no attribute ‘encoding’</h3><p>起因关于charset的设置,我在类方法的初始化里设置<code>charset=&quot;utf-8&quot;</code></p><p>就会报上面的错误,删掉就好了</p><p>原因:</p><blockquote><p>MySQL 默认的字符集是 <code>utf8mb4</code>，<code>utf8</code> 和 <code>utf8mb4</code> 都是用于存储 Unicode 字符的字符集，但它们之间有一些差异。</p><p>在 MySQL 5.5.3 之前的版本中，<code>utf8</code> 只支持最多 3 个字节的 Unicode 字符，而 <code>utf8mb4</code> 支持最多 4 个字节的 Unicode 字符。这意味着如果你使用 <code>utf8</code> 存储 4 个字节的 Unicode 字符，会出现截断数据的情况。因此，在 MySQL 5.5.3 及以后的版本中，建议使用 <code>utf8mb4</code> 作为默认字符集。</p><p>在实际使用中，<code>UTF-8</code> 和 <code>UTF8</code> 通常是可以互换使用的，在 MySQL 中，<code>UTF-8</code> 和 <code>UTF8</code> 可能无法互换使用，<code>UTF8</code> 是指代 <code>utf8mb3</code> 字符集的别名，它使用最多 3 个字节来存储 Unicode 字符。而 <code>UTF-8</code> 则是标准中使用连字符 <code>-</code> 分隔的字符集名称，它使用 1 到 4 个字节来存储 Unicode 字符。</p><p>在 MySQL 中，如果你使用 <code>UTF-8</code> 来替代 <code>UTF8</code>，可能会导致 MySQL 无法识别该字符集名称，从而出现错误。</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Spider(object):    def __init__(self, host, port, user, password,                 database, charset, **kwargs):        # 连接数据库服务器        self.conn &#x3D; pymysql.connect(host&#x3D;host, port&#x3D;port, user&#x3D;user, password&#x3D;password,                                    database&#x3D;database, cursorclass&#x3D;pymysql.cursors.DictCursor,                                    charset&#x3D;charset, **kwargs)        # 获取游标        self.cursor &#x3D; self.conn.cursor()        # 初始化表、        self.init_table()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">def init_table(self):    # 使用 execute()  方法执行 SQL 查询    sql1 &#x3D; &quot;&quot;&quot;              create table if not exists book(              id int primary key auto_increment,              bookName varchar(32),              coverImg varchar(255),              authorPenName varchar(32)              )character set&#x3D;utf8;               &quot;&quot;&quot;    self.query(sql1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解决表记录重复问题"><a href="#解决表记录重复问题" class="headerlink" title="解决表记录重复问题"></a>解决表记录重复问题</h3><p>两个方法,一个是报错停止,一个是跳过</p><ul><li>您可以在数据库表中添加唯一约束。在这种情况下，如果插入的记录重复，则会引发错误，从而防止重复的记录被插入。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">ALTER TABLE table_name ADD UNIQUE (column_name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    cursor.execute(&quot;INSERT INTO book (bookName, coverImg, authorPenName) VALUES (%s, %s, %s)&quot;, (bookName, coverImg, authorPenName))    conn.commit()    print(&quot;插入成功&quot;)except mysql.connector.IntegrityError:    print(&quot;记录已存在&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，<code>cursor.execute</code>方法执行参数化查询，并将变量值作为参数传递。如果插入记录时发生唯一约束冲突，则会引发<code>mysql.connector.IntegrityError</code>异常，您可以根据需要处理该异常</p><ul><li>您可以使用<code>INSERT IGNORE</code>语句来在插入记录时跳过重复记录。这个语句会尝试将记录插入表中，但是如果违反了唯一约束，则会忽略该操作，而不是引发错误。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># a&#x3D;&quot;INSERT IGNORE INTO book (bookName)&quot;# self.query(a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">sql &#x3D; f&quot;&quot;&quot;insert into book (bookName,coverImg,authorPenName) values (      &quot;&#123;bookName&#125;&quot;,&quot;&#123;coverImg&#125;&quot;,&quot;&#123;authorPenName&#125;&quot;);&quot;&quot;&quot;      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">sql &#x3D; f&quot;&quot;&quot;insert IGNORE into book (bookName,coverImg,authorPenName) values (            &quot;&#123;bookName&#125;&quot;,&quot;&#123;coverImg&#125;&quot;,&quot;&#123;authorPenName&#125;&quot;);&quot;&quot;&quot;print(&quot;sql:::&quot;, sql)self.query(sql)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在您的Python代码中，您可以使用以下命令来执行<code>INSERT IGNORE</code>语句：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cursor.execute(&quot;INSERT IGNORE INTO book (bookName, coverImg, authorPenName) VALUES (%s, %s, %s)&quot;, (bookName, coverImg, authorPenName))conn.commit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这个示例中，<code>cursor.execute</code>方法执行<code>INSERT IGNORE</code>语句，并将变量值作为参数传递。如果插入记录时发生唯一约束冲突，则会忽略该操作，而不是引发错误。请注意，即使插入操作被忽略，您仍然需要调用<code>conn.commit()</code>方法来提交事务。</p><h2 id="一定要注意for循环后面的语句的位置"><a href="#一定要注意for循环后面的语句的位置" class="headerlink" title="一定要注意for循环后面的语句的位置"></a>一定要注意for循环后面的语句的位置</h2><p>如何return放在for循环里,就只会执行一次</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32+esp8266智能安全监测系统</title>
      <link href="/2023/04/11/57h-stm32-esp8266-zhi-neng-an-quan-jian-ce-xi-tong/"/>
      <url>/2023/04/11/57h-stm32-esp8266-zhi-neng-an-quan-jian-ce-xi-tong/</url>
      
        <content type="html"><![CDATA[<img src="/2023/04/11/57h-stm32-esp8266-zhi-neng-an-quan-jian-ce-xi-tong/image-20230411220130176.png" class="" title="image-20230411220130176"><img src="/2023/04/11/57h-stm32-esp8266-zhi-neng-an-quan-jian-ce-xi-tong/image-20230411220130176.png" class="" title="text"><img src="/2023/04/11/57h-stm32-esp8266-zhi-neng-an-quan-jian-ce-xi-tong/image-20230411220401901.png" class="" title="image-20230411220401901"><img src="/2023/04/11/57h-stm32-esp8266-zhi-neng-an-quan-jian-ce-xi-tong/image-20230411220401901.png" class="" title="text">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>爬取m3u8视频</title>
      <link href="/2023/04/08/56p-pa-qu-m3u8-shi-pin/"/>
      <url>/2023/04/08/56p-pa-qu-m3u8-shi-pin/</url>
      
        <content type="html"><![CDATA[<h2 id="异步爬虫"><a href="#异步爬虫" class="headerlink" title="异步爬虫"></a>异步爬虫</h2><h3 id="报错Event-loop-is-closed"><a href="#报错Event-loop-is-closed" class="headerlink" title="报错Event loop is closed"></a>报错Event loop is closed</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">tasks &#x3D; []for url in ts_urls:    ts_res &#x3D; await aiohttp_(url,&quot;content&quot;)    decrypted_data &#x3D; await decrypt(ts_res, key)    await download(decrypted_data, name)task &#x3D; asyncio.create_task(download(decrypted_data,name))tasks.append(task)   await asyncio.wait(tasks)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    start &#x3D; time.time()    #这句代码容易出现错误Event loop is closed    asyncio.run(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>大佬的解释:</p><blockquote><p>aiohttp 内部使用了 _ProactorBasePipeTransport ，程序退出释放内存时自动调用其 <strong>del</strong> 方法导致二次关闭事件循环。一般的协程程序是不会使用_ProactorBasePipeTransport 的，所以asyncio.run() 还是可以正常运行。而且这种情况仅在Windows上发生。</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"># loop &#x3D; asyncio.get_event_loop()# loop.run_until_complete(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是我发现改成上面的代码后会报别的错误,并且当我把错误全都改正后,继续使用<code>asyncio.run()</code>也可以正常运行,所以我的理解是,其他代码出现错误后,会导致循环关闭</p><h3 id="AttributeError-‘NoneType’-object-has-no-attribute-‘group’"><a href="#AttributeError-‘NoneType’-object-has-no-attribute-‘group’" class="headerlink" title="AttributeError: ‘NoneType’ object has no attribute ‘group’"></a>AttributeError: ‘NoneType’ object has no attribute ‘group’</h3><p>使用 <code>group()</code> 方法提取捕获组的值。但是，如果没有找到匹配项，<code>search()</code> 方法将返回 <code>None</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">if match is not None:    print(match.group(1))else:    print(&#39;No match found&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="none返回值为空"><a href="#none返回值为空" class="headerlink" title="none返回值为空"></a>none返回值为空</h3><p>如果在爬虫是出现返回值为空的情况,要检查一下源代码,看看爬取的数据是否是动态生成或者修改的</p><h3 id="AttributeError-aenter"><a href="#AttributeError-aenter" class="headerlink" title="AttributeError:__aenter __"></a>AttributeError:__aenter __</h3><p>直接使用async,会报错是因为在使用 “async with” 语句时，不能直接使用 Python 内置的 “open” 函数进行异步文件操作。因为 “open” 函数没有定义 “<strong>aenter</strong>“ 方法，所以会出现 “AttributeError: aenter” 错误。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">async with open(f&quot;ts文件&#x2F;&#123;name&#125;&quot;, &quot;ab&quot;) as f:    await f.write(decrypted_data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">async with aiofiles.open(f&quot;ts文件&#x2F;&#123;name&#125;&quot;, &quot;ab&quot;) as f:    await f.write(decrypted_data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是这样写就可以,使用 “aiofiles” 库来进行异步文件操作</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">async with aiohttp.ClientSession() as session:async with session.get(path, ssl&#x3D;False) as resp:# 将得到的请求保存到文件中with open(&quot;ts文件&#x2F;&quot; + ts, &quot;wb&quot;) as f:f.write(await resp.content.read())print(f&quot;&#123;ts&#125;下载完成！&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码可以正常运行是因为在 <code>&quot;async with&quot; </code>语句中使用的是 <code>&quot;aiohttp.ClientSession()&quot;</code> 对象，而不是 Python 内置的 “open” 函数。 <code>&quot;aiohttp.ClientSession()&quot; </code>对象已经定义了 <code>&quot;**aenter**&quot;</code> 和 <code>&quot;**aexit**&quot; </code>方法，可以用于异步上下文管理器，因此可以使用 “async with” 语句来进行异步操作。</p><p>在这段代码中，首先使用 “aiohttp.ClientSession()” 对象创建一个异步的 HTTP 客户端会话，然后使用 “session.get()” 方法发起一个 GET 请求，返回一个响应对象 “resp”。接着，使用 “await resp.content.read()” 方法异步读取响应内容，并将结果写入到文件中。最后，输出下载完成的提示信息。</p><h2 id="url的拼接"><a href="#url的拼接" class="headerlink" title="url的拼接"></a>url的拼接</h2><h3 id="使用urljoin库拼接"><a href="#使用urljoin库拼接" class="headerlink" title="使用urljoin库拼接"></a>使用urljoin库拼接</h3><p><code>urljoin</code> 是 Python 内置的一个函数，用于合并两个 URL<code>urljoin</code> 函数不仅仅是简单地将两个 URL 连接起来。它还会处理 URL 中的相对路径和绝对路径，确保返回的 URL 是正确的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib.parse import urljoinkey_url &#x3D; urljoin(second_m3u8_link, key_line)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="使用””-join-拼接"><a href="#使用””-join-拼接" class="headerlink" title="使用””.join()拼接"></a>使用””.join()拼接</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import ossecond_m3u8_link &#x3D; os.path.join(os.path.dirname(first_m3u8_link),&quot;&#x2F;&quot;.join(res.text.split(&quot;&#x2F;&quot;)[-3:])))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中这个返回的是以<code>&quot;/&quot;</code>为分隔符,从后往前取三个,使用”&#x2F;“.join把他们串成字符串就是1200kb&#x2F;hls&#x2F;LV5eaTwd.ts</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#url&#x3D;&quot;https:&#x2F;&#x2F;s1.fsvod1.com&#x2F;20220225&#x2F;fmrpwm7M&#x2F;1200kb&#x2F;hls&#x2F;LV5eaTwd.ts&quot;&quot;&#x2F;&quot;.join(res.text.split(&quot;&#x2F;&quot;)[-3:])输出 1200kb&#x2F;hls&#x2F;LV5eaTwd.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也可以这样写</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">second_m3u8_link &#x3D; os.path.join(os.path.dirname(first_m3u8_link), &quot;&#x2F;&quot;.join(res.text.split(&quot;\n&quot;)[-3:]))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>windows系统不行,windows的输出会变成这样,可能是因为windows生成路径用的就是\</p><blockquote><p>“<a href="https://s1.fsvod1.com/20220225/fmrpwm7M/1200kb/hls/LV5eaTwd.ts">https://s1.fsvod1.com/20220225/fmrpwm7M\1200kb/hls/LV5eaTwd.ts</a>“</p></blockquote><p><code>os.path.join()</code> 方法用于将多个路径组合成一个路径字符串。在这里，它将 变量组合成一个路径字符串，并将其分隔符设置为操作系统的默认分隔符，在 Windows 上为反斜杠（\），在 Unix 上为正斜杠（&#x2F;）。</p><p>并且那个反斜杠无法用replace替换,无效,这个我暂时不知道为什么</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">second_m3u8_link.replace(&#39;\\&#39;,&#39;&#x2F;&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="使用字符串直接-上"><a href="#使用字符串直接-上" class="headerlink" title="使用字符串直接+上"></a>使用字符串直接+上</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">second_m3u8_link&#x3D;(os.path.dirname(first_m3u8_link)+&quot;&#x2F;&quot;+&quot;&#x2F;&quot;.join(res.text.split(&quot;&#x2F;&quot;)[-3:])).split()[0]#这里的split()是去url后面的\n的(不晓得从哪多出来个\n),返回的是列表所以用[0]给他取出来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="使用正则匹配到需要的那部分"><a href="#使用正则匹配到需要的那部分" class="headerlink" title="使用正则匹配到需要的那部分"></a>使用正则匹配到需要的那部分</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">last_m3u8_url &#x3D; re.findall(r&quot;&#x2F;.*?&#x2F;.*?(&#x2F;.*?m3u8?)&quot;, res.text)second_m3u8_link &#x3D; first_m3u8_link.rsplit(&quot;&#x2F;&quot;, 1)[0] + &quot;&quot;.join(last_m3u8_url[0])#后面的[0]的意思是匹配到的全拿出来,用research<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="res-text、res-content与res-read的区别"><a href="#res-text、res-content与res-read的区别" class="headerlink" title="res.text、res.content与res.read的区别"></a>res.text、res.content与res.read的区别</h3><p>res.content 和 res.read() 方法都用于读取 HTTP 响应的内容，个人感觉没有区别,这次爬取m3u8视频用的是read估计是因为需要解密</p><p>res.content 返回的是响应内容的二进制数据，类型为 bytes，可以处理任何类型的响应数据，包括图片、视频、音频等二进制数据。</p><p>res.read() 方法则返回的是响应内容的原始字节数据，类型为 bytes，也可以处理各种类型的响应数据，但需要手动进行解码和处理。</p><p>当您使用 <code>requests</code> 库发送 HTTP 请求时，服务器将以二进制形式返回响应内容。如果您使用 <code>res.content</code> 获取响应内容，您将获得响应内容的二进制表示形式，这对于处理二进制数据（例如图像、音频、视频等）非常有用。如果您使用 <code>res.text</code> 获取响应内容，<code>requests</code> 库将尝试自动将响应内容解码为文本格式，并返回解码后的字符串.<code>即res.content和res.text</code>只是<code>返回的格式不同</code></p><p>因此，如果响应内容是文本类型，建议使用 res.text 属性获取响应内容；如果响应内容是二进制类型，则建议使用 res.content 或 res.read() 方法获取响应内容。</p><h2 id="加密视频"><a href="#加密视频" class="headerlink" title="加密视频"></a>加密视频</h2><blockquote><p>这个我现在还没弄清楚是怎么回事,暂且当固定用法使用</p></blockquote><p>在加密通信中，IV（Initialization Vector，初始化向量）是用于加密算法中的随机初始值。在使用 AES 算法进行 CBC 模式加密时，需要指定一个 IV 值，用于增加加密强度和安全性。在解密时，也需要使用相同的 IV 值才能正确解密。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">iv &#x3D; ts_res.content[:16]encrypted_data &#x3D; ts_res.content[16:]cipher &#x3D; AES.new(key, AES.MODE_CBC, iv)decrypted_data &#x3D; cipher.decrypt(encrypted_data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这部分代码是用于解密AES加密的数据的一个示例，是一种常见的用法。其中，iv是初始向量，是加密时使用的参数之一，需要和加密数据一起传输；encrypted_data是加密后的数据，它包含了加密后的视频内容；key是AES加密的密钥，用于解密数据。</p><p>这段代码使用了PyCryptodome库中的AES模块，使用了AES CBC模式进行解密。其中，初始向量iv的长度为16字节，与加密时的长度相同；密钥key的长度可以是16字节、24字节或32字节，具体取决于加密时使用的密钥长度。在解密时，我们将初始向量iv和密文encrypted_data传递给AES加密器对象cipher，并使用decrypt方法解密数据。解密后的数据存储在变量decrypted_data中，它就是原始的视频内容。</p><p>在解密过程中可能需要使用不同的初始向量、密钥和加密算法，具体取决于加密时使用的加密方式和密钥。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">当涉及到加密和解密时，Python中有很多库可以使用。以下是一个使用PyCryptodome库进行AES对称加密和解密的例子，让我来为你讲解一下这段代码：from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadimport base64key &#x3D; b&#39;1234567890123456&#39;  # 密钥必须是16、24或32字节长度iv &#x3D; b&#39;1234567890123456&#39;   # 初始向量必须是16字节长度plaintext &#x3D; b&#39;This is a secret message&#39; # 待加密的明文# 创建AES加密器，并使用CBC模式和PKCS7填充cipher &#x3D; AES.new(key, AES.MODE_CBC, iv)ciphertext &#x3D; cipher.encrypt(pad(plaintext, AES.block_size))# 将密文转换为Base64字符串ciphertext_base64 &#x3D; base64.b64encode(ciphertext).decode(&#39;utf-8&#39;)print(&#39;加密后的密文:&#39;, ciphertext_base64)# 将Base64字符串转换为二进制形式ciphertext &#x3D; base64.b64decode(ciphertext_base64.encode(&#39;utf-8&#39;))# 创建AES解密器，并使用CBC模式和PKCS7填充cipher&#x3D; AES.new(key, AES.MODE_CBC, iv)decrypted &#x3D; unpad(cipher.decrypt(ciphertext), AES.block_size)print(&#39;解密后的明文:&#39;, decrypted.decode(&#39;utf-8&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="视频合并"><a href="#视频合并" class="headerlink" title="视频合并"></a>视频合并</h2><p>这个是使用ffmpeg 对index.m3u8文件使用命令进行合并,通过<code>os.system()</code>,index.m3u8文件是把ts的res.content追加写入得到的,然后使用命令合并,其实不合并,直接改文件后缀,我觉得也是可以的,但是ffmpeg应该是有其他情况下的用法</p><h2 id="爬取js生成的动态数据"><a href="#爬取js生成的动态数据" class="headerlink" title="爬取js生成的动态数据"></a>爬取js生成的动态数据</h2><p>待更新…..</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xpath</title>
      <link href="/2023/03/30/55p-xpath/"/>
      <url>/2023/03/30/55p-xpath/</url>
      
        <content type="html"><![CDATA[<p>我记得是这个问题之前遇到过,然后好像记在一个写完的代码了 ,….然后代码删了……</p><h2 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h2><p><code>selector.xpath(&quot;/html/body/div[5]/dl/dd/a&quot;)``selector.xpath(&quot;/html/body/div[5]/dl/dd/a&quot;)[0]</code>两个表达式的区别。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">chapter_list&#x3D;selector.xpath(&quot;&#x2F;html&#x2F;body&#x2F;div[5]&#x2F;dl&#x2F;dd&#x2F;a&quot;)        chapter_list&#x3D;chapter_list.xpath(&quot;&#x2F;&#x2F;@href&quot;)        #chapter_list &#x3D; selector.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;Main List&quot;]&#x2F;dl&#x2F;dd&#x2F;a&#x2F;@href&#39;)        print(chapter_list)        for i in chapter_list:            print(i.text)                         error:  chapter_list&#x3D;chapter_list.xpath(&quot;&#x2F;&#x2F;@href&quot;)AttributeError: &#39;list&#39; object has no attribute &#39;xpath&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">chapter_list&#x3D;selector.xpath(&quot;&#x2F;html&#x2F;body&#x2F;div[5]&#x2F;dl&#x2F;dd&#x2F;a&quot;)[0]        chapter_list&#x3D;chapter_list.xpath(&quot;&#x2F;&#x2F;@href&quot;)        #chapter_list &#x3D; selector.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;Main List&quot;]&#x2F;dl&#x2F;dd&#x2F;a&#x2F;@href&#39;)        print(chapter_list)        for i in chapter_list:            print(i)  output:    [&#39;&#x2F;&#x2F;static.17k.com&#x2F;skin&#x2F;main.css?v&#x3D;0911&#39;, &#39;&#x2F;&#x2F;static.17k.com&#x2F;www&#x2F;skin&#x2F;main.css?v&#x3D;0915&#39;, &#39;&#x2F;&#x2F;static.17k.com&#x2F;www&#x2F;skin&#x2F;booklist.css?v&#x3D;091508&#39;, &#39;&#x2F;&#x2F;static.17k.com&#x2F;www&#x2F;skin&#x2F;17k_header.css&#39;, &#39;&#x2F;&#x2F;www.17k.com&#39;, .......&#39;https:&#x2F;&#x2F;www.12377.cn&#x2F;jbxzxq&#x2F;64d38691937611ebb858c9da04cf59d3_web.html&#39;]&#x2F;&#x2F;static.17k.com&#x2F;skin&#x2F;main.css?v&#x3D;0911&#x2F;&#x2F;static.17k.com&#x2F;www&#x2F;skin&#x2F;main.css?v&#x3D;0915&#x2F;&#x2F;static.17k.com&#x2F;www&#x2F;skin&#x2F;booklist.css?v&#x3D;091508&#x2F;&#x2F;static.17k.com&#x2F;www&#x2F;skin&#x2F;17k_header.css<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>selector.xpath(&quot;/html/body/div[5]/dl/dd/a&quot;)</code> 是一个 xpath 表达式，它匹配 HTML 文档中所有满足条件的 <code>a</code> 元素，并返回一个元素列表。由于这个表达式中没有使用下标，因此返回的是一个包含所有匹配元素的列表。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">[&lt;Element a at 0x25f34ff6380&gt;, &lt;Element a at 0x25f34ff6440&gt;, &lt;Element a at 0x25f35001580&gt;, &lt;Element a at 0x25f35001540&gt;, &lt;Element a at 0x25f35001500&gt;, &lt;Element a at 0x25f35001480&gt;, &lt;Element a at 0x25f35001440&gt;, &lt;Element a at 0x25f35001680&gt;, &lt;Element a at 0x25f35001600&gt;, &lt;Element a at 0x25f350014c0&gt;, &lt;Element a at 0x25f35001640&gt;, &lt;Element a at 0x25f35001f40&gt;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>selector.xpath(&quot;/html/body/div[5]/dl/dd/a&quot;)[0]</code> 则是对上面表达式的结果进行下标访问，它表示获取列表中的第一个元素。由于列表中的每个元素都是一个 <code>Element</code> 对象，因此 <code>[0]</code> 表示获取第一个 <code>Element</code> 对象。如果列表中没有任何元素，访问 <code>[0]</code> 会引发 IndexError 异常。</p><p>因此，<code>selector.xpath(&quot;/html/body/div[5]/dl/dd/a&quot;)[0]</code> 返回的是第一个匹配的 <code>a</code> 元素，如果需要获取所有匹配的元素，应该使用 <code>selector.xpath(&quot;/html/body/div[5]/dl/dd/a&quot;)</code>，并遍历列表中的所有元素，例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">chapter_list &#x3D; selector.xpath(&quot;&#x2F;html&#x2F;body&#x2F;div[5]&#x2F;dl&#x2F;dd&#x2F;a&quot;)for chapter in chapter_list:    # do something with chapter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样可以遍历所有匹配的 <code>a</code> 元素，并对每个元素执行相同的操作。</p><h2 id="匹配不到"><a href="#匹配不到" class="headerlink" title="匹配不到"></a>匹配不到</h2><p>可能是因为页面是动态生成的,需要检查源代码匹配</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>磁悬浮电路设计</title>
      <link href="/2023/03/18/54h-ci-xuan-fu-dian-lu-she-ji-0/"/>
      <url>/2023/03/18/54h-ci-xuan-fu-dian-lu-she-ji-0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python的异步</title>
      <link href="/2023/01/26/53p-python-de-yi-bu/"/>
      <url>/2023/01/26/53p-python-de-yi-bu/</url>
      
        <content type="html"><![CDATA[<p>全局变量与内部变量</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#test.pyb&#x3D;&quot;外部没改的&quot;def a():    global b    b&#x3D;&quot;内部改完了&quot;print(b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">#2.pyfrom .test import bprint(b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>输出结果为:外部没改的</p></blockquote><p>注意:代码导入就会被执行</p><p>没执行的原因可能有:</p><p>被导入的代码有<code>*if __name__ == &quot;__main__&quot;:*</code>被导入后,默认执行<code>*if __name__ == &quot;__init__&quot;:*</code>后面的<code>main()</code>就无法执行</p><p>如果您将 juejin.py 导入到 <strong>init</strong>.py 文件中，那么 juejin.py 中的所有代码都将在导入模块时被执行。如果 juejin.py 中有一个 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“ 的语句块，那么在导入 <strong>init</strong>.py 文件时，<strong>name</strong> 的值将是 “<strong>init</strong>“，而不是 “<strong>main</strong>“，所以 if 语句块中的代码不会被执行。</p><p>如果你想在导入juejin.py的时候执行他的某个函数，可以在__init__.py文件中直接调用。</p><p>建议你不要将一个模块导入到另一个模块中，因为这会使您的代码变得难以维护。应该考虑使用函数或类来导出需要的功能，而不是导入整个模块。</p><p>导入包</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import JueJin_Sign<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导入同包的文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from . import JueJin_Sign<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><h3 id="AttributeError-module-‘src-plugins-脚本管理-JueJin-Sign’-has-no-attribute-‘message-juejin’"><a href="#AttributeError-module-‘src-plugins-脚本管理-JueJin-Sign’-has-no-attribute-‘message-juejin’" class="headerlink" title="AttributeError: module ‘src.plugins.脚本管理.JueJin_Sign’ has no attribute ‘message_juejin’"></a>AttributeError: module ‘src.plugins.脚本管理.JueJin_Sign’ has no attribute ‘message_juejin’</h3><p>这句报错的意思是 模块没有message_juejin的属性,人话就是<code>没这个变量</code></p><p>如果你很确定,已经在juejin.py声明了全局变量,那么很正常,因为juejin.py有定时任务,导入时异步执行了,所以只是挂起,并未运行函数,也就没有这个属性了</p><p>然后我这样写(错误!!!)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">if message_juejin and message_upvps:    #可以确定任务执行完毕,已经有这个属性了,进行下一步操作else:    print(&quot;时间没到,还未签到&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>结果:仍然会出现上述报错,因为判断属性有没有的时候,仍然报错没有这个属性</p></blockquote><p>可以用hasattr()这个函数来判断</p><blockquote><p>hasattr(object, name)&#96; 函数是 Python 标准库中提供的一个内置函数，用于判断对象是否具有某个属性。它接受两个参数：</p><p>object：要判断的对象。</p><p>name：要判断的属性名。</p><p>  它返回一个布尔值，如果对象具有指定名称的属性返回 True，否则返回 False。</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">if hasattr(JueJin_Sign, &#39;message_juejin&#39;) and hasattr(UPVPS, &#39;message_up&#39;):    # do something else:    # do something<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="async用法"><a href="#async用法" class="headerlink" title="async用法"></a>async用法</h2><p>async是Python中用来实现异步编程的关键字。它可以让函数在执行时不会阻塞其他代码的执行。使用async关键字声明一个函数，并使用await调用另一个异步函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">async def main():    result &#x3D; await _async_function()    #等价于asyncio.run(my_async_func())    print(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用async定义函数时，需要在函数内部使用await运算符来调用另一个异步函数。</p><p>用sleep的话，你的bot在这3秒期间没法处理其他消息了</p><p>异步定时器可以在本程序执行的时候执行别的函数但是不能执行别的文件,应该是有一个跨线程或者实际进程的问题</p><p>我觉得另开一个进程或者线程防止阻塞应该也是可行的</p><p>nonebot的实现方式好像是在nonebot初始化的时候就挂载,具体还需继续研究</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>上位机调节pid</title>
      <link href="/2023/01/18/52h-shang-wei-ji-diao-jie-pid/"/>
      <url>/2023/01/18/52h-shang-wei-ji-diao-jie-pid/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言指针"><a href="#C语言指针" class="headerlink" title="C语言指针"></a>C语言指针</h1><p>1、指针变量存放的是地址类型。<br>2、定义指针变量的时候设定的变量类型，确定的是从指针存的首地址开始后面读取多少个字节。（int 为4个，char为1个），而指针变量的大小是固定的，大小看设备，一般是4个字节（32位）</p><h2 id="通过chatgpt"><a href="#通过chatgpt" class="headerlink" title="通过chatgpt"></a>通过chatgpt</h2><blockquote><p>为什么通过首地址可以访问整个变量,不是应该知道所有地址吗<br>通过首地址可以访问整个变量是因为首地址存储着整个变量的第一个字节。而在内存中，整个变量是连续存储的，因此通过首地址可以访问到整个变量。<br>比如一个int类型的变量，它占4个字节，分别存储在连续的4个位置上，如果我们知道它的首地址，那么就可以访问到它的第一个字节，并且知道了第一个字节的位置，那么就可以知道后面三个字节的位置。</p></blockquote><blockquote><p>所以通过首地址可以访问整个变量。<br>需要注意的是，在访问整个变量前需要知道这个变量的类型和占用的字节数，因为不同类型的变量占用的字节数是不同的。</p></blockquote><p>我知道了,因为int变量在32位系统中占四个字节,已知a有四个字节,&amp;a获取a的地址,即a的首地址,即一个字节,就可以继续找三个字节,即为a</p><blockquote><p>所以p1是a的首地址,<em>p1即为取出p1地址的值,即</em>p1为a的首地址的值<br>不对,p1是指针变量，它指向a的首地址，所以p1的值为a的首地址。而*p1是取出p1指向的地址的值，即a的值。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a &#x3D; 258;&#x2F;&#x2F;使用unsigned char来验证int的每一个字节unsigned char *p1 &#x3D; (unsigned char*)&amp;a;   &#x2F;&#x2F;获取a的首地址unsigned char *p2 &#x3D; (unsigned char*)&amp;a+1; &#x2F;&#x2F;获取a的首地址的后一个字节地址unsigned char *p3 &#x3D; (unsigned char*)&amp;a+2; &#x2F;&#x2F;获取a的首地址的后两个字节地址unsigned char *p4 &#x3D; (unsigned char*)&amp;a+3; &#x2F;&#x2F;获取a的首地址的后三个字节地址printf(&quot;[a] p1:%x, %d\r\n&quot;, p1, *p1); &#x2F;&#x2F;打印p1的地址与存储的字节内容printf(&quot;[a] p2:%x, %d\r\n&quot;, p2, *p2); &#x2F;&#x2F;打印p2的地址与存储的字节内容printf(&quot;[a] p3:%x, %d\r\n&quot;, p3, *p3); &#x2F;&#x2F;打印p3的地址与存储的字节内容printf(&quot;[a] p4:%x, %d\r\n&quot;, p4, *p4); &#x2F;&#x2F;打印p4的地址与存储的字节内容运行结果：[a] p1:5216f804, 2[a] p2:5216f805, 1[a] p3:5216f806, 0[a] p4:5216f807, 0这个就取出的是首地址的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于这段代码,<code>他将变量a的地址强制转换成了unsigned char类型的指针</code>,并用p1,p2,p3,p4分别指向了a的首地址和后1,2,3个字节的地址,通过p1,*p2,*p3,*p4获取到了这些地址所存储的值,这些值就是a在内存中的二进制表示,根据不同的机器字节序,会得到不同的结果。</p><blockquote><p>所以在上面代码中打印p1会获得a的首地址,打印*p1会获得a的首地址的值<br>是的，在上面的代码中，p1是a的首地址，而p1是存储在a的首地址的值。这段代码中，首先将int类型的a转换为unsigned char类型的指针p1，然后利用p1来访问a的每一个字节，p2、p3、p4分别是a的首地址后一个字节、后两个字节、后三个字节的地址。在打印p1、p2、p3、p4时，会输出这些地址的十六进制值，在打印p1、*p2、*p3、*p4时，会输出这些地址所存储的值。</p></blockquote><blockquote><p>就像是*p&#x3D;<em>a,即p&#x3D;a的值<br>对，这是对的。在这个代码中，p1是一个指向unsigned char类型的指针，它获取了变量a的首地址。在打印p1时，你会得到变量a的首地址。而当你打印</em>p1时，你会得到变量a在首地址上存储的值。</p></blockquote><blockquote><p>不对我说错了是<em>p&#x3D;</em>(&amp;a),即p&#x3D;a的首地址,*p&#x3D;a的值<br>对的，p&#x3D;(&amp;a)，即p&#x3D;&amp;a，即p是a的首地址，*p&#x3D;a的值。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">void printf_bin(int num)&#123;    int i, j, k;    unsigned char *p &#x3D; (unsigned char*)&amp;num + 3;&#x2F;&#x2F;p先指向num后面第3个字节的地址，即num的最高位字节地址    for (i &#x3D; 0; i &lt; 4; i++) &#x2F;&#x2F;依次处理4个字节(32位）    &#123;        j &#x3D; *(p - i); &#x2F;&#x2F;取每个字节的首地址，从高位字节到低位字节，即p p-1 p-2 p-3地址处        for (int k &#x3D; 7; k &gt;&#x3D; 0; k--) &#x2F;&#x2F;处理每个字节的8个位，注意字节内部的二进制数是按照人的习惯存储！        &#123;            if (j &amp; (1 &lt;&lt; k))&#x2F;&#x2F;1左移k位，与单前的字节内容j进行或运算，如k&#x3D;7时，00000000&amp;10000000&#x3D;0 -&gt;该字节的最高位为0                printf(&quot;1&quot;);            else                printf(&quot;0&quot;);        &#125;        printf(&quot; &quot;);&#x2F;&#x2F;每8位加个空格，方便查看    &#125;    printf(&quot;\r\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>所以1左移k位的意思就是生成一个第k位为1的八位二进制数<br>对的，1左移k位的意思就是生成一个第k位为1,其他位为0的二进制数。例如：1左移3位，就是0001000，第4位为1，其他位为0。在这段代码中，通过将1左移k位，再与j进行&amp;运算，就可以判断j的第k位是否为1，从而将整数num转换为二进制并输出。</p></blockquote><p>在这段代码中，1左移k位的操作是从低位到高位进行的，以便将每一位的值枚举出来。这样才能依次比较每一位与j的值是否相同，如果相同则输出1，否则输出0。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">对应unsigned char型的数字，如果只需要显示8位2进制数，可以对上述小程序简化：void printf_bin_8(unsigned char num)&#123;    int k;    unsigned char *p &#x3D; (unsigned char*)&amp;num;    for (int k &#x3D; 7; k &gt;&#x3D; 0; k--) &#x2F;&#x2F;处理8个位    &#123;        if (*p &amp; (1 &lt;&lt; k))            printf(&quot;1&quot;);        else            printf(&quot;0&quot;);    &#125;    printf(&quot;\r\n&quot;);&#125;&#x2F;&#x2F;数字12的运行效果00001100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为unsign  char只有一个字节</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;在64位系统中, unsigned char仍然是1个字节, 与32位系统中相同。 不过, 在64位系统中, int, long, long long等变量可能会比32位系统中多占用一些字节。 &#x2F;&#x2F;下面是一个在64位系统中将int转换为二进制的例子:void printf_bin_64(unsigned int num)&#123;int i, k;unsigned char p &#x3D; (unsigned char)&amp;num + 7;&#x2F;&#x2F;p先指向num后面第7个字节的地址，即num的最高位字节地址for (i &#x3D; 0; i &lt; 8; i++) &#x2F;&#x2F;依次处理8个字节(64位）&#123;    for (int k &#x3D; 7; k &gt;&#x3D; 0; k--) &#x2F;&#x2F;处理每个字节的8个位    &#123;        if (*(p - i) &amp; (1 &lt;&lt; k))            printf(&quot;1&quot;);        else            printf(&quot;0&quot;);    &#125;    printf(&quot; &quot;);&#x2F;&#x2F;每8位加个空格，方便查看&#125;printf(&quot;\r\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大佬观点</p><blockquote><p>编码器的单位用rpm<br>期望速度也用rpm<br>pid计算之后传回来的值是pwm pwm越大电压越高转速越快</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python文字转图片</title>
      <link href="/2023/01/15/51p-python-wen-zi-zhuan-tu-pian/"/>
      <url>/2023/01/15/51p-python-wen-zi-zhuan-tu-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="文字转图片"><a href="#文字转图片" class="headerlink" title="文字转图片"></a>文字转图片</h2><p>可以用pygame库或者pillow库</p><h3 id="pygame"><a href="#pygame" class="headerlink" title="pygame"></a>pygame</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pygame# 初始化pygamepygame.init()# 设置文字内容text &#x3D; &quot;Hello World!\nHow are you?&quot;# 设置字体和大小font &#x3D; pygame.font.Font(None, 36)# 使用render()函数将文字转换为图片text_image &#x3D; font.render(text, True, (255, 255, 255))# 使用save()函数将图片保存到文件pygame.image.save(text_image, &quot;text.png&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个代码只能转一行,不能进行换行</p><blockquote><p>想换行的话,将文本拆分,然后分别渲染成多个图片,最后进行图片的合并</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pygame# 初始化pygamepygame.init()# 设置文字内容text &#x3D; &quot;Hello World! How are you?&quot;# 设置字体和大小font &#x3D; pygame.font.Font(None, 36)# 设置行宽line_width &#x3D; 200# 分割文本lines &#x3D; []for line in text.split(&quot;\n&quot;):    lines.extend(textwrap.wrap(line, width&#x3D;line_width))# 创建一个空白图像image &#x3D; pygame.Surface((line_width, len(lines)*font.size(&quot;A&quot;)[1]),pygame.SRCALPHA)# 渲染每一行y &#x3D; 0for line in lines:    text_image &#x3D; font.render(line, True, (255, 255, 255))    image.blit(text_image, (0, y))    y +&#x3D; font.size(&quot;A&quot;)[1]# 保存图像pygame.image.save(image, &quot;text.png&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pillow库"><a href="#pillow库" class="headerlink" title="pillow库"></a>pillow库</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import osimport Image,ImageDraw,ImageFont,ImageFilterimport randomtext&#x3D;&quot;任何屁话，\n只要被打印出来\n就成了真理&quot;# PIL实现width&#x3D;60*4height&#x3D;60*2im&#x3D;Image.new(&#39;RGB&#39;,(width,height),(255,255,255))dr&#x3D;ImageDraw.Draw(im)font&#x3D;ImageFont.truetype(os.path.join(&quot;C:\\Windows\\Fonts\\&quot;, &quot;simhei.ttf&quot;),20)dr.text((10,5),text,font&#x3D;font,fill&#x3D;&#39;#000000&#39;) im.show()im.save(&quot;t.png&quot;)#在代码执行完后自动删除图片os.remove(&quot;text.png&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/01/15/51p-python-wen-zi-zhuan-tu-pian/01.jpg" class=""><p><code>因为bot是搭建在linux服务器上的,所以可能会出现下面问题</code></p><blockquote><p>im.save(“t.png”)运行后,没有图片生成</p><blockquote><p>原因是我直接默认保存在当前位置,当前目录没有写入权限，无法将文件保存到该目录。你可以在文件路径前加上&#x2F;tmp&#x2F; 或 &#x2F;home&#x2F;user&#x2F; 来保存文件。</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写nonebot2插件时遇见的问题</title>
      <link href="/2023/01/15/50p-nonebot-questions/"/>
      <url>/2023/01/15/50p-nonebot-questions/</url>
      
        <content type="html"><![CDATA[<h2 id="发送指令成功运行后无报错-但是没有发出消息"><a href="#发送指令成功运行后无报错-但是没有发出消息" class="headerlink" title="发送指令成功运行后无报错,但是没有发出消息"></a>发送指令成功运行后无报错,但是没有发出消息</h2><blockquote><p>消息太长,或者字数太多,无法发出,是qq的问题,可以选择文字转图片</p></blockquote><h2 id="文字转图片"><a href="#文字转图片" class="headerlink" title="文字转图片"></a>文字转图片</h2><p>可以用pygame库或者pillow库<br>可能出现的报错<br><code>已安装pilow但是编译出现ModuleNotFoundError:No module named &#39;pillow&#39;</code></p><blockquote><p>pillow是PIL（Python成像库）的一个分支，PIL不再被维护了。所以，为了保持向后兼容性，往往使用旧的模块名称——PIL。所以，直接import PIL就可以了。<br><a href=""></a></p></blockquote><h2 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h2><p>指令形式:&#x2F;b baidu.com<br>获取信息:baidu.com<br>strip() 方法默认去除字符串两端的空格和换行符</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t&#x3D;&quot;b baidu.com&quot;print(t.strip(&quot;b&quot;)) #这里会多出一个空格print(t.strip(&quot;b &quot;))#这样又会少一个bprint(t.replace(&quot;b &quot;,&quot;&quot;))t &#x3D; &quot;aaabbbaaa&quot;print(t.strip(&quot;a&quot;)) #去除两边的a#&gt;&gt;&gt;&quot;bbb&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>解决</code></p><blockquote><p>可以使用<code>replace(&quot;b&quot;,&quot;&quot;,1)</code>来只删除字符串中的第一个b<br><code>或者使用正则</code><br>import re<br>t &#x3D; “aaabbbaaa”<br>print(re.sub(“^a”,””,t)) #”aabbbaaa”</p></blockquote><blockquote><p>re.sub(pattern,repl,string,count&#x3D;0) 函数的作用是在字符串 string 中查找所有与正则表达式 pattern 匹配的子串，并将其替换为 repl。</p></blockquote><p>正则表达式<code>^a</code>, 匹配了字符串中以<code>&#39;a&#39;</code>开头的所有子串。<br>调用 re.sub() 方法，这个方法会返回一个新字符串，即将匹配到的第一个<code>&#39;a&#39;</code>删除后的字符串</p><h2 id="split-用法"><a href="#split-用法" class="headerlink" title="split()用法"></a>split()用法</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">s &#x3D; &quot;Hello, World!, wa&quot;print(s.split(&quot;,&quot;)) # [&#39;Hello&#39;, &#39; World!&#39;,&#39;wa&#39;]s &#x3D; &quot;Hello, World!, wa&quot;print(s.split(&quot;,&quot;, 1)) # [&#39;Hello&#39;, &#39; World!, wa&#39;]s &#x3D; &quot;Hello, World!, wa&quot;print(s.split()) # [&#39;Hello,&#39;, &#39;World!,&#39;,&#39; wa&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="chatgpt"><a href="#chatgpt" class="headerlink" title="chatgpt"></a>chatgpt</h2><p>利用chatgpt学习了很多东西,进不去的话可以用以下方法解决:</p><blockquote><p>ERROR CODE 1020简单解决方法<br>①先断开梯，进入登录页面，进行机器人验证然后输密码<br>②点击登录之前连梯，跳转之后提示1020错误<br>③断开梯子，刷新错误页面，愉快玩耍</p></blockquote><p><a href="https://chat.openai.com/chat/b63d3896-8183-4064-b1ea-79fbe15d429a">参考chatgpt</a></p>]]></content>
      
      
      <categories>
          
          <category> QQbot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nonebot2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>base64编码</title>
      <link href="/2023/01/12/49p-shi-me-shi-base64-bian-ma/"/>
      <url>/2023/01/12/49p-shi-me-shi-base64-bian-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><blockquote><p>Base64是一种用64个字符来表示任意二进制数据的方法.</p></blockquote><p>Base64可以将ASCII字符串或者是二进制编码成只包含A—Z，a—z，0—9，+，&#x2F;这64个字符(26个大写字母，26个小写字母，10个数字，1个+，一个&#x2F;刚好64个字符)。这64个字符用6个bit位就可以全部表示出来，一个字节有8个bit 位,剩下两个bit位用0来补充。其实，一个Base64字符仍然是8个bit位,但是有效部分只有右边的6个 bit，左边两个永远是0。Base64将3个字节转变为4个字节，因此，编码后的代码量（以字节为单位）约比编码前的代码量多了1&#x2F;3 (24,32,(32-24)&#x2F;24&#x3D;1&#x2F;3)</p><img src="/2023/01/12/49p-shi-me-shi-base64-bian-ma/01.png" class=""><p>首先对二进制数进行处理,每三个字节一组,一共是3x8&#x3D;24bit位,二进制数一组是8位,一个字节,将这24位数据重新分成四组,一组6bit.在每组前面加上两个0,变成8bit(<code>为什么要加上两个0,加不加不都是0-63吗,因为:定义的一个字节=8位,逻辑上可以分成六位,但是程序处理的时候按八位一个字节处理,所以不加两个0的话,相当于没转,无事发生</code>)<br>将获得的四个数字作为索引,查base64码表,获得对应的四个字符,就是编码后的字符串</p><p>若需要编码的二进制数据不是三的倍数,最后会剩下一两个字节,base64会用\x00补足后,加上等号,表示补了几位,解码的时候会自动去掉<br><a href="https://zhidao.baidu.com/question/936729407932485852.html">为什么在六位数据前面加两个零</a></p><h2 id="Base64码表"><a href="#Base64码表" class="headerlink" title="Base64码表"></a>Base64码表</h2><img src="/2023/01/12/49p-shi-me-shi-base64-bian-ma/ASCII%E7%A0%81%E8%A1%A8.png" class=""><h2 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a>ASCII码表</h2><img src="/2023/01/12/49p-shi-me-shi-base64-bian-ma/Base64%E7%A0%81%E8%A1%A8.png" class=""><h2 id="转换演示”AbC”"><a href="#转换演示”AbC”" class="headerlink" title="转换演示”AbC”"></a>转换演示”AbC”</h2><p>十进制:”Abc”:65,98,99<br>二进制:0100 0001,0110 0010, 0110 0011<br>Base64:0100 00,0101 10,0010 01,1000 11<br>补0变成八位:<code>00</code>0100 00,<code>00</code>0101 10,<code>00</code>0010 01,<code>00</code>1000 11<br>Base64:16,22,9,67  查Base64编码表获得<code>QWJj</code><br><a href="https://blog.csdn.net/JGYBZX_G/article/details/125636691">Base64编码步骤</a><br><a href="https://blog.csdn.net/doublepg13/article/details/128383734?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-128383734-blog-127026213.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-128383734-blog-127026213.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=5">Base64编码剖析</a><br><a href="https://www.cnblogs.com/libin-1/p/6165485.html">Base64编码原理分析</a></p><h2 id="Base64的应用"><a href="#Base64的应用" class="headerlink" title="Base64的应用"></a>Base64的应用</h2><p>因为Base64码是将二进制转换为可打印的字符,所以我们要先将ASCII码转变成二进制数据<br>我这里是调用api时传入的url需要用base64转换</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import base64print(base64.b64encode(b&#39;binary\x00string&#39;))print(base64.b64decode(&#39;YmluYXJ5AHN0cmluZw&#x3D;&#x3D;&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><code>&gt;&gt;&gt;</code>b’YmluYXJ5AHN0cmluZw&#x3D;&#x3D;’<br> <code>&gt;&gt;&gt;</code>b’binary\x00string’<br>这个b应该是用来区分base64编码和字符串吧，所以如果想单纯的使用base64编码需要把多余的字符去掉</p></blockquote><h3 id="decode为utf-8编码"><a href="#decode为utf-8编码" class="headerlink" title="decode为utf-8编码"></a>decode为utf-8编码</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">a&#x3D;&#39;AbC&#39;.encode()a &#x3D;a.decode(&#39;utf-8&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="str转化为utf-8编码"><a href="#str转化为utf-8编码" class="headerlink" title="str转化为utf-8编码"></a>str转化为utf-8编码</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">a&#x3D;&#39;AbC&#39;.encode()a &#x3D;str(a,&#39;utf-8&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="http://t.zoukankan.com/annatest-p-14758317.html">参考文章</a></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="字符型转换为字节型-str转换byte"><a href="#字符型转换为字节型-str转换byte" class="headerlink" title="字符型转换为字节型,str转换byte"></a>字符型转换为字节型,str转换byte</h3><blockquote><p>str.encode(“utf-8”)<br>b”str”</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">a&#x3D;b&quot;uuudiy.com&quot;a &#x3D; base64.b64encode(a)print(a)&gt;&#96;&gt;&gt;&gt;&#96;b&#39;dXV1ZGl5LmNvbQ&#x3D;&#x3D;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">a&#x3D;base64.b64decode(a)a &#x3D; str(a, &#39;utf-8&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><code>&gt;&gt;&gt;</code>dXV1ZGl5LmNvbQ&#x3D;&#x3D;</p></blockquote><p><a href="https://blog.csdn.net/lotus_2015/article/details/104637938?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-6-104637938-blog-126154421.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-6-104637938-blog-126154421.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=13">Base64和Base64URL加解密</a></p><h2 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h2><p>首先是<code>.encode()</code></p><p>将字符串转为二进制</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a&#x3D;&quot;uuudiy.com&quot;print(a.encode())&gt;&gt;&gt;b&#39;uuudiy.com&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>.decode()</code>将二进制数据转换为字符(按照指定的字符集（例如UTF-8）解码成字符串)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#b&#x3D;b.decode(&#39;utf-8&#39;) #b &#x3D; str(b,&#39;utf-8&#39;)print(b)&gt;&gt;&gt;uuudiy.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="base64库"><a href="#base64库" class="headerlink" title="base64库"></a>base64库</h3><p>base64是将<code>二进制数据</code>按照(base64字符集)转换为<code>字符串</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import base64a&#x3D;&quot;uuudiy.com&quot;print(base64.b64encode(a.encode()))&gt;&gt;&gt;b&#39;dXV1ZGl5LmNvbQ&#x3D;&#x3D;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回的结果是二进制数据所以要加<code>.decode()</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt;dXV1ZGl5LmNvbQ&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>requests库实现自动签到</title>
      <link href="/2022/12/02/48p-python-qian-dao-jiao-ben/"/>
      <url>/2022/12/02/48p-python-qian-dao-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h2 id="签到原理"><a href="#签到原理" class="headerlink" title="签到原理"></a>签到原理</h2><p>按下<code>签到</code>后,浏览器向会发送请求,所以我们只需要模拟浏览器,给对应的url发送请求就可以了</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>但是,签到之前一般要先登录,登录的原理是<code>提交表单</code>这部分内容参考&lt;&lt;python网络爬虫权威指南&gt;&gt;<br>大多数网页表单都是由一些 HTML 字段、一个提交按钮和一个进行表单处理的操作页面构<br>成的。虽然这些 HTML 字段通常由文字内容构成，但是也可以实现文件上传或包含其他非<br>文字内容。<br><a href="pythonscraping.com">书中提供的示例网站</a><br>构建了一组不同类型的表单和登录窗口，以便你用网络爬虫抓取。最简单的表单位于<br><a href="http://pythonscraping.com/pages/files/form.html%E3%80%82">http://pythonscraping.com/pages/files/form.html。</a><br>这个表单的源代码是：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;processing.php&quot;&gt;First name: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;firstname&quot;&gt;&lt;br&gt;Last name: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;lastname&quot;&gt;&lt;br&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot;&gt;&lt;&#x2F;form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>首先，两个输入字段的名称是 firstname 和 lastname，<br>这两个字段的名称决定了表单提交后要被 POST 到服务器上的可变参数的名称。<br>如果你想模拟表单提交数据的行为，就要保证你的变量名称与字段名称是一一对应的。<br>其次，表单的操作发生在 <code>processing.php</code>（绝对路径是<a href="http://pythonscraping.com/files/processing">http://pythonscraping.com/files/processing</a>.<br>php）。对表单的任何 POST 请求其实都发生在这个页面上，而非表单本身所在的页面。</p></blockquote><blockquote><p>切记：HTML 表单的目的，只是帮助网站的访问者将格式正确的请求发送到进行实际操作的</p></blockquote><p>用 Requests 库提交表单只需 4 行代码，包括导入库文件的语句和打印内容的指令</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsparams &#x3D; &#123;&#39;firstname&#39;: &#39;Ryan&#39;, &#39;lastname&#39;: &#39;Mitchell&#39;&#125;r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;pythonscraping.com&#x2F;pages&#x2F;processing.php&quot;, data&#x3D;params)print(r.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>表单被提交之后，程序应该会返回响应的内容：</p><blockquote><p>Hello there, Ryan Mitchell!<br>然后保存cooike,请求签到按钮对应的url</p></blockquote><h3 id="跟踪cookies的两个方法"><a href="#跟踪cookies的两个方法" class="headerlink" title="跟踪cookies的两个方法"></a>跟踪cookies的两个方法</h3><p>直接从请求结果中获得</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;pythonscraping.com&#x2F;pages&#x2F;processing.php&quot;, data&#x3D;params)print(&#39;Cookie is set to:&#39;)print(r.cookies.get_dict())print(&#39;Going to profile page...&#39;)r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;pythonscraping.com&#x2F;pages&#x2F;cookies&#x2F;profile.php&#39;,cookies&#x3D;r.cookies)#请求完成print(r.text)#打印一下返回的内容,看看是否签到成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过requests.Session()获得<br>会话（session）对象（通过调用 requests.Session() 获取）会持续跟踪会话信息，包括 cookie、header，甚至是 HTTP 协议的信息，比如 HTTPAdapter（为 HTTP和 HTTPS 的链接会话提供统一接口）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">session&#x3D;requests.Session()s &#x3D; session.post(&#39;http:&#x2F;&#x2F;pythonscraping.com&#x2F;pages&#x2F;cookies&#x2F;welcome.php&#39;, params)print(&#39;Cookie is set to:&#39;)print(s.cookies.get_dict())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>不管我怎么请求,都无法签到<br>后来发现签到请求的url也需要post提交表单</p><h3 id="MutableMapping-from-collections"><a href="#MutableMapping-from-collections" class="headerlink" title="MutableMapping from collections"></a>MutableMapping from collections</h3><p>ImportError: cannot import name <code>MutableMapping</code>（<code>Iterable</code>）from collections<br>网上查寻资料说是python版本过高（我是最新的3.10.1，需要版本降级)<br>详细报错</p><p>找到最后的py文件,将修改collections.替换为collections.abc.,就是在后面加个.abc<br>继续运行,如果继续报错,重复上述步骤<br><a href="https://ask.csdn.net/questions/7639233?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166994137416800213042846%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166994137416800213042846&biz_id=4&utm_medium=distribute.pc_search_result.none-task-ask_topic-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-7639233-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Econtrol_2,213%5Ev2%5Et3_esquery_v3&utm_term=Python%E5%85%B3%E4%BA%8EImportError:%20cannot%20import%20name%20%E2%80%98MutableMapping%E2%80%98%20%EF%BC%88%E6%88%96%E8%80%85%E2%80%98Iterable%E2%80%98%20%EF%BC%89from%20%E2%80%98collections%E2%80%98&spm=1018.2226.3001.4187">原因</a></p><blockquote><p>自 Python 3.10 開始，庫 collections 以下各項都停用了，其中就包含了 pygal._compat.py 中的 from collections import Iterator</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">[&quot;Awaitable&quot;, &quot;Coroutine&quot;, &quot;AsyncIterable&quot;, &quot;AsyncIterator&quot;, &quot;AsyncGenerator&quot;, &quot;Hashable&quot;,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="">为什么改成.abc就好用了</a><br><a href="https://blog.csdn.net/weixin_47251596/article/details/124198903">参考文章</a></p><h2 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h2><p>import os<br>os.environ[“http_proxy”] &#x3D; “<a href="http://127.0.0.1:1231/">http://127.0.0.1:1231</a>“<br>os.environ[“https_proxy”] &#x3D; “<a href="http://127.0.0.1:1231/">http://127.0.0.1:1231</a>“<br><a href="https://blog.csdn.net/whatday/article/details/112169945">参考文章</a><br>如果电脑开着代理,且没有加上面代码,会报错</p><h2 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h2><p>使用的是apscheduler,下面这三行代码就可以了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sched &#x3D; BlockingScheduler()sched.add_job(main, &#39;cron&#39;, hour&#x3D;10, minute&#x3D;55)sched.start()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://huaweicloud.csdn.net/63802ef2dacf622b8df86279.html?spm=1001.2101.3001.6650.11&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-11-102600181-blog-124737291.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-11-102600181-blog-124737291.pc_relevant_recovery_v2&utm_relevant_index=17#5_apscheduler__186?login=from_csdn">参考文章</a></p><h2 id="server酱通知"><a href="#server酱通知" class="headerlink" title="server酱通知"></a>server酱通知</h2><p>server酱API调用实例<br>最简单的调用方式，直接在浏览器中输入以下 URL：</p><blockquote><p><a href="https://sctapi.ftqq.com/SCT90898T5nukNVW9mMKCGjtQxCN6Xs3K.send?title=messagetitle">https://sctapi.ftqq.com/SCT90898T5nukNVW9mMKCGjtQxCN6Xs3K.send?title=messagetitle</a></p></blockquote><p>如果你要发送中文，记得要把参数编码，比如通过 urlencode 函数。这样发送只有标题，如果需要内容，可以这样：</p><blockquote><p><a href="https://sctapi.ftqq.com/SCT90898T5nukNVW9mMKCGjtQxCN6Xs3K.send?title=messagetitle&desp=messagecontent">https://sctapi.ftqq.com/SCT90898T5nukNVW9mMKCGjtQxCN6Xs3K.send?title=messagetitle&amp;desp=messagecontent</a></p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">def send_wechat(msg):    &quot;&quot;&quot;server酱推送&quot;&quot;&quot;    #token &#x3D; &#39; XXXXXXXXXXXXXXXXXX&#39; #前边复制到那个token    key&#x3D;&quot;SCT90898T5nukNVW9mMKCGjtQxCN6Xs3K&quot;    messagetitle &#x3D; &#39;标题&#39;    messagecontent &#x3D; 想要的内容    url &#x3D; f&quot;https:&#x2F;&#x2F;sctapi.ftqq.com&#x2F;&#123;key&#125;.send?title&#x3D;&#123;messagetitle&#125;&amp;desp&#x3D;&#123;messagecontent&#125;&quot;    #print(url)    r &#x3D; requests.get(url&#x3D;url)    #print(r.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="微信企业号通知"><a href="#微信企业号通知" class="headerlink" title="微信企业号通知"></a>微信企业号通知</h2><p>待完成…….</p><h2 id="部署到服务器上"><a href="#部署到服务器上" class="headerlink" title="部署到服务器上"></a>部署到服务器上</h2><p>screen挂后台</p><p><a href="https://blog.csdn.net/m0_46497373/article/details/119873630?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-119873630-blog-119858120.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-119873630-blog-119858120.pc_relevant_default&utm_relevant_index=4">整体代码参考</a></p><p><a href="https://www.cnblogs.com/chenyuting/p/9322791.html">sys.exit(main())</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电压比较器</title>
      <link href="/2022/11/21/47h-lm321mfx/"/>
      <url>/2022/11/21/47h-lm321mfx/</url>
      
        <content type="html"><![CDATA[<h2 id="电压比较器基本应用电路"><a href="#电压比较器基本应用电路" class="headerlink" title="电压比较器基本应用电路"></a>电压比较器基本应用电路</h2><h3 id="什么是电压比较器"><a href="#什么是电压比较器" class="headerlink" title="什么是电压比较器"></a>什么是电压比较器</h3><p>比较器是一个将模拟电压信号与基准电压相比较的电路,两个或多个输入电压相比,来确定他们的的大小关系,类似于增益不可调的运算放大器,如LM339电压比较器。两路输入为模拟信号,输出为0或1,当输入电压的差值增大或减小,且正负符号不变时,输出保持恒定</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>电压比较器是对两个模拟电压比较其大小(也有两个数字电压比较的，这里不介绍)，并判断出其中哪一个电压高，如图1所示，图1(a是比较器，它有两个输入端:同相输入端(“+”)及反相输入端(“”端)，有一个输出端Vout(输出电平信号)。另外有电源+及地这是个单电源比较器)，同相端输入电压VA，反相端输入VB。VA和VB的变化如图11b)示、在时间0<del>t1时，VA&gt;VB: 在t1 ~t2时，VB&gt;VA: 在t2</del>t3时VA&gt;VB。在这种情况下，Vout的输出如图11C)所示: VA&gt;VB时，Vout输出高电平(饱和输出)，VB&gt;VA时，Vout输出低电平，根据输出电平的高低便可知道哪个电压大</p><img src="/2022/11/21/47h-lm321mfx/03.jpg" class=""><p>同一比较器根据外围电路的不同可以实现多种电压比较功能，如单限比较器、滞回比较器、窗口比较器。</p><h3 id="单限比较器"><a href="#单限比较器" class="headerlink" title="单限比较器"></a>单限比较器</h3><p>单限比较器是最简单的电压比较电路，如图1a所示，Vref为固定参考电压，Vin为输入电压，Vout为输出电压。Vout随Vin的变化关系如图1b所示，红线代表输出电压。当Vin低于Vref时，输出引脚下拉到GND，输出低电平。当Vin高于Vref时，输出引脚悬空，相当于开路,由于有R1上拉电阻，所以Vout此时输出高电平。（我们为了方便显示原理，有时会将VCC、GND以及上拉电阻R1在图中省略掉，将输出VCC称为输出高电平VOH，将输出GND称为低电平VOL）</p><img src="/2022/11/21/47h-lm321mfx/01.jpg" class=""><img src="/2022/11/21/47h-lm321mfx/02.jpg" class=""><p><a href="https://mbb.eet-china.com/blog/3890995-407228.html">电压比较器基本应用电路</a><br><a href="http://www.jbeilai.net/jbeilai_Article_144303.html">电压比较器的工作原理及应用</a><br><a href="https://blog.csdn.net/qlexcel/article/details/79671016">运放的电压的比较器</a><br><a href="https://www.dianyuan.com/article/48225.html">比较器与运放</a><br><a href="%E8%BF%90%E6%94%BE%E8%87%AA%E9%94%81%E7%94%B5%E8%B7%AF">运放的自锁电路</a></p><h3 id="光敏电阻"><a href="#光敏电阻" class="headerlink" title="光敏电阻"></a>光敏电阻</h3><p>光敏电阻，是一种特殊的电阻，简称光电阻，又名光导管。黑暗中电阻可以达到几十K到几个M，而正常可视的光强下，概念模糊，不能确定，如果说是强光照射，阻值大概为几个欧姆到几百欧姆，它的电阻和光线的强弱有直接关系。<code>光强度增加，则电阻减小:光强度减小，则电阻增大</code>。这是由于光照产生的载流子都参与导电，在外加电易的作用下作漂移运动，电子奔向电源的正极，空穴奔向电源的负极，从而使光敏电阻器的阻值迅速下降</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运算放大器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PY数据可视化</title>
      <link href="/2022/11/11/46p-shu-ju-ke-shi-hua/"/>
      <url>/2022/11/11/46p-shu-ju-ke-shi-hua/</url>
      
        <content type="html"><![CDATA[<p><a href="https://gallery.pyecharts.org/">pyrchart的官方文档</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pyecharts import options as optsfrom pyecharts.charts import Mapfrom pyecharts.faker import Fakerf &#x3D; open(&#39;国内疫情数据.csv&#39;, mode&#x3D;&#39;a&#39;, encoding&#x3D;&#39;utf-8-sig&#39;, newline&#x3D;&#39;&#39;)csv_writer &#x3D; csv.writer(f)csv_read &#x3D; csv.reader(f)csv_writer.writerow([&quot;date&quot;,&quot;province&quot;, &quot;city&quot;, &quot;local_confirm_add&quot;, &quot;local_wzz_add&quot;])df &#x3D; pd.read_csv(&quot;国内疫情数据.csv&quot;) #读取csv文件city &#x3D; df[&#39;city&#39;].tolist()          #tolist()转成列表local_confirm_add &#x3D; df[&#39;local_confirm_add&#39;].tolist()  # 转成列表title &#x3D; str(date)c &#x3D; (    Map()    .add(&quot;商家A&quot;, [list(z) for z in zip(Faker.country, Faker.values())], &quot;world&quot;)    .set_series_opts(label_opts&#x3D;opts.LabelOpts(is_show&#x3D;False))    .set_global_opts(        title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;Map-世界地图&quot;),        visualmap_opts&#x3D;opts.VisualMapOpts(max_&#x3D;200),    )    .render(&quot;map_world.html&quot;))#不知道数据是什么可以打印出来看一下print(Faker.country)print(Faler.values())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫遇到的error</title>
      <link href="/2022/11/03/45p-pa-chong-bao-cuo/"/>
      <url>/2022/11/03/45p-pa-chong-bao-cuo/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="list-index-out-of-range"><a href="#list-index-out-of-range" class="headerlink" title="list index out of range"></a>list index out of range</h3><p>1.ist [index] index超出范围<br>2.list是空的,无元素</p><h3 id="only-concatenate-str-not-“NoneType“-to-str"><a href="#only-concatenate-str-not-“NoneType“-to-str" class="headerlink" title="only concatenate str (not “NoneType“) to str"></a>only concatenate str (not “NoneType“) to str</h3><blockquote><p>只能连接str(不是“空”)到str<br>在解析后过滤空值。</p></blockquote><h4 id="concatenate-str-not-“list”-to-str"><a href="#concatenate-str-not-“list”-to-str" class="headerlink" title="concatenate str (not “list”) to str"></a>concatenate str (not “list”) to str</h4><blockquote><p>类型错误:只能连接str(不是“列表”)到str<br>debug操作：str()类型转换</p></blockquote><h4 id="concatenate-str-not-“float”-to-str"><a href="#concatenate-str-not-“float”-to-str" class="headerlink" title="concatenate str (not “float”) to str"></a>concatenate str (not “float”) to str</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(&quot;时间是&quot;+t)改成print(:&quot;时间是&quot;+str(t))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="FileNotFoundError-Errno-2-No-such-file-or-directory"><a href="#FileNotFoundError-Errno-2-No-such-file-or-directory" class="headerlink" title="FileNotFoundError: [Errno 2] No such file or directory"></a>FileNotFoundError: [Errno 2] No such file or directory</h3><ul><li><p>出现原因：这里是由于Vscode中，python里的路径是相对与工作目录来进行定位的。所以在多级目录情况下，若不设置绝对路径，往往找不到相应的文件的。</p></li><li><p>解决办法：首先打开左下角的设置按钮，在方框中输入python dir，回车，找到python这一栏，打开，勾选上”Execute In File Dir”即可。或者在setting.json中输入：”python.terminal.executeInFileDir”: true也可以。<br><a href="https://blog.csdn.net/likepoems/article/details/123924280">原文链接</a></p></li></ul><h3 id="NoneType‘-object-has-no-attribute-’find-all‘"><a href="#NoneType‘-object-has-no-attribute-’find-all‘" class="headerlink" title="NoneType‘ object has no attribute ’find_all‘"></a>NoneType‘ object has no attribute ’find_all‘</h3><p>NoneType类型，它没有‘find_all’这个方法</p><blockquote><p>解决:尝试着先把它转换为’str’类型</p></blockquote><h3 id="NoneType‘-object-has-no-attribute-‘xxx‘"><a href="#NoneType‘-object-has-no-attribute-‘xxx‘" class="headerlink" title="NoneType‘ object has no attribute ‘xxx‘"></a>NoneType‘ object has no attribute ‘xxx‘</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">Nonetype类型NoneType类型只有一个值None，表示空值，它是特殊Python对象，与0、空字符串、空列表不同print(type(None))结果输出：&lt;class &#39;NoneType&#39;&gt;None在Python解释器启动时自动创建，解释器退出时销毁NoneType类型只有一个值None.None不支持任何运算也没有任何内建方法None和任何其他的数据类型比较永远返回FalseA &#x3D; &quot;&quot;B &#x3D; Noneif(A is not B):    print(&quot;空字符串和None不同&quot;)if(B is None):    print(&quot;变量B的值是None&quot;)结果输出：空字符串和None不同变量B的值是None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>报错原因:</p><blockquote><p>Nonetype类型只有一个None，反推也就是出现问题的语句中，含有了 None这个变量。而根据前面知道，None是没有任何内建方法的，从而也就没有了任何属性。<br>1.读取文件不成功<br>2.函数返回none<br><a href="https://blog.csdn.net/panbaoran913/article/details/124650015?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-124650015-blog-79908033.pc_relevant_3mothn_strategy_and_data_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3">参考恩张</a></p></blockquote><h3 id="requests-exceptions-ConnectionError-HTTPSConnectionPool-host-‘xxx’-port-443"><a href="#requests-exceptions-ConnectionError-HTTPSConnectionPool-host-‘xxx’-port-443" class="headerlink" title="requests.exceptions.ConnectionError: HTTPSConnectionPool(host&#x3D;‘xxx’, port&#x3D;443)"></a>requests.exceptions.ConnectionError: HTTPSConnectionPool(host&#x3D;‘xxx’, port&#x3D;443)</h3><p>个人觉得就是连接超时了,科学上网打开就正常了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">1.检查以下库有没有# 没有的话请依次安装pip install certifipip install cryptographypip install pyOpenSSL2.请在网页请求中加入：verify&#x3D;False这个的含义是： requests设置移除SSL认证response &#x3D; requests.get(url, headers&#x3D;headers,verify&#x3D;False)print(response)# 但是可能会出现 InsecureRequestWarning 警告，# 虽然不影响代码采集但是看着不舒服，可以加上下面两行：import urllib3urllib3.disable_warnings()3.访问频繁在代码中加入延迟 time.sleep(3)更换IP更换使用随机的UA网络问题，更换网络或者使用手机流量4.连接数过多如果requests连接数很多，那么在请求中避免使用持久连接可以加上headers &#x3D; &#123;&#39;Connection&#39;: &#39;close&#39;&#125;或者requests.adapters.DEFAULT_RETRIES &#x3D; 55.requests请求网页时可能会请求不到，重试加入try…except…语句try:response &#x3D; session.get(url, headers&#x3D;headers,verify&#x3D;False)except:response &#x3D; session.get(url, headers&#x3D;headers,verify&#x3D;False)print(response)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/weixin_45520735/article/details/115260374">参考文章</a></p><h3 id="InvalidHeader-Invalid-return-character-or-leading-space-in-header-user-agent"><a href="#InvalidHeader-Invalid-return-character-or-leading-space-in-header-user-agent" class="headerlink" title=".InvalidHeader: Invalid return character or leading space in header: user-agent"></a>.InvalidHeader: Invalid return character or leading space in header: user-agent</h3><p>请求头信息里面，不能有空格</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;user-agent&quot;:&quot; Mozilla&#x2F;5.0(  像这种,把空格去掉就好了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="InsecureRequestWarning-Unverified-HTTPS-request-is-being-made-Adding-certificate-verif"><a href="#InsecureRequestWarning-Unverified-HTTPS-request-is-being-made-Adding-certificate-verif" class="headerlink" title="InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verif"></a>InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verif</h3><p>在未启用证书验证的情况下向 HTTPS URL 发出请求时会发生这种情况</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">requests 库其实是基于 urllib 编写的，对 urllib 进行了封装，使得使用时候的体验好了很多，现在 urllib 已经出到了3版本，功能和性能自然是提升了不少。所以，requests最新版本也是基于最新的 urllib3 进行封装。在urllib2时代对https的处理非常简单，只需要在请求的时候加上 verify&#x3D;False 即可，这个参数的意思是忽略https安全证书的验证，也就是不验证证书的可靠性，直接请求，这其实是不安全的，因为证书可以伪造，不验证的话就不能保证数据的真实性。在urllib3时代，官方强制验证https的安全证书，如果没有通过是不能通过请求的，虽然添加忽略验证的参数，但是依然会 给出醒目的 Warning，这一点没毛病。已经有很多博主，给出解决方法，我试了一下，真的可以。这里详细熟说下，使用过程。首先找到你原来请求网页的连接，比如我的：蓝色的是网页请求连接，在前面一行添加代码就没有了安全警告。requests.packages.urllib3.disable_warnings()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="name-‘xxx’-is-not-defined"><a href="#name-‘xxx’-is-not-defined" class="headerlink" title="name ‘xxx’ is not defined"></a>name ‘xxx’ is not defined</h3><p>个人遇到的情况是:前面没定义,后面就直接用了<br><a href="https://www.cnblogs.com/zyh19980816/p/11844659.html">参考文章</a></p><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><h3 id="JSONDecodeError-Expecting-value-line-1-column-1-char-0"><a href="#JSONDecodeError-Expecting-value-line-1-column-1-char-0" class="headerlink" title=".JSONDecodeError: Expecting value: line 1 column 1 (char 0)"></a>.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</h3><p>1.报错的意思是，你获取的数据json数据不是字典形式，</p><p>解决：需要获取如下图所示的字典形式json数据，才能通过json.loads 解析成python的字典形式。</p><p>2.检查url是否正确</p><p>也可能是网站封锁了我的账号，可以正常访问，但不允许这个账号进行爬虫…<br><a href="https://stackoverflow.com/questions/16573332/jsondecodeerror-expecting-value-line-1-column-1-char-0">大佬们的回答</a><br>json 解码错误 你传的值不对<br>调用网络api时返回值不是json类型</p><h3 id="使用json-dump-与json-dumps-避免一行显示"><a href="#使用json-dump-与json-dumps-避免一行显示" class="headerlink" title="使用json.dump()与json.dumps()避免一行显示"></a>使用json.dump()与json.dumps()避免一行显示</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"># one line showdata1 &#x3D; json.dumps(data) # multi lines show as dict formatdata2 &#x3D; json.dumps(data, indent&#x3D;2)　# indent 表示缩进<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali虚拟机网络配置</title>
      <link href="/2022/10/14/44l-kali/"/>
      <url>/2022/10/14/44l-kali/</url>
      
        <content type="html"><![CDATA[<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="暂时改变ip"><a href="#暂时改变ip" class="headerlink" title="暂时改变ip"></a>暂时改变ip</h3><p>在root权限下执行</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">ifconfig                           #查看本机IP地址vim &#x2F;etc&#x2F;network&#x2F;interfaces        #修改网卡配置文件auto eth0iface eth0 inet dhcpifconfig eth0 192.168.31.119&#x2F;24    #配置临时iproute add default gw 192.168.31.1  #配置默认路由&#x2F;etc&#x2F;init.d&#x2F;networking restart     #重启网络服务 echo name server 8.8.8.8&gt; &#x2F;etc&#x2F;resolv.conf                                    #配置dns服务器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="永久改变ip"><a href="#永久改变ip" class="headerlink" title="永久改变ip"></a>永久改变ip</h3><p>vim &#x2F;etc&#x2F;network&#x2F;interfaces        #修改网卡配置文件</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">auto eth0iface eth0 inet staticaddress 192.168.31.119netmask 255.255.255.0gateway 192.168.31.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ssh连接虚拟机"><a href="#ssh连接虚拟机" class="headerlink" title="ssh连接虚拟机"></a>ssh连接虚拟机</h2><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">netstat -lnt                 &#x2F;&#x2F;查看开放是否开放22端口vim &#x2F;etc&#x2F;ssh&#x2F;sshd_configpermitrootlogin yespubkeyauthenticatation yes&#x2F;etc&#x2F;init.d&#x2F;ssh restartlsof -i :22                 &#x2F;&#x2F;查看22端口是否被监听&#x2F;etc&#x2F;init.d&#x2F;ssh status      &#x2F;&#x2F;查看ssh服务状态，running则表示已启动成功update-rc.d ssh enable      &#x2F;&#x2F;设置为自动启动ssh登录服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><p>如果ssh连接不上且<code>ping不通</code>的话,把虚拟机的<code>nat模式</code>换成<code>桥接模式</code><br>nat模式下不可以ssh，虚拟机可以上网<br>桥接模式下可以ssh，但是虚拟机不能上网！！</p><p>解决无法上网<br>vim &#x2F;etc&#x2F;resolv.conf</p><p>nameserver dns<br>nameserver 114.114.114.114</p><p>即可上网</p><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>deb <a href="https://mirrors.aliyun.com/kali">https://mirrors.aliyun.com/kali</a> kali-rolling main non-free contrib<br>deb-src <a href="https://mirrors.aliyun.com/kali">https://mirrors.aliyun.com/kali</a> kali-rolling main non-free contrib<br>apt update</p><blockquote><p>参考文章<br><a href="https://zhuanlan.zhihu.com/p/113141126">ssh连接kali虚拟机</a><br><a href="https://blog.csdn.net/woai_zhongguo/article/details/121373551">ssh登录kali</a><br><a href="https://blog.csdn.net/polimo/article/details/84080869">虚拟机网络连接模式</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HACKTHEBOX入门</title>
      <link href="/2022/10/05/43l-hackthebox/"/>
      <url>/2022/10/05/43l-hackthebox/</url>
      
        <content type="html"><![CDATA[<h2 id="开始练习"><a href="#开始练习" class="headerlink" title="开始练习"></a>开始练习</h2><blockquote><p>右上角-&gt;STARING POINT-&gt;OPENVON-&gt;DOWNLOAD<br>然后将文件上传到kali<br>使用root用户执行<br>openvpn 文件名<br>左边选择一个machine,生成机器,ping一下看看隧道是否建立成功</p></blockquote><h3 id="OpenVPN-简介"><a href="#OpenVPN-简介" class="headerlink" title="OpenVPN 简介"></a>OpenVPN 简介</h3><blockquote><p>VPN 直译就是虚拟专用通道，是提供给企业之间或者个人与公司之间安全数据传输的隧道，OpenVPN 无疑是 Linux 下开源 VPN 的先锋，提供了良好的性能和友好的用户 GUI。<br>虚拟私有网络（VPN）隧道是通过 Internet 隧道技术将两个不同地理位置的网络安全的连接起来的技术。<code>当两个网络是使用私有 IP 地址的私有局域网络</code>时，它们之间是不能相互访问的，这时使用<code>隧道技术</code>就可以使得<code>两个子网内的主机进行通讯</code>。例如，VPN 隧道技术经常被用于<code>大型机构</code>中<code>不同办公区域子网的连接</code>。有时，使用 VPN 隧道仅仅是因为它很安全。服务提供商与公司会使用这样一种方式架设网络，他们将重要的服务器（如，数据库，VoIP，银行服务器）放置到一个子网内，仅仅让有权限的用户通过 VPN 隧道进行访问。如果需要搭建一个安全的 VPN 隧道，通常会选用 IPSec，因为 IPSec VPN 隧道被多重安全层所保护。<br><a href="https://juejin.cn/post/6844903736012193800">OpenVPN 简介</a></p></blockquote><h2 id="Meow"><a href="#Meow" class="headerlink" title="Meow"></a>Meow</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">1.What does the acronym VM stand for?（VM是什么的缩写）virtual machine2.What tool do we use to interact with the operating system in order to start our vpn connection?(我们用什么工具与操作系统进行交互进而开启我们的vpn连接？)terminal3.What service do we use to form our vpn connection?（我们用什么服务形成我们vpn连接？）openvpn4.What is the abreviated name for a tunnel interface in the output of your vpn boot-up sequence output?（vpn启动后隧道接口的缩写名称是什么）tun5.What tool do we use to test our connection to the target?（我们用什么工具来测试与目标靶机的连接？）ping6.What is the name of the tool we use to scan the target&#39;s ports?（我们用什么工具来扫描目标靶机的端口？）nmap7.What service do we identify on port 23&#x2F;tcp during our scans?（在我们的扫描结果中tcp23端口被我们认定为是什么服务）telnet8.What username ultimately works with the remote management login prompt for the target?（哪个用户名最终可以成功远程登录到目标靶机？）root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="操作及命令"><a href="#操作及命令" class="headerlink" title="操作及命令"></a>操作及命令</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">nmap 10.129.151.144telnet 10.129.151.144 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Fawn"><a href="#Fawn" class="headerlink" title="Fawn"></a>Fawn</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">1.What does the 3-letter acronym FTP stand for?（FTP是什么的简称？）File Transfer Protocol2.What communication model does FTP use, architecturally speaking?（从架构上来说，FTP用的是什么通信模型？）client-server model3.What is the name of one popular GUI FTP program?（最受欢迎的FTP图形化软件的名字是什么？）FileZilla4.Which port is the FTP service active on usually?（通常情况下，FTP活跃在哪个端口？）21 tcp5.What acronym is used for the secure version of FTP?（安全版本的FTP的简称是什么？）sftp视频中提出的问题答案：FTP：明文传输，通过Wireshark可以抓包看到命令及文件传输的内容SFTP：加密传输，ssh内嵌的协议，默认情况下只要启动了sshd服务，sftp服务就会在22端口工作。FTPS：加密传输，类似于HTTPS。（更多详细的信息可以通过度娘来查询）6.What is the command we can use to test our connection to the target?（我们可以用什么工具测试我们与目标主机的连通性？）ping7.From your scans, what version is FTP running on the target?（从你扫描的结果来看，目标靶机上运行的是哪个版本的FTP？）&gt;nmap -sV ip 查看8.From your scans, what OS type is running on the target?（从你的扫描结果来看，目标主机的操作系统类型是什么？）&gt;nmap -sV ip 查看<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="操作及命令-1"><a href="#操作及命令-1" class="headerlink" title="操作及命令"></a>操作及命令</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">nmap -sV 10.129.165.160ftp 10.129.165.160anonymousftp&gt;  lsftp&gt; get flag.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Dancing"><a href="#Dancing" class="headerlink" title="Dancing"></a>Dancing</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">1.What does the 3-letter acronym SMB stand for?（SMB是什么的简称？）Server Message Block2.What port does SMB use to operate at?（用什么端口去操作SMB?）4453.What network communication model does SMB use, architecturally speaking?（从架构上讲，SMB属于哪种通信模型？）client-server model4.What is the service name for port 445 that came up in our nmap scan?（从扫描结果来看，445端口的服务名称是什么？）microsoft-ds5.What is the tool we use to connect to SMB shares from our Linux distribution?（在Linux发行版中，我们用什么工具去连接SMB服务的分享？）smbclient6.What is the &#96;flag&#96; or &#96;switch&#96; we can use with the SMB tool to &#96;list&#96; the contents of the share?（我们可以用SMB工具哪个“标识”或者“开关”来列举出分享的文件？）-L7.What is the name of the share we are able to access in the end?（最终我们可以访问的分享名称是什么？）WorkShares8.What is the command we can use within the SMB shell to download the files we find?（在SMB Shell下，我们用什么命令来下载我们找到的文件？）get<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="操作及命令-2"><a href="#操作及命令-2" class="headerlink" title="操作及命令"></a>操作及命令</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">nmap -sV -v 10.129.219.244smbclient -L 10.129.219.244smbclient &#x2F;&#x2F;10.129.219.244&#x2F;WorkSharessmb&gt; lssmb&gt; get flag.txt <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h2><p>Nmap是一款开源免费的网络发现（Network Discovery）和安全审计（Security Auditing）工具。软件名字Nmap是Network Mapper的简称。Nmap最初是由Fyodor在1997年开始创建的。随后在开源社区众多的志愿者参与下，该工具逐渐成为最为流行安全必备工具之一。</p><p>一般情况下，Nmap用于列举网络主机清单、管理服务升级调度、监控主机或服务运行状况。Nmap可以检测目标机是否在线、端口开放情况、侦测运行的服务类型及版本信息、侦测操作系统与设备类型等信息。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">经典单个主机IP&#x2F;域名普通扫描：nmap     IP   可以得到service的port状态,以及端口号nmap -sV IP    能够得到服务版本信息 nmap -sC IP    sC参数，能够得到更加详细的服务信息nmap -sS -sV -T4 ip -sS:使用TCP SYN扫描-sV:进行版本探测T0-T5 表示扫描速度，数字越大速度越快使用TCP协议：1.半扫描，迅速且隐蔽nmap -sS 目标IP2.全扫描，完成3次握手nmap -sT 目标IP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/Gjqhs/article/details/121957155">Namp在kali中的常见命令</a></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><blockquote><p>redis 是一个开源的、使用 C 语言编写的 NoSQL 数据库<br>redis 基于内存运行并支持持久化（支持存储在磁盘），采用 key-value（键值对）的存储形式，是目前分布式架构中不可或缺的一环<br>redis 服务器程序是单进程模型</p></blockquote><h3 id="redis-cli命令行工具"><a href="#redis-cli命令行工具" class="headerlink" title="redis-cli命令行工具"></a>redis-cli命令行工具</h3><p>redis-cli 常用于登陆至redis 数据库<br>redis-cli -h host -p port -a password<br>-h 指定远程主机<br>-p 指定 redis 服务的端口号<br>-a 指定密码，未设置数据库密码可以省略 -a 选项<br>若不添加任何选项表示，则使用 127.0.0.1:6379 连接本机上的 redis 数据库</p><p>注:<br>执行该条命令是可能会出现<code>Command &#39;redis-cli&#39; not found</code></p><blockquote><p>apt-get update </p></blockquote><p>执行后可能会出现</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">E: 无法下载 https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali&#x2F;pool&#x2F;main&#x2F;r&#x2F;redis&#x2F;redis-tools_6.0.16-2_amd64.deb  404  Not Found [IP: 119.188.121.248 443]E: 有几个软件包无法下载，要不运行 apt-get update 或者加上 --fix-missing 的选项再试试？<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行以下命令</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">wget -q -O - https:&#x2F;&#x2F;archive.kali.org&#x2F;archive-key.asc | apt-key addapt-key adv --keyserver hkp:&#x2F;&#x2F;keys.gnupg.net --recv-keys 7D8D0BF6用了这两条命令更新了签名问题就解决了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>没解决看原文章,我是apt-get update就可以了<br><a href="https://blog.csdn.net/MENGYOU____/article/details/115091631">关于kali源的问题</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">redis-server: 用于启动Redis 的工具redis-benchmark: 用于检测Redis在本机的运行效率redis-check-aof: 修复AOF持久化文件redis-check-rdb: 修复RDB持久化文件redis-cli: Redis 命令行工具.rdb 和aof 是redis服务中持久化功能的两种形式RDB AOF <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">1、远程连接redis：redis-cli -h ip -p port   （无账号密码登录）2、查看redis相关信息：info（该命令可以查看redis的版本信息、多少个key等）3、查看key所存储的数据类型：type key4、获取key所存储的内容：get key5、obtain all the keys in a database: keys *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://copyfuture.com/blogs-details/202207130551151366#1%E3%80%81Redis%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7">redis命令工具</a></p><h2 id="Redeemer"><a href="#Redeemer" class="headerlink" title="Redeemer"></a>Redeemer</h2><pre class=" language-language-c"><code class="language-language-c">1.Q : Which TCP port is open on the machine? A : nmap IP -> 63792.Q : Which service is running on the port that is open on the machine? A : nmap IP -> redis2.Q : What type of database is Redis? Choose from the following options: (i) In-memory Database, (ii) Traditional Database A : (i) In-memory Database4.Q : Which command-line utility is used to interact with the Redis server? Enter the program name you would enter into the terminal without any arguments. A : redis-cli5.Q : Which flag is used with the Redis command-line utility to specify the hostname? A : -h6.Q : Once connected to a Redis server, which command is used to obtain the information and statistics about the Redis server? A : info7.Q : What is the version of the Redis server being used on the target machine? A : nmap -sV IP -> 5.0.78.Q : Which command is used to select the desired database in Redis? A : select9.Q : How many keys are present inside the database with index 0? A : info -> 410.Q : Which command is used to obtain all the keys in a database? A : keys *11.Q : Submit root flag A : redis-cli -h IP -p 6379    keys *    get flag </code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HACKTHEBOX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPIO功能</title>
      <link href="/2022/09/29/42h-f407-gpio/"/>
      <url>/2022/09/29/42h-f407-gpio/</url>
      
        <content type="html"><![CDATA[<h2 id="GPIO的功能"><a href="#GPIO的功能" class="headerlink" title="GPIO的功能"></a>GPIO的功能</h2><blockquote><p>复用功能<br>STM32Fxx内部集成了很多的外设控制器，比如USART、SPI、bxCAN等等，这些外设控制器，也需要通过引脚与外设连接。复用功能是相对于单片机的引脚而言的。所谓“复用功能”，是指单片机的引脚既可以做普通GPIO使用，也可以作为内部外设控制器的引脚来使用。</p></blockquote><p><a href="https://blog.csdn.net/weixin_45378136/article/details/123038151">stm32单片机的引脚复用功能</a><br><a href="https://blog.csdn.net/k666499436/article/details/123845466">STM32入门-GPIO端口的八种工作模式(超级详细)</a><br><a href="https://blog.csdn.net/Savage888777/article/details/125469496">四种输入和四种输出模式</a></p><h2 id="推挽输出"><a href="#推挽输出" class="headerlink" title="推挽输出"></a>推挽输出</h2><p>● 施密特触发输入被激活<br>● 弱上拉和下拉电阻被禁止<br>● <code>出现在I/O脚上的数据在每个APB2时钟被采样到输入数据寄存器</code><br>● 在开漏模式时，对输入数据寄存器的读访问可得到I&#x2F;O状态<br>● 在推挽式模式时，对输出数据寄存器的读访问得到最后一次写的值</p><p>在输出模式中，推挽模式时双 MOS 管以轮流方式工作，输出数据寄存器 GPIOx_ODR可控制 I&#x2F;O 输出高低电平。开漏模式时，只有 N-MOS 管工作，输出数据寄存器可控制 I&#x2F;O输出高阻态或低电平。<br><a href="https://blog.csdn.net/baidu_19356259/article/details/80921524?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-80921524-blog-120311499.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-80921524-blog-120311499.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=2">mos管的基本认识</a></p><h3 id="MOS管的开关条件"><a href="#MOS管的开关条件" class="headerlink" title="MOS管的开关条件"></a>MOS管的开关条件</h3><p>N-MOS 管：高电平 导通<br>P-MOS 管： 低电平 导通<br>N沟道—导通时 Ug&gt; Us,Ugs&gt; Ugs(th)时导通<br>P沟道—导通时 Ug&lt; Us,Ugs&lt; Ugs(th)时导通<br>总之，导通条件：|Ugs|&gt;|Ugs(th)|</p><h2 id="开漏输出"><a href="#开漏输出" class="headerlink" title="开漏输出"></a>开漏输出</h2><h2 id="复用功能推挽开漏输出"><a href="#复用功能推挽开漏输出" class="headerlink" title="复用功能推挽开漏输出"></a>复用功能推挽开漏输出</h2><p>复用功能模式中，输出使能，输出速度可配置，可工作在开漏及推挽模式， 但是输出信号源于其它外设<br>输出数据寄存器 GPIOx_ODR 无效；输入可用，通过输入数据寄存器可获取 I&#x2F;O 实际状态，但一般直接用外设的寄存器来获取该数据信号<br>这里以串口的发送TX和接收RX引脚为例</p><p><code>复用功能的推挽与开漏输出与普通的推挽与开漏输出只是输出的寄存器换成外设的寄存器</code><br>复用推挽输出和（普通）推挽输出在输出的时候均使用两个MOS管（P-MOS和-MOS），其输出电路是相同的。<br>区别在于控制输出的信号来源：<br>（普通）推挽输出控制MOS管的信号来自 输出数据寄存器。<br>复用推挽输出的控制信号来自单片机的 内置外设控制器（比如SPI1）。</p><h2 id="为什么F407的usart-rx和usart-tx都是推挽复用输出"><a href="#为什么F407的usart-rx和usart-tx都是推挽复用输出" class="headerlink" title="为什么F407的usart_rx和usart_tx都是推挽复用输出"></a>为什么F407的usart_rx和usart_tx都是推挽复用输出</h2><p>网上大佬的理解:</p><blockquote><p>在STM32F103的串口配置例程中一般把RX设置成了浮空输入模式，而在STM32F407的串口配置模式中却把RX配置成了推挽输出的模式，RX是接收端，为什么不是输入模式，但是这样设置却可以正常使用,浮空输入时，呈高阻态，施密特触发器起作用，读取输入结果时，只有0或1两种，RX设置为浮空输入可以加强抵御外部阻抗变化的对内部的干扰，RX在推挽模式下，虽然是在输出状态，但是这种状态通过对输出数据寄存器的读访问可以得到最后一次写的值，也就是说可以得到RX引脚上的电压</p></blockquote><p>😃我的理解:</p><p>✔如图,推挽输出和开漏输出的特点是<code>出现在I/O脚上的数据在每个APB2时钟被采样到输入数据寄存器</code>所以即便是输出模式,也可以监测到usart_rx引脚的电平变化,是0还是1.</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32F407 </tag>
            
            <tag> GPIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USART串口通信</title>
      <link href="/2022/09/28/41h-f407-usart/"/>
      <url>/2022/09/28/41h-f407-usart/</url>
      
        <content type="html"><![CDATA[<h2 id="数据通信方式"><a href="#数据通信方式" class="headerlink" title="数据通信方式"></a>数据通信方式</h2><h3 id="串行与并行通信"><a href="#串行与并行通信" class="headerlink" title="串行与并行通信"></a>串行与并行通信</h3><blockquote><p>按数据传送的方式，通讯可分为串行通讯与并行通讯。</p></blockquote><ul><li>串行通讯：是指设备之间通过一根数据信号线，地线以及控制信号线，按数据位形式一位一位地传输数据的通讯方式，同一时刻只能传输一位(bit)数据。<br>并行通讯：是指使用 8、16、32 及 64 根或更多的数据线(有多少信号为就需要多少信号位)进行传输的通讯方式，可以同一时刻传输多个数据位的数据</li></ul><img src="/2022/09/28/41h-f407-usart/01.jpg" class=""><ul><li><p>全双工、半双工及单工通讯<br>单工通信：信息只能单方向传输的工作方式，一个固定为发送设备，另一个固定为接收设备，发送端只能发送信息不能接收信息，接收端只能接收信息不能发送信息，只需一根信号线</p></li><li><p>半双工通信：可以实现双向的通信，但不能在两个方向上同时进行，必须轮流交替进行，其实也可以理解成一种可以切换方向的单工通信，同一时刻必须只能一个方向传输，只需一根数据线</p></li><li><p>全双工通信：在同一时刻，两个设备之间可以同时收发数据，全双工方式无需进行方向的切换，这种方式要求通讯双方均有发送器和接收器，同时，需要2根数据线。</p></li></ul><img src="/2022/09/28/41h-f407-usart/02.jpg" class=""><h3 id="同步通讯与异步通讯"><a href="#同步通讯与异步通讯" class="headerlink" title="同步通讯与异步通讯"></a>同步通讯与异步通讯</h3><ul><li>同步通讯：收发设备双方会使用一根信号线表示时钟信号，在时钟信号的驱动下双方进行协调，同步数据，通讯中通常双方会统一规定在时钟信号的上升沿或下降沿对数据线进行采样，对应时钟极性与时钟相位。<br>I2C 的同步通信：</li></ul><img src="/2022/09/28/41h-f407-usart/03.jpg" class=""><p>异步通讯：不需要时钟信号进行数据同步，它们直接在数据信号中穿插一些同步用的信号位，或者把主体数据进行打包，以数据帧（串口：起始位 数据 校验位(可以没有) 停止位）的格式传输数据，某些通讯中还需要双方约定数据的传输速率（波特率），以便更好地同步。</p><img src="/2022/09/28/41h-f407-usart/04.jpg" class=""><h2 id="串口通讯协议"><a href="#串口通讯协议" class="headerlink" title="串口通讯协议"></a>串口通讯协议</h2><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><h4 id="1-RS232标准"><a href="#1-RS232标准" class="headerlink" title="(1)RS232标准"></a>(1)RS232标准</h4><p>很多单片机内部例如我们所用的STM32，以及一些传感器一般都是TTL电平。<br>RS232是一种串行数据传输形式，称其为串行连接，最经典的标志就是 9 针孔的 DB9 电缆RS232电压表示逻辑 1 ，0的范围大极大的增强了容错率，主要用于工业设备直接通信。</p><img src="/2022/09/28/41h-f407-usart/05.jpg" class=""><p>由上图可知，TLL与RS-232标准逻辑相反，而且电平也大不相同，若单片机与单片机或其他设备TLL设备通信采用RS-232通信（DB9）,肯定先要进行电平的转化TLL-&gt;RS232 RS232-&gt;TTL</p><img src="/2022/09/28/41h-f407-usart/06.jpg" class=""><p>两个通讯设备的“DB9 接口”之间通过串口信号线建立起连接，串口信号线中使用“RS-232 标准”传输数据信号。由于 RS-232 电平标准的信号不能直接被控制器直接识别，所以这些信号会经过一个“电平转换芯片”转换成控制器能识别的“TTL 标准”的电平信号，才能实现通讯。<br>电平转换芯片一般有max3232,sp3232</p><h4 id="USB转串口"><a href="#USB转串口" class="headerlink" title="USB转串口"></a>USB转串口</h4><p>主要用于单片机与电脑通信</p><img src="/2022/09/28/41h-f407-usart/07.jpg" class=""><p>电平转换芯片一般有CH340、PL2303、CP2102、FT232</p><img src="/2022/09/28/41h-f407-usart/08.jpg" class=""><h4 id="原生的串口到串口"><a href="#原生的串口到串口" class="headerlink" title="原生的串口到串口"></a>原生的串口到串口</h4><img src="/2022/09/28/41h-f407-usart/09.jpg" class=""><p>原生的串口通信主要是控制器跟串口的设备或者传感器通信他们但是TLL电平，不需要经过电平转换芯片来转换电平，直接就用TTL电平通信，GPS模块、GSM模块、串口转WIFI模块、HC04蓝牙模块</p><h3 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h3><img src="/2022/09/28/41h-f407-usart/04.jpg" class=""><h3 id="1）通讯的起始和停止信号"><a href="#1）通讯的起始和停止信号" class="headerlink" title="1）通讯的起始和停止信号"></a>1）通讯的起始和停止信号</h3><p>串口通讯的一个数据包从起始信号开始，直到停止信号结束。数据包的起始信号由一个逻辑 0 的数据位表示，而数据包的停止信号可由 0.5、1、1.5 或 2 个逻辑 1 的数据位表示</p><p>1个停止位：停止位位数的默认值。<br>2个停止位：可用于常规USART模式、单线模式以及调制解调器模式。<br>0.5个停止位：在智能卡模式下接收数据时使用。<br>1.5个停止位：在智能卡模式下发送和接收数据时使用。</p><h3 id="2-有效数据"><a href="#2-有效数据" class="headerlink" title="2)有效数据"></a>2)有效数据</h3><p>在数据包的起始位之后紧接着的就是要传输的主体数据内容，也称为有效数据，有效数据的长度常被约定为 5、6、7 或 8 位长</p><h3 id="3-数据校验"><a href="#3-数据校验" class="headerlink" title="3)数据校验"></a>3)数据校验</h3><p>偶校验：校验位使得一帧中的7或8个LSB数据以及校验位中’1’的个数为偶数。<br>例如：数据&#x3D;00110101，有4个’1’，如果选择偶校验(在USART_CR1中的PS＝0)，校验位将是’0’，最后数据检验如果数据有偶数个1则数据传输没有出错(但不是绝对的，如果同时两个数据为发送错误(0变成1)则还是偶数个1)</p><img src="/2022/09/28/41h-f407-usart/10.jpg" class=""><p>奇校验：此校验位使得一帧中的7或8个LSB数据以及校验位中’1’的个数为奇数。<br>例如：数据&#x3D;00110101，有4个’1’，如果选择奇校验(在USART_CR1中的PS＝1)，校验位将是’1’，最后数据检验如果数据有奇数个1则数据传输没有出错，但同样不是绝对的(同时两个1变成0)</p><img src="/2022/09/28/41h-f407-usart/11.jpg" class=""><h3 id="控制寄存器-USART-CR1"><a href="#控制寄存器-USART-CR1" class="headerlink" title="控制寄存器(USART_CR1)"></a>控制寄存器(USART_CR1)</h3><img src="/2022/09/28/41h-f407-usart/12.jpg" class=""><p>传输模式：如果USART_CR1的PCE位被置位，如果奇偶校验失败USART_SR寄存器中的PE标志被置’1’，并且如果USART_CR1寄存器的PEIE在被预先设置的话，中断产生(我们可以在相应的中断服务函数中，写处理校验失败的代码)</p><h3 id="状态寄存器-USART-CR1"><a href="#状态寄存器-USART-CR1" class="headerlink" title="状态寄存器(USART_CR1)"></a>状态寄存器(USART_CR1)</h3><img src="/2022/09/28/41h-f407-usart/13.jpg" class=""><img src="/2022/09/28/41h-f407-usart/14.jpg" class=""><h2 id="🔥USART功能框图"><a href="#🔥USART功能框图" class="headerlink" title="🔥USART功能框图"></a>🔥USART功能框图</h2><img src="/2022/09/28/41h-f407-usart/15.jpg" class=""><h3 id="功能引脚"><a href="#功能引脚" class="headerlink" title="功能引脚"></a>功能引脚</h3><img src="/2022/09/28/41h-f407-usart/16.jpg" class=""><h3 id="数据寄存器（重点）"><a href="#数据寄存器（重点）" class="headerlink" title="数据寄存器（重点）"></a>数据寄存器（重点）</h3><img src="/2022/09/28/41h-f407-usart/17.jpg" class=""><img src="/2022/09/28/41h-f407-usart/18.jpg" class=""><img src="/2022/09/28/41h-f407-usart/19.jpg" class=""><img src="/2022/09/28/41h-f407-usart/20.jpg" class=""><h3 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a>控制单元</h3><ul><li>发送器</li></ul><p>发送器根据M位的状态发送8位或9位的数据字。当发送使能位(TE)被设置时，发送移位寄存器中的数据在TX脚上输出，相应的时钟脉冲在CK脚上输出。</p><p>一个字符帧发送需要三个部分：起始位+数据帧（可能有校验位）+停止位。<code>每个字符(一个数据帧)之前都有一个低电平的起始位，之后跟着的停止位</code>，其数目可配置,数据帧就是我们要发送的 8 位或 9 位数据，<code>数据是从最低位开始传输的</code>,停止位是一定时间周期的高电平。</p><p>配置步骤：</p><img src="/2022/09/28/41h-f407-usart/21.jpg" class=""><img src="/2022/09/28/41h-f407-usart/22.jpg" class=""><img src="/2022/09/28/41h-f407-usart/23.jpg" class=""><img src="/2022/09/28/41h-f407-usart/24.jpg" class=""><img src="/2022/09/28/41h-f407-usart/25.jpg" class=""><p><code>实际上就是把十进制的小数转化成十六进制</code></p><img src="/2022/09/28/41h-f407-usart/32.jpg" class=""><blockquote><p>波特率计算方法<br>首先时钟来源，fPCLK1或fPCLK2<br>然后除以USARTDIV<br>再除以8*（2-OVER8）<br>OVER8是可以改变的，可以为1或0（在CR1寄存器15位设置）<br>故波特率 &#x3D; F&#x2F;（（8*（2-OVER8））*USARTDIV）<br>如果你要快，就设置OVER8为1，8倍过样率，但是容错差<br>如果你要精准，就OVER8设置为0，16倍过样率，但是慢<br>我们如何控制波特率，当我们确认好我们的波特率，时钟信号也确定了，就需要控制USARTDIV大小<br>USARTDIV的值如何决定<br>由USART_BRR决定<br>当OVER8为0时，小数比方编码为4位，并通过USART_BRR寄存器中的DIV_fraction[3:0]位编程<br>当OVER8为1时，小数比方编码为3位，并通过USART_BRR寄存器中的DIV_fraction[2:0]位编程，这DIV_fraction[3]必须保持清0<br>USART_BRR寄存器如上图<br>32位使用了低16位，分为2部分，有高12位和低4位<br>高12位：整数<br>低4位：小数</p></blockquote><blockquote><p>OVER8&#x3D;0时候波特率计算</p></blockquote><img src="/2022/09/28/41h-f407-usart/33.png" class=""><p><a href="https://blog.csdn.net/qq_54674051/article/details/126858320?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32%E4%B8%B2%E5%8F%A3%E6%B3%A2%E7%89%B9%E7%8E%87%E5%A6%82%E4%BD%95%E8%80%8C%E8%AE%A1%E7%AE%97&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-8-126858320.142%5Ev51%5Econtrol,201%5Ev3%5Econtrol_1&spm=1018.2226.3001.4187">STM32串口工作原理</a></p><blockquote><p>小知识:<br>波特率就是每秒传输的bit的位数<br>计算机最小的单位是bit,位,也叫比特位<br>byte是字节,也就是B<br>一字节(B)&#x3D;8位(bit)<br>位只有两种形式,0和1,只能表示两种状态,而字节有八个位,有256个状态<br>1GB&#x3D;1024MB<br>1MB&#x3D;1024KB<br>1KB&#x3D;1024B<br>1B&#x3D;8bit</p></blockquote><p>设置USART_CR1中的TE位，发送一个空闲帧帧(<code>一个数据帧长度的高电平</code>)作为第一次数据发送。</p><img src="/2022/09/28/41h-f407-usart/26.jpg" class=""><h3 id="深入理解TXE位与TC位："><a href="#深入理解TXE位与TC位：" class="headerlink" title="深入理解TXE位与TC位："></a>深入理解TXE位与TC位：</h3><p>清零TXE位总是通过对数据寄存器的写操作(CPU 或 DMA)来完成的，当TXE位已经被硬件置1它表明：</p><p>● 数据已经从TDR移送到移位寄存器，数据发送已经开始(发送移位寄存器正在一位一位向外传输数据)</p><p>● TDR寄存器被清空</p><p>● 下一个数据可以被写进USART_DR寄存器而不会覆盖先前的数据如果TXEIE位被设置，此标志将产生一个中断。</p><p>如果此时USART正在发送数据(发送移位寄存器正在一位一位向外传输数据)，对USART_DR寄存器的写操作把数据存进TDR寄存器，并在当前传输结束时把该数据复制进移位寄存器，也就是说移位寄存器里面的数据并不会被覆盖，所以我觉得只要你发送一帧数据等待TXE置1，就算是发送多帧数据时最后也不用等待TC&#x3D;1。</p><p>如果此时USART没有在发送数据，处于空闲状态，对USART_DR寄存器的写操作直接把数据放进移位寄存器，数据传输开始，TXE位立即被置起。</p><p>当一帧发送完成时(停止位发送后)并且设置了TXE位，TC位被置起，如果USART_CR1寄存器中的TCIE位被置起时，则会产生中断</p><p>使用下列软件过程清除TC位：<br>1．读一次USART_SR寄存器；<br>2．写一次USART_DR寄存器。<br>TC位也可以通过软件对它写’0’来清除。此清零方式只推荐在多缓冲器通信模式下使用</p><p>接收器<br>如果将 USART_CR1 寄存器的 RE 位置 1，使能 USART 接收，使得接收器在 RX 线开始搜索起始位。在确定到起始位后就根据 RX 线电平状态把数据存放在接收移位寄存器内。接收完成后就把接收移位寄存器数据移到 RDR 内，并把 USART_SR 寄存器的 RXNE 位置1，同时如果 USART_CR2 寄存器的 RXNEIE 置 1 的话可以产生中断。</p><p>当一字符被接收到时，<br>● RXNE位被置1。它表明移位寄存器的内容被转移到RDR。换句话说，数据已经被接收并且可以被读出。</p><p>● 如果RXNEIE位被设置，产生中断。</p><p>● 在多缓冲器通信时，RXNE在每个字节接收后被置起，并由DMA对数据寄存器的读操作而清零。</p><p>● 在单缓冲器模式里，由软件读USART_DR寄存器完成对RXNE位清除,RXNE标志也可以通过对它写0来清除。RXNE位必须在下一字符接收结束前(接收移位寄存器接收满)被清零(要将数据读出)，以避免溢出错误(移位寄存器的数据会被覆盖)。</p><p>溢出错误<br>如果RXNE还没有被复位（还没有读出DR寄存器的数据），又接收到一个字符，则发生溢出错误,数据只有当RXNE位被清零后才能从移位寄存器转移到RDR寄存器。RXNE标记是接收到每个字节后被置位的。如果下一个数据已被收到或先前DMA请求还没被服务时，RXNE标志仍是1，溢出错误产生。</p><p>当溢出错误产生时：<br>● ORE位被置位。<br>● RDR内容将不会丢失。读USART_DR寄存器仍能得到先前的数据。<br>● 移位寄存器中以前的内容将被覆盖。随后接收到的数据都将丢失。</p><p>● 如果RXNEIE位被设置或EIE和DMAR位都被设置，中断产生。</p><p>● 顺序执行对USART_SR和USART_DR寄存器的读操作，可复位ORE位</p><img src="/2022/09/28/41h-f407-usart/27.jpg" class=""><img src="/2022/09/28/41h-f407-usart/28.jpg" class=""><h3 id="USART和UART的区别"><a href="#USART和UART的区别" class="headerlink" title="USART和UART的区别"></a>USART和UART的区别</h3><p>UART：universal asynchronous receiver and transmitter通用异步收&#x2F;发器(裁剪掉了同步通信功能（时钟同步）)<br>USART:universal synchronous asynchronous receiver and transmitter通用同步&#x2F;异步收&#x2F;发器<br>大家能看出来USART和UART相比较，可以实现同步，就是说USART相对UART的区别之一就是能提供主动时钟。</p><blockquote><p>串行通信一般是以帧格式传输数据，即是一帧一帧的传输，每帧包含有起始信号、数据信息、校验信息(由我们自己设置)、停止信号。</p></blockquote><h3 id="串口相关寄存器"><a href="#串口相关寄存器" class="headerlink" title="串口相关寄存器"></a>串口相关寄存器</h3><blockquote><p>USART_SR　状态寄存器<br>USART_DR　数据寄存器<br>USART_BRR　波特率寄存器<br>USART_CR1　控制寄存器</p></blockquote><h3 id="封装函数"><a href="#封装函数" class="headerlink" title="封装函数"></a>封装函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 获取状态标志位FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);&#x2F;&#x2F; 清除状态标志位void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);&#x2F;&#x2F; 获取中断状态标志位ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);&#x2F;&#x2F; 清除中断状态标志位void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);&#x2F;&#x2F; 发送数据到串口(通过写USART_DR寄存器发送数据)void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);&#x2F;&#x2F; 接收数据（从USART_DR寄存器读取接收到的数据）uint16_t USART_ReceiveData(USART_TypeDef* USARTx);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="USART初始化结构体"><a href="#USART初始化结构体" class="headerlink" title="USART初始化结构体"></a>USART初始化结构体</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct&#123;  uint32_t USART_BaudRate;            uint16_t USART_WordLength;          uint16_t USART_StopBits;            uint16_t USART_Parity;               uint16_t USART_Mode;               uint16_t USART_HardwareFlowControl;                                         &#125; USART_InitTypeDef;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/09/28/41h-f407-usart/28.jpg" class=""><ol><li><p>USART_BaudRate：波特率设置。一般设置为9600、115200。标准库函数会自己计算计算得到 USARTDIV 值，从而写入USART_BRR 寄存器。</p></li><li><p>USART_WordLength：数据帧字长，可选 8 位或 9 位。它设置了USART_CR1 寄存器的 M 位的值。如果没有使能奇偶校验位，一般使用 8 数据位；如果使能了奇偶校验则一般设置为 9 数据位，最后一位是奇偶校验位。</p></li><li><p>USART_StopBits：停止位设置，可选 0.5 个、1 个、1.5 个和 2 个停止位，它设定USART_CR2 STOP位，一般我们选择 1 个停止位。</p></li><li><p>USART_Parity ： 奇 偶 校 验 控 制 选 择 ，USART_CR1 寄存器的 PCE 位和 PS 位的值。</p></li><li><p>USART_Mode：USART 模式选择，有 USART_Mode_Rx 和 USART_Mode_Tx，允许使用逻辑或运算选择两个,USART_CR1 寄存器的 RE 位和 TE 位。</p></li><li><p>USART_HardwareFlowControl：硬件流控制选择，只有在硬件流控制模式才有效，可选有⑴使能 RTS、⑵使能 CTS、⑶同时使能 RTS 和 CTS、⑷不使能硬件流。</p></li></ol><h3 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">1) 使能 RX 和 TX 引脚 GPIO 时钟和 USART 时钟；2) 初始化 GPIO，并将 GPIO 复用到 USART 上；3) 配置 USART 参数初始化结构体；4) 配置中断控制器并使能 USART 接收中断；5) 使能 USART；6) 在 USART 接收中断服务函数实现数据接收和发送<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="串口收发代码"><a href="#串口收发代码" class="headerlink" title="串口收发代码"></a>串口收发代码</h3><p><code>usart.h</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#ifndef _USART_H#define _USART_H#include &quot;stm32f10x.h&quot;#include &lt;stdio.h&gt;#define   DEBUG_USART1    1#define   DEBUG_USART2    0#if  DEBUG_USART1 &#x2F;&#x2F; 串口1-USART1#define  DEBUG_USARTx                   USART1#define  DEBUG_USART_CLK                RCC_APB2Periph_USART1#define  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd#define  DEBUG_USART_BAUDRATE           115200&#x2F;&#x2F; USART GPIO 引脚宏定义#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd    #define  DEBUG_USART_TX_GPIO_PORT       GPIOA   #define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9#define  DEBUG_USART_RX_GPIO_PORT       GPIOA#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10#define  DEBUG_USART_IRQ                USART1_IRQn#define  DEBUG_USART_IRQHandler         USART1_IRQHandler#elif   DEBUG_USART2 &#x2F;&#x2F; 串口2-USART2#define  DEBUG_USARTx                   USART2#define  DEBUG_USART_CLK                RCC_APB1Periph_USART2#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd#define  DEBUG_USART_BAUDRATE           115200&#x2F;&#x2F; USART GPIO 引脚宏定义#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd    #define  DEBUG_USART_TX_GPIO_PORT       GPIOA   #define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_2#define  DEBUG_USART_RX_GPIO_PORT       GPIOA#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_3#define  DEBUG_USART_IRQ                USART2_IRQn#define  DEBUG_USART_IRQHandler         USART2_IRQHandler#endifvoid USART_Config(void);void Usart_SendByte( USART_TypeDef * pUSARTx, uint8_t date);void Usart_SendString( USART_TypeDef * pUSARTx, char *str);void Usart_SendHalfWord( USART_TypeDef * pUSARTx, uint16_t date);void Usart_SendArray(USART_TypeDef * pUSARTx,uint8_t *arr,uint16_t num);#endif &#x2F;* _USART_H *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>usart.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;usart.h&quot;#include &quot;led.h&quot;static void NVIC_Configuration(void)&#123;NVIC_InitTypeDef  NVIC_InitStructure;NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);NVIC_InitStructure.NVIC_IRQChannel &#x3D;DEBUG_USART_IRQ;NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority &#x3D;0x01;NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D;0x01;NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D;ENABLE;NVIC_Init(&amp;NVIC_InitStructure);&#125;void USART_Config(void)&#123; GPIO_InitTypeDef GPIO_InitStructure;USART_InitTypeDef USART_InitStructure;&#x2F;&#x2F; 打开串口GPIO的时钟DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);&#x2F;&#x2F; 打开串口外设的时钟DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);&#x2F;&#x2F; 将USART Tx的GPIO配置为推挽复用模式GPIO_InitStructure.GPIO_Pin &#x3D; DEBUG_USART_TX_GPIO_PIN;GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF_PP;GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_50MHz;GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &amp;GPIO_InitStructure);  &#x2F;&#x2F; 将USART Rx的GPIO配置为浮空输入模式GPIO_InitStructure.GPIO_Pin &#x3D; DEBUG_USART_RX_GPIO_PIN;GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_IN_FLOATING;GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &amp;GPIO_InitStructure);&#x2F;&#x2F; 配置串口的工作参数&#x2F;&#x2F; 配置波特率USART_InitStructure.USART_BaudRate &#x3D; DEBUG_USART_BAUDRATE;&#x2F;&#x2F; 配置 针数据字长USART_InitStructure.USART_WordLength &#x3D; USART_WordLength_8b;&#x2F;&#x2F; 配置停止位USART_InitStructure.USART_StopBits &#x3D; USART_StopBits_1;&#x2F;&#x2F; 配置校验位USART_InitStructure.USART_Parity &#x3D; USART_Parity_No ;&#x2F;&#x2F; 配置硬件流控制USART_InitStructure.USART_HardwareFlowControl &#x3D; USART_HardwareFlowControl_None;&#x2F;&#x2F; 配置工作模式，收发一起USART_InitStructure.USART_Mode &#x3D; USART_Mode_Rx | USART_Mode_Tx;&#x2F;&#x2F; 完成串口的初始化配置USART_Init(DEBUG_USARTx, &amp;USART_InitStructure);&#x2F;&#x2F;中断配置NVIC_Configuration();&#x2F;&#x2F;开启串口接收中断USART_ITConfig(DEBUG_USARTx,USART_IT_RXNE, ENABLE);&#x2F;&#x2F;使能串口USART_Cmd(DEBUG_USARTx, ENABLE);&#125;&#x2F;&#x2F;发送一个字节void Usart_SendByte(USART_TypeDef * pUSARTx,uint8_t date)&#123; USART_SendData(pUSARTx,date); while( USART_GetFlagStatus(pUSARTx,USART_FLAG_TXE)&#x3D;&#x3D; RESET);&#125;&#x2F;&#x2F;发送一个16位的数据void Usart_SendHalfWord(USART_TypeDef * pUSARTx,uint16_t date)&#123;uint16_t tmp_h;uint16_t tmp_l;tmp_h &#x3D;date&gt;&gt;0x08;tmp_l &#x3D;date &amp; 0xff;Usart_SendByte(pUSARTx,tmp_h);Usart_SendByte(pUSARTx,tmp_l);&#125;&#x2F;&#x2F;发送一个8位的数组void Usart_SendArray(USART_TypeDef * pUSARTx,uint8_t *arr,uint16_t num)&#123;    while(num--) &#123; Usart_SendByte( pUSARTx ,*arr++); &#125; while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TC)&#x3D;&#x3D; RESET);&#125;&#x2F;&#x2F;发送字符串void Usart_SendString( USART_TypeDef * pUSARTx, char *str)&#123; while( *str!&#x3D;&#39;\0&#39; ) &#123; Usart_SendByte( pUSARTx, *str++);  &#125; while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TC)&#x3D;&#x3D; RESET);&#125;&#x2F;&#x2F;&#x2F;重定向c库函数printf到串口，重定向后可使用printf函数int fputc(int ch, FILE *f)&#123;&#x2F;* 发送一个字节数据到串口 *&#x2F;USART_SendData(DEBUG_USARTx, (uint8_t) ch);&#x2F;* 等待发送完毕 *&#x2F;while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) &#x3D;&#x3D; RESET);return (ch);&#125;&#x2F;&#x2F;&#x2F;重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数int fgetc(FILE *f)&#123;&#x2F;* 等待串口输入数据 *&#x2F;while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) &#x3D;&#x3D; RESET);return (int)USART_ReceiveData(DEBUG_USARTx);&#125;&#x2F;&#x2F;中断服务函数void DEBUG_USART_IRQHandler(void)&#123;     uint16_t tmp;if(USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) !&#x3D; RESET)&#123;  tmp&#x3D;USART_ReceiveData(DEBUG_USARTx); USART_SendData(DEBUG_USARTx,tmp);while( USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE)&#x3D;&#x3D; RESET);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;stm32f10x.h&quot;#include &quot;led.h&quot;#include  &quot;usart.h&quot;#include  &lt;string.h&gt;#define SOFT_DELAY Delay(0x0FFFFF);void Delay(__IO u32 nCount); int main(void)&#123; uint16_t ch; uint8_t arr[10]&#x3D;&#123;1,2,3,4,5,6,7,8,9,10&#125;;&#x2F;* LED 端口初始化 *&#x2F;LED_GPIO_Config();  &#x2F;*初始化USART 配置模式为 115200 8-N-1，中断接收*&#x2F;  USART_Config();   &#x2F;&#x2F;发送一个字符 printf(&quot;发送一个字节：\r\n&quot;);   Usart_SendByte(DEBUG_USARTx ,97); printf(&quot;\r\n&quot;);    &#x2F;&#x2F;发送一个16位数据 Usart_SendHalfWord(DEBUG_USARTx,0xffee); &#x2F;&#x2F;发送一个数组 Usart_SendArray(DEBUG_USARTx, arr,10); &#x2F;&#x2F;发送一个字符串 printf(&quot;发送一个字符串：\r\n&quot;); Usart_SendString( DEBUG_USARTx, &quot;hello world\r\n&quot;);  while(1);&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h2><img src="/2022/09/28/41h-f407-usart/30.jpg" class=""><img src="/2022/09/28/41h-f407-usart/31.jpg" class=""><p><a href="https://blog.csdn.net/k666499436/article/details/124354165?spm=1001.2014.3001.5502">一位大佬写的STM32串口通信详解</a><br><a href="https://www.dandelioncloud.cn/article/details/1531874206224773122">stm32 USART_IT_IDLE中断 一帧数据</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32F407 </tag>
            
            <tag> USART </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>肖特基二极管</title>
      <link href="/2022/09/27/40h-sbd-diode/"/>
      <url>/2022/09/27/40h-sbd-diode/</url>
      
        <content type="html"><![CDATA[<h2 id="肖特基二极管"><a href="#肖特基二极管" class="headerlink" title="肖特基二极管"></a>肖特基二极管</h2><p>肖特基（Schottky）二极管，又称肖特基势垒二极管（简称 SBD），它属一种低功耗、超高速半导体器件。最显著的特点为反向恢复时间极短（可以小到几纳秒），<code>正向导通压降仅0.4V左右</code>。<code>其多用作高频、低压、大电流整流二极管、续流二极管、保护二极管，也有用在微波通信等电路中作整流二极管、小信号检波二极管使用</code>。</p><p>SBD不是通过使用在P型半导体和N型半导体之间形成PN结的原理来制造的，而是通过使用通过金属和半导体之间的接触形成的金属-半导体结的原理来制造的。因此，SBD也被称为金属-半导体（接触）二极管或表面势垒二极管，它是热载流子二极管。</p><p>　　肖特基二极管的最大特点是正向压降VF比较小。在同样电流的情况下，它的正向压降要小许多。另外它的恢复时间短。<br>    缺点是：耐压比较低，漏电流稍大些。选用时要全面考虑。</p><p><strong>左负右正</strong></p><img src="/2022/09/27/40h-sbd-diode/1749193291789.png" class="" width="1749193291789"><h3 id="肖特基二极管在电路中作用"><a href="#肖特基二极管在电路中作用" class="headerlink" title="肖特基二极管在电路中作用"></a>肖特基二极管在电路中作用</h3><blockquote><p>肖特基二极管在电路中最常见的作用就是辅助电路的运行。<code>整流、续流、保护</code>.<br>　　一般情况下，肖特基二极管的特性是<code>导通压降低，反向恢复极快</code>，这一个特点就让肖特基二极管在电路中特殊起来。在肖特基二极管电路里的电压，两个电压当信号处理，这就证明有一个电压进行负载，离肖特基二极管较远的那个电压如果较低的话，电压给截止。这就是充电回路的工作原理<br><a href="https://m.elecfans.com/article/809909.html">参考文章1</a><br><a href="https://baike.baidu.com/item/%E8%82%96%E7%89%B9%E5%9F%BA%E4%BA%8C%E6%9E%81%E7%AE%A1/3217901?fr=aladdin">参考文章2</a></p></blockquote><h1 id="1N4007与B5819W"><a href="#1N4007与B5819W" class="headerlink" title="1N4007与B5819W"></a>1N4007与B5819W</h1><h2 id="二、主要电气参数对比"><a href="#二、主要电气参数对比" class="headerlink" title="二、主要电气参数对比"></a>二、主要电气参数对比</h2><table><thead><tr><th>参数</th><th>1N4007</th><th>B5819W (肖特基)</th><th>说明</th></tr></thead><tbody><tr><td>最大重复反向电压 VRRM</td><td>1000 V</td><td>40 V</td><td>1N4007适合高压整流，B5819W适合低压高频应用</td></tr><tr><td>平均整流正向电流 IF(AV)</td><td>1 A</td><td>1 A</td><td>两者额定电流相同，但使用场景不同</td></tr><tr><td>峰值正向浪涌电流 IFSM</td><td>30 A (8.3 ms 单半波)</td><td>25 A (8.3 ms 单波)</td><td>都支持几十安的浪涌，但1N4007稍高<a href="https://www.mouser.com/datasheet/2/149/1N4007-888322.pdf?srsltid=AfmBOoq8j_y0LO_I3F_SVPh3cULQA53CVHa-jxRnH4Ojw3A5PDxrgo_F&utm_source=chatgpt.com">mouser.com</a><a href="https://semiware.com/news/wp-content/uploads/2024/11/B5819W-schottky-diode-datasheet-1.pdf?utm_source=chatgpt.com">semiware.com</a></td></tr><tr><td>正向压降 VF</td><td>~1.1 V (@ IF&#x3D;1 A)</td><td>0.60 V (max) (@ IF&#x3D;1 A)</td><td>B5819W正向压降显著低于1N4007，损耗更小<a href="https://www.mouser.com/datasheet/2/149/1N4007-888322.pdf?srsltid=AfmBOoq8j_y0LO_I3F_SVPh3cULQA53CVHa-jxRnH4Ojw3A5PDxrgo_F&utm_source=chatgpt.com">mouser.com</a>[smc-diodes.com](<a href="https://www.smc-diodes.com/propdf/B5817W-B5819W">https://www.smc-diodes.com/propdf/B5817W-B5819W</a> N1752 REV.-.pdf?utm_source&#x3D;chatgpt.com)</td></tr><tr><td>反向漏电流 IR</td><td>典型5 μA (@ VR&#x3D;1000 V, Ta&#x3D;25 °C)</td><td>最大1 mA (@ VR&#x3D;40 V, Ta&#x3D;25 °C)</td><td>肖特基漏电比普通硅整流高几个数量级<a href="https://www.mouser.com/datasheet/2/149/1N4007-888322.pdf?srsltid=AfmBOoq8j_y0LO_I3F_SVPh3cULQA53CVHa-jxRnH4Ojw3A5PDxrgo_F&utm_source=chatgpt.com">mouser.com</a>[smc-diodes.com](<a href="https://www.smc-diodes.com/propdf/B5817W-B5819W">https://www.smc-diodes.com/propdf/B5817W-B5819W</a> N1752 REV.-.pdf?utm_source&#x3D;chatgpt.com)</td></tr><tr><td>典型结电容 CT</td><td>15 pF (@ VR&#x3D;4 V, f&#x3D;1 MHz, Ta&#x3D;25 °C)</td><td>120 pF (@ VR&#x3D;4 V, f&#x3D;1 MHz, Ta&#x3D;25 °C)</td><td>肖特基结电容较大，不利于超高频应用，但对一般开关足够<a href="https://www.mouser.com/datasheet/2/149/1N4007-888322.pdf?srsltid=AfmBOoq8j_y0LO_I3F_SVPh3cULQA53CVHa-jxRnH4Ojw3A5PDxrgo_F&utm_source=chatgpt.com">mouser.com</a>[smc-diodes.com](<a href="https://www.smc-diodes.com/propdf/B5817W-B5819W">https://www.smc-diodes.com/propdf/B5817W-B5819W</a> N1752 REV.-.pdf?utm_source&#x3D;chatgpt.com)</td></tr><tr><td>典型反向恢复时间 Trr</td><td>~30 μs （慢恢复类型）</td><td>极短，几乎无反向恢复时间</td><td>1N4007为慢恢复二极管，B5819W为肖特基，反向恢复极快</td></tr><tr><td>结温范围 Tj</td><td>–55 ℃ ～ +175 ℃</td><td>–50 ℃ ～ +125 ℃</td><td>1N4007允许更高结温，但B5819W为表贴，实际散热受限</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>若项目需要<strong>高电压（可达1000 V）</strong>、<strong>低成本插件式整流</strong>、或工作在<strong>低频环境</strong>，且对正向损耗没有苛刻要求，1N4007为首选；</li><li>若需求是<strong>40 V以内的低压整流</strong>、<strong>高频快速切换</strong>、注重<strong>低正向压降和高速恢复</strong>，并且采用<strong>SMT贴片工艺</strong>，则B5819W更合适。</li></ul><p>也就是<code>1N4007</code>能承受的反向电压更高,<strong>B5819W</strong>开关更快</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>F407串口DMA收发数据</title>
      <link href="/2022/09/23/39h-usart-dma/"/>
      <url>/2022/09/23/39h-usart-dma/</url>
      
        <content type="html"><![CDATA[<h2 id="📕DMA-是什么？"><a href="#📕DMA-是什么？" class="headerlink" title="📕DMA 是什么？"></a>📕DMA 是什么？</h2><p>全称 Direct Memory Access，即直接存储器访问。<br>作用:给 CPU 解放出来，让 CPU 不用去管数据的传输，只管数据的处理。<br>正常情况下，数据如果想要传输，得由 CPU 先读取目标数据，再传向目标地址。有了 DMA 后，传输的事就是 DMA 做的了，CPU 只要初始化 DMA 就可以了。<br>STM32F4 最多有 2 个 DMA 控制器，2 个 DMA 控制器总共有 16 个数据流（每个控制器 8 个），8 个数据流中每一个都连接到专用硬件 DMA 通道（请求）。每个 DMA 控制器都用于管理一个或者多个外设的存储器访问请求。每个数据流总共可以有多达 8 个通道（或请求）（理论上一共就是 16x8&#x3D;128 个通道，实际上每个通道都固定了对应的映射，所以并没有 128 个），每个通道都有一个仲裁器，用于处理 DMA 请求间的优先级。</p><p>注：每个数据流只能同时接一个通道！</p><img src="/2022/09/23/39h-usart-dma/01.png" class=""><p>DMA 传输，由源地址-&gt;目标地址，源地址和目标地址都可以是外设、存储器的地址。</p><p>特别的，当<code>存储器</code>到<code>存储器</code>时候，<code>仅限于DMA2</code>控制器；一般没有外设到外设。</p><p>可设置独立的源和目标传输宽度（字节（8 位）、半字（16 位）、字（32 位））：源和目标的数据宽度不相等时，DMA 自动封装&#x2F;解封必要的传输数据来优化带宽。这个特性仅在 FIFO 模式下可用。如：A 设置 8 位传输出去，B 设置 32 位接收，FIFO 会等 A 传出 4 次，共 32 位数据，然后封装成 B 的一次“字”的接收。</p><img src="/2022/09/23/39h-usart-dma/02.png" class=""><p>DMA1 控制器 AHB 外设端口与 DMA2 控制器的情况不同，不连接到总线矩阵，因此，仅 DMA2 数据流能够执行存储器到<br>存储器的传输</p><img src="/2022/09/23/39h-usart-dma/03.png" class=""><img src="/2022/09/23/39h-usart-dma/04.png" class=""><p>流配置过程</p><img src="/2022/09/23/39h-usart-dma/05.jpg" class=""><img src="/2022/09/23/39h-usart-dma/06.jpg" class=""><h3 id="常用的-DMA-库函数"><a href="#常用的-DMA-库函数" class="headerlink" title="常用的 DMA 库函数"></a>常用的 DMA 库函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct);void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter);uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx);void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,uint32_t DMA_CurrentMemory);void DMA_DoubleBufferModeCmd();void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx,uint32_t MemoryBaseAddr, uint32_t DMA_MemoryTarget);uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx);FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx);uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx);FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState);ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/sinat_42513925/article/details/81481467">DMA 库函数功能</a></p><h3 id="外设-DMA-使能库函数"><a href="#外设-DMA-使能库函数" class="headerlink" title="外设 DMA 使能库函数"></a>外设 DMA 使能库函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq,FunctionalState NewState);void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState);void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState);void SDIO_DMACmd(FunctionalState NewState);void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq,FunctionalState NewState);void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase,uint16_t TIM_DMABurstLength)void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource,FunctionalState NewState);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DMA-Init"><a href="#DMA-Init" class="headerlink" title="DMA_Init();"></a>DMA_Init();</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct);typedef struct&#123;  uint32_t DMA_Channel;                &#x2F;&#x2F;DMA_Channel_0~ DMA_Channel_7  uint32_t DMA_PeripheralBaseAddr;     &#x2F;&#x2F;设置 DMA 传输的外设基地址，比如要进行串口DMA 传输，那么外设基地址为                                       &#x2F;&#x2F;串口接受发送数据存储器 USART1-&gt;DR 的地址，表示方法为&amp;USART1-&gt;DR  uint32_t DMA_Memory0BaseAddr;        &#x2F;&#x2F;内存基地址，也就是我们存放 DMA 传输数据的内存地址。  uint32_t DMA_DIR;                    &#x2F;&#x2F;设置数据传输方向，从外设读取数据到内存,选择目的地  uint32_t DMA_BufferSize;             &#x2F;&#x2F;设置一次传输数据量的大小  uint32_t DMA_PeripheralInc;          &#x2F;&#x2F;设置传输数据的时候外设地址是不变还是递增。如果设置为递增，那么下一次                                       &#x2F;&#x2F;传输的时候地址加 1，这里因为我们是一直往固定外设地址&amp;USART1-&gt;DR                                       &#x2F;&#x2F;发送数据，所以地址不递增，值为 DMA_PeripheralInc_Disable；  uint32_t DMA_MemoryInc;              &#x2F;&#x2F;设置传输数据时候内存地址是否递增                                       &#x2F;&#x2F;这里我们的场景是将内存中连续存储单元的数据发送到串口，毫无疑问内存地                                       &#x2F;&#x2F;址是需要递增的，所以值为 DMA_MemoryInc_Enable  uint32_t DMA_PeripheralDataSize;     &#x2F;&#x2F;设置外设的数据长度是为字节传输（8bits）                                       &#x2F;&#x2F;半字传输(16bits),还是字传输(32bits)  uint32_t DMA_MemoryDataSize;         &#x2F;&#x2F;内存的数据长度,跟上一个意思相近  uint32_t DMA_Mode;                   &#x2F;&#x2F;设置 DMA模式,分为循环模式和铺铜模式  uint32_t DMA_Priority;               &#x2F;&#x2F;设置 DMA通道的优先级,有低,中,高,超高三种模式                                       &#x2F;&#x2F;DMA仲裁器将根据这些优先级的设置来决定先执行那个数据流的DMA                                       &#x2F;&#x2F;优先级相同的时候,根据硬件上的编号来决定哪个先执行（编号越小越优先）  uint32_t DMA_FIFOMode;               &#x2F;&#x2F;来设置是否开启 FIFO 模式  uint32_t DMA_FIFOThreshold;          &#x2F;&#x2F;设置FIFO阈值.根据前面讲解可以为FIFO容量的1&#x2F;4,1&#x2F;2,3&#x2F;4以及1倍  uint32_t DMA_MemoryBurst;            &#x2F;&#x2F;用来配置存储器突发传输配置,可以选择为 4 个节拍的增量突发传输                                       &#x2F;&#x2F;DMA_MemoryBurst_INC4.8个节拍,16个节拍,单次传输  uint32_t DMA_PeripheralBurst;        &#x2F;&#x2F;配置外设突发传输配置。&#125;DMA_InitTypeDef;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="DMA-配置程序过程"><a href="#DMA-配置程序过程" class="headerlink" title="DMA 配置程序过程"></a>DMA 配置程序过程</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">  DMA_InitTypeDef DMA_InitStructure ();  &#x2F;&#x2F;定义DMA结构体① RCC_AHB1PeriphClockCmd();  使能DMA时钟②  DMA_DeInit();③ USART_DMACmd();  使能串口DMA发送,串口DMA使能函数：④ DMA_GetCmdStatus();  查询DMA的EN位，确保数据流就绪，可以配置⑤ DMA_SetCurrDataCounter();  设置通道当前剩余数据量⑥ DMA_Cmd();  使能DMA1通道，启动传输。⑤ DMA_GetFlagStatus();  查询DMA传输状态⑥ DMA_GetCurrDataCounter();  获取&#x2F;设置通道当前剩余数据量：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码理解-😶"><a href="#代码理解-😶" class="headerlink" title="代码理解 😶"></a>代码理解 😶</h2><p>1.配置 usart 部分</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">注意:1.引脚复用映射     2.复用推挽输出     (STM32的IO都是通用接口     因此在作为特殊用途如串口输出时，需要对该IO口的设置成端口复用,区别于普通推挽输出)     3.&#x2F;&#x2F;使能串口       USART_Cmd(Usartx, ENABLE);       &#x2F;&#x2F;开启串口空闲中断       USART_ITConfig(Usartx, USART_IT_IDLE, ENABLE);       他的工作原理为：       当STM32的串口接收完一包数据后，会产生一个空闲中断。       这个中断在串口其他任何状态都不产生，只会在接收完一包数据后才会产生，一包数据可以是1个字节或者多个字节.       因此，我们可以在这个空闲中断函数中，设置一个接收完成标志位。       只需要在主程序中检测这个标志位就知道数据是否接收完成.       if(USART_GetITStatus(USART1,USART_IT_IDLE) !&#x3D; RESET) &#x2F;&#x2F;接收中断(接收到的数据必须是0x0d 0x0a结尾)  RESET是0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="http://blog.uuudiy.com/2022/09/29/42h-f407-gpio/">为什么是复用推挽输出</a><br><a href="https://www.guyuehome.com/35488">串口空闲检测中断</a> 2.配置 DMA 部分 😶‍🌫️</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">注意:1.使能DMA时钟   使能 DMA2 时钟，并等待数据流可配置。   DMA 的时钟使能是通过 AHB1ENR 寄存器来控制的，这里我们要先使能时钟，才可以配置 DMA   相关寄存器。所以先要使能DMA2的时钟。另外，要对配置寄存器（DMA_SxCR）进行设置，必须   先等待其最低位为&#96;0&#96;也就是 DMA 传输禁止了才可以进行配置。   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2,ENABLE);    &#x2F;&#x2F;DMA2 时钟使能   等待 DMA 可配置，也就是等待 DMA_SxCR 寄存器最低位为 0 的方法为：   while (DMA_GetCmdStatus(DMA_Streamx) !&#x3D; DISABLE)&#123;&#125;    &#x2F;&#x2F;等待 DMA 可配置    2.初始化DMA通道参数    3.使能串口DMA发送    4.查询DMA的EN位，确保数据流就绪，可以配置    5.设置通道当前剩余数据量    6.使能DMA1通道，启动传输。    7.查询DMA传输状态    8.获取&#x2F;设置通道当前剩余数据量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x2F;&#x2F;DMA 的发送初始化函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">    @Usartx             指定的串口，如 USART1    @Par                DMA外设地址，如 (u32)&amp;USART1-&gt;DR    @DMA_Streamx_tx     代表DMA1的发送数据流，DMA1_Stream0~DMA1_Stream7    @DMA_Chx            代表DMA的通道选择，DMA_Channel_0~DMA_Channel_7    @Tx_Buf             代表DMA的发送缓冲区    @Tx_Size            代表发送数据个数    @DMA_Streamx_Irqn   DMA数据流的中断，如 DMA2_Stream7_IRQnvoid Init_Dma_Tx_Config(USART_TypeDef *Usartx,u32 Par, DMA_Stream_TypeDef *DMA_Streamx_Tx,                        u32 DMA_Chx,u32 Tx_Buf, u16 Tx_Size, u32 DMA_Streamx_Irqn)&#123;    DMA_InitStructure.DMA_Channel &#x3D; DMA_Chx;                                   &#x2F;&#x2F;通道选择    DMA_InitStructure.DMA_PeripheralBaseAddr &#x3D; Par;                            &#x2F;&#x2F;DMA外设地址    DMA_InitStructure.DMA_Memory0BaseAddr &#x3D; Tx_Buf;                            &#x2F;&#x2F;DMA 存储器0地址    DMA_InitStructure.DMA_DIR &#x3D; DMA_DIR_MemoryToPeripheral;                    &#x2F;&#x2F;存储器到外设模式    DMA_InitStructure.DMA_BufferSize &#x3D; Tx_Size;                                &#x2F;&#x2F;数据传输量    DMA_InitStructure.DMA_PeripheralInc &#x3D; DMA_PeripheralInc_Disable;           &#x2F;&#x2F;外设非增量模式    DMA_InitStructure.DMA_MemoryInc &#x3D; DMA_MemoryInc_Enable;                    &#x2F;&#x2F;存储器增量模式    DMA_InitStructure.DMA_PeripheralDataSize &#x3D; DMA_PeripheralDataSize_Byte;    &#x2F;&#x2F;外设数据长度:8位    DMA_InitStructure.DMA_MemoryDataSize &#x3D; DMA_MemoryDataSize_Byte;            &#x2F;&#x2F;存储器数据长度:8位    DMA_InitStructure.DMA_Mode &#x3D; DMA_Mode_Normal;                              &#x2F;&#x2F; 使用普通模式    DMA_InitStructure.DMA_Priority &#x3D; DMA_Priority_Medium;                      &#x2F;&#x2F;中等优先级    DMA_InitStructure.DMA_FIFOMode &#x3D; DMA_FIFOMode_Disable;                     &#x2F;&#x2F;初始化DMA_FIFOMode    DMA_InitStructure.DMA_FIFOThreshold &#x3D; DMA_FIFOThreshold_Full;              &#x2F;&#x2F;FIFO 阈值选择。    DMA_InitStructure.DMA_MemoryBurst &#x3D; DMA_MemoryBurst_Single;                &#x2F;&#x2F;存储器突发单次传输    DMA_InitStructure.DMA_PeripheralBurst &#x3D; DMA_PeripheralBurst_Single;        &#x2F;&#x2F;外设突发单次传输    DMA_Init(DMA_Streamx_Tx, &amp;DMA_InitStructure);                               &#x2F;&#x2F;初始化    DMAStream    &#x2F;&#x2F;DMA 中断设置    NVIC_InitStructure.NVIC_IRQChannel &#x3D; DMA_Streamx_Irqn;                     &#x2F;&#x2F;DMA发送数据流中断通道    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority &#x3D; 0;                  &#x2F;&#x2F;抢占优先级0    NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D; 0;                         &#x2F;&#x2F;子优先级0    NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D; ENABLE;                            &#x2F;&#x2F;IRQ通道使能    NVIC_Init(&amp;NVIC_InitStructure);                                            &#x2F;&#x2F;根据指定的参数初始化NVIC寄存器    USART_DMACmd(Usartx,USART_DMAReq_Tx,ENABLE);                               &#x2F;&#x2F;使能串口1的DMA发送    DMA_Cmd(DMA_Streamx_Tx, DISABLE);                                          &#x2F;&#x2F;关闭DMA传输    DMA_ITConfig(DMA_Streamx_Tx,DMA_IT_TC,ENABLE);                             &#x2F;&#x2F;使能DMA的发送数据流中断&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x2F;&#x2F;DMA 的接收初始化函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">    @Usartx             指定的串口，如 USART1    @Par                DMA外设地址，如 (u32)&amp;USART1-&gt;DR    @DMA_Streamx_rx     代表DMA1的接收数据流，DMA1_Stream0~DMA1_Stream7    @DMA_Chx            代表DMA的通道选择，DMA_Channel_0~DMA_Channel_7    @Rx_Buf             代表DMA的接收缓冲区    @Rx_Size            代表接收数据个数void Init_Dma_Rx_Config(USART_TypeDef *Usartx, u32 Par, DMA_Stream_TypeDef *DMA_Streamx_Rx,                        u32 DMA_Chx,u32 Rx_Buf, u16 Rx_Size)&#123;    DMA_InitStructure.DMA_Channel &#x3D; DMA_Chx;                                 &#x2F;&#x2F;通道选择    DMA_InitStructure.DMA_PeripheralBaseAddr &#x3D; Par;                          &#x2F;&#x2F;DMA外设地址    DMA_InitStructure.DMA_Memory0BaseAddr &#x3D; Rx_Buf;                          &#x2F;&#x2F;DMA 存储器0地址    DMA_InitStructure.DMA_DIR &#x3D; DMA_DIR_PeripheralToMemory ;                 &#x2F;&#x2F;外设到存储器模式    DMA_InitStructure.DMA_BufferSize &#x3D; Rx_Size;                              &#x2F;&#x2F;数据传输量    DMA_InitStructure.DMA_PeripheralInc &#x3D; DMA_PeripheralInc_Disable;         &#x2F;&#x2F;外设非增量模式    DMA_InitStructure.DMA_MemoryInc &#x3D; DMA_MemoryInc_Enable;                  &#x2F;&#x2F;存储器增量模式    DMA_InitStructure.DMA_PeripheralDataSize &#x3D; DMA_PeripheralDataSize_Byte;  &#x2F;&#x2F;外设数据长度:8位    DMA_InitStructure.DMA_MemoryDataSize &#x3D; DMA_MemoryDataSize_Byte;          &#x2F;&#x2F;存储器数据长度:8位    DMA_InitStructure.DMA_Mode &#x3D; DMA_Mode_Normal;                            &#x2F;&#x2F; 使用普通模式    DMA_InitStructure.DMA_Priority &#x3D; DMA_Priority_Medium;                    &#x2F;&#x2F;中等优先级    DMA_InitStructure.DMA_FIFOMode &#x3D; DMA_FIFOMode_Disable;                   &#x2F;&#x2F;初始化DMA_FIFOMode    DMA_InitStructure.DMA_FIFOThreshold &#x3D; DMA_FIFOThreshold_Full;            &#x2F;&#x2F;FIFO 阈值选择。    DMA_InitStructure.DMA_MemoryBurst &#x3D; DMA_MemoryBurst_Single;              &#x2F;&#x2F;存储器突发单次传输    DMA_InitStructure.DMA_PeripheralBurst &#x3D; DMA_PeripheralBurst_Single;      &#x2F;&#x2F;外设突发单次传输    DMA_Init(DMA_Streamx_Rx, &amp;DMA_InitStructure);                            &#x2F;&#x2F;初始化DMA Stream    USART_DMACmd(Usartx,USART_DMAReq_Rx,ENABLE);                             &#x2F;&#x2F;使能串口的DMA接收    DMA_Cmd(DMA_Streamx_Rx, ENABLE);                                         &#x2F;&#x2F;开启DMA传输&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DMA-的发送使能"><a href="#DMA-的发送使能" class="headerlink" title="DMA 的发送使能"></a>DMA 的发送使能</h3><p>DMA 配置 mormal 模式只能进行一次数据的发送<br>circular 模式可以持续发送相同的数据。但是要多次发送不同的数据<br>normal 模式下需要进行一下操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">DMA1_Channel4-&gt;CCR&amp;&#x3D;~(1&lt;&lt;0);   &#x2F;&#x2F;关闭DMA1的通道四DMA1_Channel4-&gt;CNDTR&#x3D;9;        &#x2F;&#x2F;设置DMA数据计数器的值DMA1_Channel4-&gt;CCR|&#x3D;1&lt;&lt;0;      &#x2F;&#x2F;使能DMA1的通道四上面是使用了直接操作寄存器的方式实现了需求DMA_Cmd(DMA1_Channel4,DISABLE);DMA_SetCurrDataCounter(DMA1_Channel4,9);DMA_Cmd(DMA1_Channel4,ENABLE);这样每次调用DMA发送函数时,相当于重新计数,达到多次发送不同数据的效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">    @DMA_Streamx_tx             &#x2F;&#x2F;代表DMA的发送数据流    @DMA1_Stream0~DMA1_Stream7  &#x2F;&#x2F;DMA2_Stream0~DMA2_Stream7    @ndtr                       &#x2F;&#x2F;代表DMA的发送数据个数void Dma_Send_Enable(DMA_Stream_TypeDef *DMA_Streamx_tx,u16 ndtr)&#123;    DMA_Cmd(DMA_Streamx_tx, DISABLE);                         &#x2F;&#x2F;关闭DMA传输    while (DMA_GetCmdStatus(DMA_Streamx_tx) !&#x3D; DISABLE);      &#x2F;&#x2F;确保DMA可以被设置    DMA_SetCurrDataCounter(DMA_Streamx_tx,ndtr);              &#x2F;&#x2F;数据传输量    DMA_Cmd(DMA_Streamx_tx, ENABLE);                          &#x2F;&#x2F;开启DMA传输&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DMA-的发送完成中断函数"><a href="#DMA-的发送完成中断函数" class="headerlink" title="DMA 的发送完成中断函数"></a>DMA 的发送完成中断函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">void DMA2_Stream7_IRQHandler(void)&#123;    if(DMA_GetFlagStatus(DMA2_Stream7,DMA_FLAG_TCIF7)!&#x3D;RESET) &#x2F;&#x2F;等待DMA2_Steam7传输完成    &#123;        DMA_ClearFlag(DMA2_Stream7,DMA_FLAG_TCIF7);           &#x2F;&#x2F;清除DMA2_Steam7传输完成标志        DMA_Cmd(DMA2_Stream7,DISABLE);                        &#x2F;&#x2F;关闭DMA        DMA_ClearITPendingBit(DMA2_Stream7, DMA_IT_TCIF7);    &#x2F;&#x2F;清除中断屏蔽位    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/09/23/39h-usart-dma/08.png" class=""><h3 id="串口-1-的空闲中断函数"><a href="#串口-1-的空闲中断函数" class="headerlink" title="串口 1 的空闲中断函数"></a>串口 1 的空闲中断函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">void USART1_IRQHandler(void)&#123;    u16 i;                                                       &#x2F;&#x2F;串口空闲中断,idle置1说明接收到了一包数据    if(USART_GetITStatus(USART1,USART_IT_IDLE) !&#x3D; RESET)         &#x2F;&#x2F;接收中断,RESET&#x3D;0        DMA_Cmd(DMA2_Stream5, DISABLE);                          &#x2F;&#x2F;关闭DMA,防止处理其间有数据        &#x2F;&#x2F;先读SR，再读DR，是为了清除IDLE中断        i &#x3D; USART1-&gt;SR;                                          &#x2F;&#x2F;读SR寄存器(状态寄存器)        i &#x3D; USART1-&gt;DR;                                          &#x2F;&#x2F;读DR寄存器(数据寄存器)        rx_len &#x3D; BufferLen - DMA_GetCurrDataCounter(DMA2_Stream5);  &#x2F;&#x2F;获得这一帧数据的长度,获得这一帧数据的长度                                                                    &#x2F;&#x2F;DMA缓存的大小 - 剩余 DMA缓存大小        if(rx_len !&#x3D;0)                                              &#x2F;&#x2F;这一帧数据长度不为0        &#123;            rx_flag &#x3D; 1;                                            &#x2F;&#x2F;数据帧接收标志置1            for(i&#x3D;0;i&lt;rx_len;i++)            &#123;                SendBuffer[i]&#x3D; ReceiveBuffer[i];                    &#x2F;&#x2F;将接收的数据保存            &#125;            for(i&#x3D;0;i&lt;rx_len;i++)                                   &#x2F;&#x2F;将接收缓冲区清零            &#123;                ReceiveBuffer[i]&#x3D;0;                                 &#x2F;&#x2F;这段我理解的是利用串口空闲中断标志位,rx_flag作为dma_send函数是否发                                                                    &#x2F;&#x2F;送的标志位            &#125;        &#125;        &#x2F;&#x2F;清除DMA2_Steam5传输完成标志        DMA_ClearFlag(DMA2_Stream5,DMA_FLAG_TCIF5 | DMA_FLAG_FEIF5 | DMA_FLAG_DMEIF5 | DMA_FLAG_TEIF5 | DMA_FLAG_HTIF5);        DMA_SetCurrDataCounter(DMA2_Stream5, BufferLen);            &#x2F;&#x2F;设置DMA接收单元的长度        DMA_Cmd(DMA2_Stream5, ENABLE);                              &#x2F;&#x2F;打开DMA    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/09/23/39h-usart-dma/07.png" class=""><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int main(void)&#123;    LED_Init();    delay_init(168);          &#x2F;&#x2F;初始化延时函数    Init_Clock_Config();                     &#x2F;&#x2F;时钟初始化    Init_Gpio_Config();                      &#x2F;&#x2F;GPIO引脚初始化    Init_Usart_Config(USART1,19200);          &#x2F;&#x2F;串口初始化    Init_Usart_Nvic_Config(USART1_IRQn);     &#x2F;&#x2F;串口中断初始化    &#x2F;&#x2F;DMA 发送数据流初始化    Init_Dma_Tx_Config(USART1, (u32)(&amp;USART1-&gt;DR), DMA2_Stream7, DMA_Channel_4, (u32)SendBuffer, BufferLen, DMA2_Stream7_IRQn);    &#x2F;&#x2F;DMA 接收数据流初始化    Init_Dma_Rx_Config(USART1, (u32)(&amp;USART1-&gt;DR), DMA2_Stream5, DMA_Channel_4, (u32)ReceiveBuffer, BufferLen);    while(1)    &#123;        &#x2F;&#x2F;接收到一帧数据        if(rx_flag)        &#123;            &#x2F;&#x2F;将接收到的数据发送到设备            Dma_Send_Enable(DMA2_Stream7, rx_len);        &#x2F;&#x2F;这里我不理解为什么是rx_len,而不是sendbuffer ,rx_len不只是个长度吗                                                          &#x2F;&#x2F;数据长度即数据本身,原理应该跟已知计数最大值,                                                          &#x2F;&#x2F;求计数初值&#x3D;计数最大值-要计的个数相似                                                          &#x2F;&#x2F;传输的数据实际上就是0 1            &#x2F;&#x2F;数据帧接收标志清零            rx_flag &#x3D; 0;        &#125;        LED1 &#x3D; !LED1;     &#x2F;&#x2F;LED灯闪烁，表示程序正常运行        delay_ms(100);                    &#x2F;&#x2F;延时300ms    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>📖 我可能需要恶补一下 c 语言 😭<br><a href="https://blog.csdn.net/m0_62722416/article/details/126540746?spm=1001.2101.3001.6650.17&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-17-126540746-blog-121202129.t0_edu_mlt&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-17-126540746-blog-121202129.t0_edu_mlt&utm_relevant_index=22">DMA 配置</a><br><a href="https://blog.csdn.net/qq_28959531/article/details/81219150?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5-81219150-blog-122668801.pc_relevant_aa_2&spm=1001.2101.3001.4242.4&utm_relevant_index=8">STM32F407ZGT6 串口 DMA</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32F407 </tag>
            
            <tag> USART_DMA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab的几个绘图函数</title>
      <link href="/2022/09/12/38m-matlab/"/>
      <url>/2022/09/12/38m-matlab/</url>
      
        <content type="html"><![CDATA[<h2 id="linspace-生成线性间距向量"><a href="#linspace-生成线性间距向量" class="headerlink" title="linspace 生成线性间距向量"></a>linspace 生成线性间距向量</h2><p>y &#x3D; linspace(x1,x2) 返回包含 x1 和 x2 之间的 100 个等间距点的行向量。<br>y &#x3D; linspace(x1,x2,n) 生成 n 个点。这些点的间距为 (x2-x1)&#x2F;(n-1)。</p><p>linspace 类似于冒号运算符“:”，但可以直接控制点数并始终包括端点。“linspace”名称中的“lin”指示生成线性间距值而不是同级函数 logspace，后者会生成对数间距值。</p><h2 id="plot-二维线图"><a href="#plot-二维线图" class="headerlink" title="plot 二维线图"></a>plot 二维线图</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">语法plot(X,Y)创建 Y 中数据对 X 中对应值的二维线图。         要绘制由线段连接的一组坐标，请将 X 和 Y 指定为相同长度的向量。         要在同一组坐标轴上绘制多组坐标，请将 X 或 Y 中的至少一个指定为矩阵。plot(X,Y,LineSpec)    使用指定的线型、标记和颜色创建绘图。plot(X1,Y1,...,Xn,Yn) 在同一组坐标轴上绘制多对 x 和 y 坐标。此语法可替代将坐标指定为矩阵的形式。plot(X1,Y1,LineSpec1,...,Xn,Yn,LineSpecn) 可为每个 x-y 对组指定特定的线型、标记和颜色。&#39;x&#39; 默认 &#39;--&#39;虚线  &#39;:&#39;点线                                          可以对某些 x-y 对组指定 LineSpec，而对其他对组省略它。plot(x,y1,&#39;g&#39;,x,y2,&#39;b--o&#39;,x,y3,&#39;c*&#39;)      指定线型、颜色和标记plot(x,y,&#39;-o&#39;,&#39;MarkerIndices&#39;,1:5:length(y)) 在特定的数据点显示标记plot(X1,Y1,&#39;o&#39;,X2,Y2) 对第一个 x-y 对组指定标记，但没有对第二个对组指定标记。plot(Y)              绘制 Y 对一组隐式 x 坐标的图。                     如果 Y 是向量，则 x 坐标范围从 1 到 length(Y)。                     如果 Y 是矩阵，则对于 Y 中的每个列，图中包含一个对应的行。x 坐标的范围是从 1 到 Y 的行数。                     如果 Y 包含复数，MATLAB® 绘制 Y 的虚部对 Y 的实部的图。 如果同时指定了 X 和 Y，虚部将被忽略。plot(___,Name,Value) 使用一个或多个名称-值参数指定 Line 属性。                     这些属性应用于绘制的所有线条。需要在上述任一语法中的所有参数之后指定名称-值参数。有关属性列表，请参阅 Line 属性。plot(ax,___)         在目标坐标区上显示绘图。将坐标区指定为上述任一语法中的第一个参数。p &#x3D; plot(___)        返回一个 Line 对象或 Line 对象数组。创建绘图后，使用 p 修改该绘图的属性。有关属性列表，请参阅                     Line 属性。 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="mesh函数用法"><a href="#mesh函数用法" class="headerlink" title="mesh函数用法"></a>mesh函数用法</h2><p>mesh语句画网格图片，实际上就是给出一对坐标(x,y)，来画矩阵z(x,y)的值。</p><img src="/2022/09/12/38m-matlab/01.jpg" class=""><h2 id="meshgrid函数"><a href="#meshgrid函数" class="headerlink" title="meshgrid函数"></a>meshgrid函数</h2><p>将函数转换生成矩阵</p><img src="/2022/09/12/38m-matlab/02.jpg" class=""><pre class="line-numbers language-c" data-language="c"><code class="language-c">x&#x3D;-4:0.25:4;y&#x3D;x;[X,Y]&#x3D;meshgrid(x,y);   #缺少这步骤会报错:Z必须为矩阵，不能是标量或向量。Z&#x3D;-X.^4+Y.^5;mesh(Z)title(&#39;网格面&#39;)xlabel(&#39;x&#39;),ylabel(&#39;y&#39;),zlabel(&#39;z&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/09/12/38m-matlab/03.jpg" class=""><pre class="line-numbers language-c" data-language="c"><code class="language-c">t&#x3D;-4:0.1:4;[X,Y]&#x3D;meshgrid(t);Z&#x3D;peaks(X,Y);mesh(X,Y,Z)title(&#39;显示网格&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/09/12/38m-matlab/04.jpg" class=""><h2 id="for-用来重复指定次数的-for-循环"><a href="#for-用来重复指定次数的-for-循环" class="headerlink" title="for 用来重复指定次数的 for 循环"></a>for 用来重复指定次数的 for 循环</h2><p><a href="https://ww2.mathworks.cn/help/matlab/ref/mesh.html?searchHighlight=mesh&s_tid=srchtitle_mesh_1">官方文档</a><br><a href="https://blog.csdn.net/weixin_44044161/article/details/115802993?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166286682316782412591023%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166286682316782412591023&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-115802993-null-null.142%5Ev47%5Epc_rank_34_default_2,201%5Ev3%5Econtrol_1&utm_term=matlab%20mesh&spm=1018.2226.3001.4187">三维网格绘图（mesh)</a><br><a href="https://blog.csdn.net/Ricardo2/article/details/117514592?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166337608116782412577988%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166337608116782412577988&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-117514592-null-null.142%5Ev47%5Epc_rank_34_default_2,201%5Ev3%5Econtrol_1&utm_term=matlab%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86&spm=1018.2226.3001.4187">数值积分</a><br><a href="https://blog.csdn.net/fifiyang/article/details/116357355">matlab绘制奈奎斯特图和伯德图</a></p>]]></content>
      
      
      <categories>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keil开发51单片机及使用汇编语言点亮数码管</title>
      <link href="/2022/09/08/37h-51-number-led/"/>
      <url>/2022/09/08/37h-51-number-led/</url>
      
        <content type="html"><![CDATA[<h2 id="keil-搭建-51-环境"><a href="#keil-搭建-51-环境" class="headerlink" title="keil 搭建 51 环境"></a>keil 搭建 51 环境</h2><p>安装 c51v959.exe,然后使用 keygen 激活一下</p><p>file-&gt;device database 搜索 at89c51 芯片</p><p>output-&gt;√ create hex file(output 里可以对生成的.hex 文件命名)</p><p>target-&gt;可以更改更改晶振频率</p><p>新建一个文件夹-&gt;作为新建的工程的位置-&gt;选否(选择不复制 8051 启动代码到工程文件)<code>暂时还不知道为啥,不过汇编语言和直接使用proteus仿真</code></p><p>然添加文件路径,和文件,.asm 文件不能通过那三个魔方加入,似乎只有.c 可以,但是可以通过<code>双击source group1将.asm加入进来</code></p><h2 id="汇编语言编写程序"><a href="#汇编语言编写程序" class="headerlink" title="汇编语言编写程序"></a>汇编语言编写程序</h2><p>注意:<br>汇编语言中,以字母开头的数前面要加 0 比如 0F8H<br><a href="https://blog.csdn.net/nuli123lkj/article/details/124102398">51 单片机————Keil 基本操作</a>)</p><h2 id="一些基础汇编指令"><a href="#一些基础汇编指令" class="headerlink" title="一些基础汇编指令"></a>一些基础汇编指令</h2><p>一、符号定义</p><table><thead><tr><th align="center">名 称</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="center">Rn</td><td align="left">n&#x3D;0 ～ 7，R0 ～ R7 寄存器</td></tr><tr><td align="center">Direct</td><td align="left">直接地址，内部数据区的地址 RAM(00H ～ 7FH)</td></tr><tr><td align="center">SFR</td><td align="left">(80H ～ FFH) B，ACC，PSW，IP，P3，IE，P2，SCON，P1，TCON，P0</td></tr><tr><td align="center">@Ri</td><td align="left">间接寻址 Ri&#x3D;R0、R1 8051&#x2F;31RAM 地址(00H ～ 7FH) 8052&#x2F;32RAM 地址(00H ～ FFH)</td></tr><tr><td align="center">#data</td><td align="left">8 位常数</td></tr><tr><td align="center">#data16</td><td align="left">16 位常数</td></tr><tr><td align="center">Addr16</td><td align="left">16 位的目标地址</td></tr><tr><td align="center">Addr11</td><td align="left">11 位的目标地址</td></tr><tr><td align="center">Rel</td><td align="left">相关地址</td></tr><tr><td align="center">bit</td><td align="left">内部数据 RAM(20H ～ 2FH)，特殊功能寄存器的直接地址的位</td></tr></tbody></table><p><a href="https://blog.csdn.net/Danie_wu/article/details/80461726?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166311995416782425166909%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166311995416782425166909&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80461726-null-null.142%5Ev47%5Epc_rank_34_default_2,201%5Ev3%5Econtrol_1&utm_term=cjne%E6%8C%87%E4%BB%A4&spm=1018.2226.3001.4187">常用汇编语言指令 1</a><br><a href="https://blog.csdn.net/m0_51171997/article/details/115632110?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166311995416782425166909%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166311995416782425166909&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-115632110-null-null.142%5Ev47%5Epc_rank_34_default_2,201%5Ev3%5Econtrol_1&utm_term=cjne%E6%8C%87%E4%BB%A4&spm=1018.2226.3001.4187">常用汇编语言指令 2</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ORG 0000H           ;指定程序的起始地址   SJMP  MAIN       ;跳转到MAIN程序MAIN:               ;程序的主程序    MOV  A,#08H     ;将08H送入A寄存器    MOV  P0,A       ;将A寄存器的值送入P0口    MOV  A,#00H     ;用来存储偏移量    MOV  R0,#10     ;记录循环次数,0-9有十个数    MOV  R1,#0    MOV  DPTR,#DIGIT ;数组首地址用DPRT记录,指针给DPRT,见解来说,DPRT是数组的第一个地址                     ;我想知道这个DIGIT是不是就是一个单纯的数组名LOOP:    MOV   A,R1    MOVC  A,@A+DPTR ;基地址的偏移指针,只能用a做偏移量    MOV   P2,A      ;读取到的数组内容赋值给P2引脚    INC   R1        ;偏移量加1    LCALL DELAY500MS ;LCALL的意思是调用，调用DELAY1000MS    DJNZ  R0,LOOP    ;将R0减一，非0则跳转到LOOP，为0则执行下一句（可以执行10次）    SJMP  MAINDIGIT:    DB 0C0H,0F9H,0A4H,0B0H,099H,092H,082H,0F8H,080H,090H  ;前面加0,因为不能以字母开头 ;共阳   0    1    2    3    4    5    6    7    8    9   ;注：在汇编语言中十六进制的立即数有一个规则，当十六进制数是字母开头时要在前面加0，                                                          ;这也就是为什么时#0C0H 而不是 #C0H的原因了）DELAY500MS:    MOV   R7,#17H     ;让CPU执行废指令达到延时的目的,可以通过调整R7,R6,R5的值调整延时的时间DL1:    MOV   R6,#98HDL0:    MOV   R5,#46H    DJNZ  R5,$      ;如果R5不为0，就跳转到$处，也就是跳转到本句，这样就可以实现延时    DJNZ  R6,DL0    ;当R6不为0时，跳转到DL0，为0时执行下一句    DJNZ  R7,DL1    NOP             ;空    RET             ;函数结束    END             ;整个程序块结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/yvge669/article/details/124522144">51单片机汇编语言点亮一位数码管</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STC89C52单片机</title>
      <link href="/2022/09/03/36h-stc89c52/"/>
      <url>/2022/09/03/36h-stc89c52/</url>
      
        <content type="html"><![CDATA[<h2 id="单片机按键复位电路的原理"><a href="#单片机按键复位电路的原理" class="headerlink" title="单片机按键复位电路的原理"></a>单片机按键复位电路的原理</h2><p>51单片机要复位只需求在第9引脚接个高电平持续2us就能够完结,只需确保电容的充放电时刻大于2US，即可完结复位，所以电路中的电容值是能够改动的</p><img src="/2022/09/03/36h-stc89c52/01.png" class="" title="复位电路"><p>利用RC电路的充放电效应。当单片机上电的时候，复位电路通过电容加载RST引脚一个短暂的高电平信号，这个高电平信号随着电容的充电而逐渐降低，这个高电平持续的时间和RC电路的充放电时间有关。用户在使用时，需要选择合适的电容和电阻来使高电平的持续时间大于单片机的复位时间。<br>1．上电复位：<br>在电路图中，电容的的大小是10uf，电阻的大小是10k。所以依据公式…..(<code>暂时未知</code>).，能够算出电容充电到电源电压的0.7倍（单片机的电源是5V，所以充电到0.7倍即为3.5V），需求的时间是10K*10UF&#x3D;0.1S。也就是说在单片机启动的0.1S内，电容两头的电压时在0<del>3.5V添加。这个时间10K电阻两头的电压为从5</del>1.5V削减（串联分压）。所以在0.1S内，RST引脚所接纳到的电压是5V~1.5V。在5V正常作业的51单片机中小于1.5V的电压信号为低电平信号，而大于1.5V的电压信号为高电平信号。所以在开机0.1S内，单片机体系主动复位（RST引脚接纳到的高电平信号时刻为0.1S摆布）。</p><p>2．手动复位：<br>在单片机启动0.1S后，电容C两头的电压继续充电为5V，这个时候10K电阻两头的电压挨近于0V，RST处于低电平所以体系正常工作。当按键按下时，开关导通，这个时候电容两头构成了一个回路，电容被短路，所以在按键按下的这个进程中，电容开端开释之前充的电量。随着时刻的推移，电容的电压在0.1S内，从5V开释到变为了1.5V，甚至更小。依据串联电路电压为遍地之和，此时10K电阻两头的电压为3.5V，可能更大，所以RST引脚又接到高电平。单片机体系主动复位。<br>3.相关公式<br>1.1 RC充放电时间常数<br>串联RC电路的时间常数是一个固定的时间间隔，等于电阻和电容的乘积。其公式为：</p><img src="/2022/09/03/36h-stc89c52/02.png" class=""><p>式中，τ为RC充放电时间常数，单位是S；R为电阻，单位是Ω；C为电容，单位是F。<br>1.2 RL充放电时间常数<br>串联RL电路的时间常数是一个固定的时间间隔，等于电感对电阻的比值。其公式为：</p><img src="/2022/09/03/36h-stc89c52/03.png" class=""><p>式中，τ为RL充放电时间常数，单位是S；L为电感，单位是H；R为电阻，单位是Ω。</p><h2 id="STC89C52RC原理图"><a href="#STC89C52RC原理图" class="headerlink" title="STC89C52RC原理图"></a>STC89C52RC原理图</h2><p>P0.0到P0.7内部无上拉电阻,如果作为IO口的,必须外接10k-4.7k的上拉电阻<br>当P0作为数据&#x2F;地址总线使用时,此时无需外接上拉电阻<br>EA引脚已内部上拉到VCC,外部不加上拉或上拉到VCC,上电复位后单片机从内部开始执行程序<br>EA引脚外部下拉到地,单片机上电复位后从外部开始执行程序<br>晶振,数据手册上建议的是47pf,暂时不知道为什么大多数都用了22pf</p><p>LED灯的原理图</p><img src="/2022/09/03/36h-stc89c52/08.png" class=""><p>引脚左部分为单片机内部电路,不用a电路,第一是因为led导通对电压有要求,而单片机电压可能会损耗,led可能会出现无法被点亮的情况,b电路可以保证引脚为低电平时二极管一定导通,第二是可能会因为功率问题导致芯片烧毁</p><p>引脚功能图</p><img src="/2022/09/03/36h-stc89c52/04.png" class=""><img src="/2022/09/03/36h-stc89c52/05.png" class=""><img src="/2022/09/03/36h-stc89c52/06.png" class=""><p>芯片引脚图</p><img src="/2022/09/03/36h-stc89c52/07.png" class=""><img src="/2022/09/03/36h-stc89c52/09.png" class=""><p><a href="https://www.eefocus.com/e/485623">参考文章</a><br><a href="https://www.elecfans.com/emb/danpianji/202007121244668.html">参考文章</a><br><a href="https://www.semiee.com/file/STC/STC-STC89C51RC.pdf">数据手册</a></p><p>　　</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STC89C52 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八路灰度传感器</title>
      <link href="/2022/08/30/35h-grayscale-sensor/"/>
      <url>/2022/08/30/35h-grayscale-sensor/</url>
      
        <content type="html"><![CDATA[<h2 id="灰度传感器与红外传感器"><a href="#灰度传感器与红外传感器" class="headerlink" title="灰度传感器与红外传感器"></a>灰度传感器与红外传感器</h2><p>1.灰度传感器是模拟传感器,有一只发光二极管和一只光敏电阻,安装在同一面上,利用不同颜色的检测面对光的反射程度不同，光敏电阻对不同检测面返回的光，其阻值也不同的原理进行颜色深浅检测。在有效的检测距离内，发光二极管发出白光，照射在检测面上，检测面反射部分光线，光敏电阻检测此光线的强度并将其转换为机器人可以识别的信号。</p><p>灰度传感器：所谓灰度也可认为是亮度，简单的说就是色彩的深浅程度。根据反射光的强度，可以判断出物体的灰级程度</p><p>灰度传感器缺点：有效检测距离比较短。</p><p>2.红外传感器：红外传感器主要用来检测是否有障碍物，一般由两只红外管构成的，一只发射，一只接收</p><ul><li>调电阻可变电阻的技术指标<ul><li>可调电阻被广泛的应用于各种电路中，常见的型号有3361W、3006P、3266W、3323P、3266P、3296P、3386P、3296W、3362P、3362M、3361P、3266X等。常见阻值的标注方法有：101表示10×10的一次方，即100Ω;202表示200×10的二次方，即2000Ω&#x3D;2kΩ;501表示50×10的一次方，即500Ω;</li></ul></li><li>单圈电位器和多圈电位器的区别<ul><li><p>单圈电位器是说，它的电阻体只有一周，既可以无限连续旋转，也可以有机械限位角度。有止挡的话，可以在0-360度范围内选择电气角度。 多圈电位器是说，它的电阻体有很多周，通常来说有10周。即：它的机械行程为3600度。内部可以做成螺旋状的机械行程导轨，在导轨两头设置止挡。<br> 无论多圈还是单圈电位器，只要在机械部分设置了止挡，则电位器的机械行程是有范围的，即：不可连续无限旋转的。 电位器很小，它的止挡是有“止挡力矩”的，过大的力将破坏电位器的止挡，从而引起电位器的损坏。<br> 没有限制角度的电位器，叫做无止挡电位器（从机械角度讲，可以连续旋转，但是电阻体上总是有一个起始点和一个终止点）</p></li><li><p>单圈电位器主要用在民用设备上，主要特点是在一圈的范围内就能完成大幅度的改变，多圈特点是能调节的精密，适合设备上或工控用，举个例子，假设你买个音箱，想变个音量，但音箱用多圈电位器，你受得了调个音量就得转十几圈么？但如果有个0~5V的电压源，你能要输出3.25V，但单圈电位器稍微一碰就0.5V的变动，肯定用单圈就是失败的设计。在PCB设计上如不是太计较成本都可以用的，多圈电位器也有小型的！</p></li></ul></li></ul><p>需要精确度比较高的调试,常选用多圈电位器</p><h2 id="画板过程中遇到的困难"><a href="#画板过程中遇到的困难" class="headerlink" title="画板过程中遇到的困难"></a>画板过程中遇到的困难</h2><p>首先就是不知道原理,资料很少,照着一个大佬的博客画出了原理图,看到淘宝有卖那种数字信号和模拟信号只需改变电阻位置就可以改变结果的,找原因找了好久,最后发现是因为LM339DT做电压比较器,想要输出模拟信号,去掉这个芯片就可以,所以这个芯片应该是A&#x2F;D转换芯片<br>所以淘宝店铺的那个产品的电阻部分应该是这样的</p><img src="/2022/08/30/35h-grayscale-sensor/05.jpg" class=""><img src="/2022/08/30/35h-grayscale-sensor/04.jpg" class=""><p>一个焊盘在A_OUT1的左面,接在这里输出数字信号</p><img src="/2022/08/30/35h-grayscale-sensor/06.jpg" class=""><p>另一个焊盘的位置在这张图的R1这,改变的电阻就是R1,接在这里,输出的就是模拟信号,因为LM339DT已经断开</p><h2 id="LM339DT芯片"><a href="#LM339DT芯片" class="headerlink" title="LM339DT芯片"></a>LM339DT芯片</h2><p>引脚图</p><img src="/2022/08/30/35h-grayscale-sensor/07.jpg" class=""><p>LM339 比较器 IC 由 4 个内置的独立电压比较器组成<br>比较器 1、2、3 、 4 ：正输入连接到 IC 引脚 3 ， 负输入 连接到 IC 引脚 12。<br>比较器 1 ：反相输入连接到 IC 引脚 4 ，非反相输入连接到 IC 引脚 5，输出连接到 IC 引脚 2。<br>比较器 2 ：反相输入连接到 IC 引脚 6 ，非反相输入连接到 IC 引脚 7，输出连接到 IC 引脚 1。<br>比较器 3 ：反相输入连接到 IC 引脚 8 ，非反相输入连接到 IC 引脚 9，输出连接到 IC 引脚14。<br>比较器 4 ：反相输入连接到 IC 引脚 10 ，非反相输入连接到 IC 引脚 11，输出连接到 IC 引脚13。<br>典型电路图</p><img src="/2022/08/30/35h-grayscale-sensor/08.jpg" class=""><h2 id="暂时还不知道LM339DT芯片与LM399芯片的区别是什么"><a href="#暂时还不知道LM339DT芯片与LM399芯片的区别是什么" class="headerlink" title="暂时还不知道LM339DT芯片与LM399芯片的区别是什么"></a>暂时还不知道LM339DT芯片与LM399芯片的区别是什么</h2><h2 id="LM399芯片"><a href="#LM399芯片" class="headerlink" title="LM399芯片"></a>LM399芯片</h2><p>LM399 是一款电压比较器，由 14 个引脚和 4 个独立的电压比较器组成，比较在输入端应用的两个输入，并以数字形式显示输出</p><h2 id="可以进行模数转换的原理"><a href="#可以进行模数转换的原理" class="headerlink" title="可以进行模数转换的原理"></a>可以进行模数转换的原理</h2><p>  红外对管,透明的那个是红外发射管，暗黑色那个叫红外接收管。是不是红外发射管发出的亮度越高越好呢？不是的，发出的亮度应该是适中且固定的。适中容易<br>理解，固定是什么意思？就是亮度应该由始至终都相同，不然就算是检测同一个障碍物的灰度，红外发射管发射的亮度忽明忽暗，红外接收管接收到的反射光也就忽明忽暗，但是明明是同一个障碍物，这样就不对了。我们一般能够在厂商提供的数据手册中找到红外发射管正常工作时的电流（一般是十几毫安到几十毫安），根据这个电流和电源的电压，求出要加的电阻的大小。</p><p>红外接收管怎么知道接收红外光有多亮<br>　　首先我们要了解一个概念：光敏元件，简单来说就是对光敏感的元件，也就是说，环境亮度大小会导致光敏元件某一个物理量发生变化。我们使用的红外接收管就是一种光敏元件，当接收红外光亮度越大时，电阻就越小。接收的原理弄懂了，实际实现要怎么做呢？测电阻。但是单片机没有办法直接测电阻,把测电阻转换成测电压。</p><p>　　怎么测电阻大小,图中的RL即红外接收管的电阻，R1是我们挑选的固定阻值的电阻。根据电阻分压原理，我们可以得到UL的值，固定电源为5V，我们假设红外接收管在障碍物为黑色的时候（即在跑道上），RL电阻为30K，在障碍物为白色的时候，RL电阻为300，假设R1我们用10K的电阻，求障碍物为黑色的时候电压UL等于多少，障碍物为白色的时候电压UL等于多少。<br>　　因此小车在跑道上跑的时候，UL的值就在0.15到3.75之间变化，我们通过检测UL的大小就可以知道这个红外灰度传感器是否在跑道上了。</p><p>　还记得我们前面提到说，“勉强”可以测量电压吗？为什么要说勉强？实际上一般型号的51单片机（不包括某些增强版）是不具备测电压功能的，也就是说，我们没有办法测得出UL的数值。但是51单片机能够输入高低电平，也就是0和1，输入低于0.4V就相当于输入0，输入高于2.4V就相当于输入1。因此，我们需要一种折中的办法，以达到我们的目的。<br>　　我们回顾一下我们的目的，不就是区分黑线和白色背景吗，而且黑线和白色背景对应的UL相差又比较大，我们大概取一个中间值，约为2V。现在我们设计一个元件，这个元件有一个输入和一个输出。当输入小于2V时，输出为0V；当输出大于2V时，输出为5V。如下图理解：</p><p>　　这样一来我们就将UL的0.15~3.75这样的一个范围值变成了0和5这样的两个数，对应了单片机输入的0和1，分别代表着白色背景和黑色线路。</p><p>　　<code>这个将数值进行比较后进行输出的元件叫电压比较器，划重点，电压比较器</code>！！！ 电压比较器的电路应该这样画：</p><img src="/2022/08/30/35h-grayscale-sensor/07.jpg" class=""><p>　　中间那个带+ -号的三角形叫做运放，当+（正）端输入的电压大于-（负）端电压时，输出5V，否则输出0V。</p><p>　　回顾一下上面说到的几个电路，电阻限流，电阻分压，比较器。综合以上三个电路，一个红外灰度传感器的电路就出现了，如下图：VCC连接电源正极，GND连接电源负极，TCRT5000是一组红外对管，左边带两个箭头的是红外发射管，右边的是红外接收管。</p><img src="/2022/08/30/35h-grayscale-sensor/09.jpg" class=""><p>　　上面我们说的，比较器的原理是什么来着，<code>当运放+（正）输入电压大于-（负）输入电压时(也就是IN+&gt;IN-引脚的时候)</code>，运放输出(OUT引脚)就为5V，反之输出就为0V。观察此时的+-极输入是什么。+极输入是前面电阻分压电路得到的UL，-极输入是VCC和GND之间的电压经过滑动变阻器（也叫电位器）分压后得到的某一固定电压，在上文的分析中，我们把这个固定电压设置为2V，在这里我们调节滑动变阻器，获得一个2V的电压提供给运放-（负）极即可。<br><a href="https://www.eefocus.com/e/508731">灰度传感器与红外传感器的介绍</a><br><a href="https://item.taobao.com/item.htm?spm=a230r.1.14.151.78fe2ed1yarCIX&id=593277124077&ns=1&abbucket=14#detail">八路传感器的介绍</a><br><a href="https://blog.csdn.net/ycznjust/article/details/124309824">传感器原理图参考</a><br><a href="https://blog.csdn.net/lmf666/article/details/126084700">LM393灰度传感器</a><br><a href="http://www.360doc.com/content/22/0730/21/11955020_1042010929.shtml">LM339参考文章</a><br><a href="https://www.semiee.com/file/TI/TI-LM339.pdf">LM339-Datasheet</a><br><a href="https://blog.51cto.com/liucw/1155420">嵌入式硬件基础</a><br><a href="https://blog.csdn.net/weixin_30851409/article/details/96397517?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166159776316782388033825%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166159776316782388033825&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-96397517-null-null.142%5Ev42%5Epc_rank_34_ctr25,185%5Ev2%5Econtrol&utm_term=%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8%E5%92%8C%E7%81%B0%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB&spm=1018.2226.3001.4187">对红外灰度传感器的理解</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传感器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>msp432p401r-pcb</title>
      <link href="/2022/08/12/34h-msp432p401r-pcb/"/>
      <url>/2022/08/12/34h-msp432p401r-pcb/</url>
      
        <content type="html"><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>1.msp供电vcc是接DVcc接3.3v， DVss接地<br>2.为什么大佬们画的板子上JTAG接口引脚与jlink上的不一样</p><blockquote><p>因为他们画的是msp430仿真器的JTAG<br>JLINK的JTAG引脚图</p></blockquote><p>msp430的JTAG引脚图</p><h3 id="JTAG调试的引脚介绍"><a href="#JTAG调试的引脚介绍" class="headerlink" title="JTAG调试的引脚介绍"></a>JTAG调试的引脚介绍</h3><p>JTAG 调试用到了 TCK、TMS、TDI、TDO 和 TRST 这几个脚。</p><ul><li>其中 TRST 是用来对 TAP controller进行复位的，它不是必须的。通过在 TMS脚也可以使 TAP controller复位。</li><li>Test Clock Input (TCK)</li><li>TCK为 TAP的操作提供了一个独立的、基本的时钟信号，TAP 的所有操作都是通过这个时钟信号来驱动的。TCK在 IEEE 1149.1 标准里是强制要求的。</li><li>Test Mode Selection Input (TMS)</li><li>TMS信号用来控制 TAP状态机的转换。通过 TMS信号，可以控制 TAP在不同的状态间相互转换。TMS信号在 TCK的上升沿有效。TMS在 IEEE 1149.1 标准里是强制要求的。</li><li>Test Data Input (TDI)</li><li>TDI 是数据输入的接口。所有要输入到特定寄存器的数据都是通过 TDI 接口一位一位串行输入的（由 TCK驱动）。TDI在 IEEE 1149.1 标准里是强制要求的。</li><li>Test Data Output (TDO)</li><li>TDO 是数据输出的接口。所有要从特定的寄存器中输出的数据都是通过 TDO 接口一位一位串行输出的（由 TCK驱动）。TDO在 IEEE 1149.1 标准里是强制要求的。</li><li>Test Reset Input (TRST)</li><li>TRST 可以用来对 TAP Controller 进行复位（初始化）。不过这个信号接口在 IEEE 1149.1标准里是可选的，并不是强制要求的。因为通过 TMS也可以对 TAP Controller进行复位（初始化</li></ul><h2 id="晶振"><a href="#晶振" class="headerlink" title="晶振"></a>晶振</h2><h3 id="晶振的封装"><a href="#晶振的封装" class="headerlink" title="晶振的封装"></a>晶振的封装</h3><p>晶振的封装分为SMD贴片晶振和DIP插件晶振</p><p>MHz贴片晶体有如下尺寸：</p><img src="/2022/08/12/34h-msp432p401r-pcb/05.jpg" class=""><p>\1. SMD1612 - 尺寸1.6x1.2mm</p><p>- 小型化的贴片晶体KX16，频率范围是24MHz<del>54MHz，负载电容可选8</del>32pF；</p><p>- 温补晶振KT16CS，削峰正弦波输出，频率范围是13MHz ~ 52MHz，可选择1.8V~2.5V工作电压。</p><p>\2. SMD2016 - 尺寸2.0x1.6mm</p><p>- 贴片晶体KX20, 频率范围20MHz<del>54MHz, 负载电容可选8</del>32pF;</p><p>- 贴片晶振KS20，频率范围1MHz<del>54MHz， 工作电压可选1.8V</del>3.3V;</p><p>- 温补晶振KT20CS，削峰正弦波输出, 频率范围10MHz<del>52MHz,工作电压可选1.8V</del>3.3V，可选是否有电压调整。</p><p>\3. SMD2520 - 尺寸2.5x2.0mm</p><p>- 贴片谐振器KX25, 频率范围12MHz~60MHz，应用于消费类和工业类产品，小体积，低成本；</p><p>- 贴片时钟振荡器： 普通晶振KS25；低抖动晶振KJ25； 差分晶振KD256D&#x2F;KD256C为6引脚LVDS和HCSL输出；</p><p>- 压控晶振KV25，频率范围4MHz~50MHz；</p><p>- 温补晶振KT25CS, 削峰正弦波输出</p><p>\4. SMD3225 - 尺寸3.2x2.5mm</p><p>- 主流晶振的封装, 从谐振器到温补晶振都有3225贴片封装。多款特种晶振可供选择：低频khz，差分输出，低抖动，可编程晶振，超高频晶振等等。</p><p>\5. SMD5032 - 尺寸5.0x3.2mm</p><p>- 5032是主流晶振封装，在SMD3225特种晶振的选择上，还有防电磁干扰晶振KM50；</p><p>\6. SMD6035 - 尺寸6.0x3.5mm</p><p>- 目前市场上不常见，各大厂商已经停止6035的产线.</p><p>\7. SMD7050 - 尺寸7.0x5.0mm</p><p>- 7050晶振是应用比较广泛的尺寸，有多种特性晶振可供选择。</p><p>kHz贴片晶体有如下尺寸：</p><img src="/2022/08/12/34h-msp432p401r-pcb/06.jpg" class=""><p>- 型号分别为KX2012, KX3215, KX3880, KX7015</p><p>02直插晶振</p><p>\1. 插件封装 DIP08&#x2F;DIP14</p><img src="/2022/08/12/34h-msp432p401r-pcb/07.jpg" class=""><p>- 时钟振荡器KS08 (13.2x13.2mm) KS14 (20.3x13.2mm)</p><p>- 压控晶振KV08&#x2F;KV14&#x2F;KV14S</p><p>- 温补晶振KT14&#x2F;KT14S</p><p>\2. HC-49S&#x2F;M&#x2F;U</p><img src="/2022/08/12/34h-msp432p401r-pcb/08.jpg" class=""><p>- HC-49S晶振封装尺寸10.5<em>3.5</em>3.8mm, 频率范围3.5MHz~80MHz</p><p>- HC-49SMD晶振封装尺寸13<em>4.8</em>4mm，又叫做假贴晶振，是49S直插改型而来的；</p><p>- HC-49U晶振封装尺寸：11.05*4.65.13.46mm，频率范围1.8MHz~210MHz。</p><p>\3. 圆柱晶体</p><img src="/2022/08/12/34h-msp432p401r-pcb/09.jpg" class=""><p>- 1.0φx4.0仅有kHz频率： KX1040的频率为32.768kHz；</p><p>- 2.0φx6.0有kHz和MHz：KX2060频率范围25k<del>200kHz；KX26频率为12M</del>30MHz；</p><p>- 3.0φx8.0有kHz和MHz：KX3080频率范围25k<del>200kHz；KX38频率为4M</del>40MHz</p><p>我们知道，电子线路中的晶体振荡器分为无源晶振和有源晶振两种类型。无源晶振与有源晶振的英文名称不同，无源晶振为crystal（晶体），而有源晶振则叫做oscillator（振荡器）。<br>1.一般来说晶振是没有方向的<br>2.但晶振有分有源晶振跟无源晶振,有源晶振是有分方向的,但是大部份产品都是用的无源晶振。</p><h3 id="无源晶振"><a href="#无源晶振" class="headerlink" title="无源晶振"></a>无源晶振</h3><p>无源晶振是有2个引脚的无极性元件，需要借助于时钟电路才能产生振荡信号，自身无法振荡起来，所以“无源晶振”这个说法并不准确。</p><img src="/2022/08/12/34h-msp432p401r-pcb/03.png" class="" title="无源晶振参考电路"><p>无源晶振信号质量较差，通常需要精确匹配外围电路（用于信号匹配的电容、电感、电阻等），更换不同频率的晶体时周边配置电路也需要做相应的调整。<br>一般建议采用精度较高的石英晶体，尽可能不要采用精度低的陶瓷晶体。</p><h3 id="有源晶振"><a href="#有源晶振" class="headerlink" title="有源晶振"></a>有源晶振</h3><p>有源晶振有4只引脚，是一个完整的振荡器，其中除了石英晶体外，还有晶体管和阻容元件，因此体积较大。<br>有源晶振的封装有4个引脚，分别为VCC（电压）、GND（地）、OUT（时钟信号输出）、NC（空脚）。</p><p>有源晶振参考电路</p><img src="/2022/08/12/34h-msp432p401r-pcb/04.png" class="" title="无源晶振参考电路"><p>有源晶振不需要CPU的内部振荡器，信号稳定，质量较好，而且连接方式比较简单（主要做好电源滤波，通常使用一个电容和电感构成滤波网络，输出端用一个小阻值的电阻过滤信号即可），不需要复杂的配置电路。</p><h3 id="有源晶振和无源晶振的区别"><a href="#有源晶振和无源晶振的区别" class="headerlink" title="有源晶振和无源晶振的区别"></a>有源晶振和无源晶振的区别</h3><p>1、有源晶振比较贵，但是有源晶振自身就能震动<br>2、无源晶振最高精度为5ppm，而有源晶振的精度则可以达到0.1ppm。精度越高，频率稳定性也更好。有源晶振在稳定性上要胜过无源晶振，但有源晶振的信号电平是固定，所以需要选择好合适输出电平，灵活性较差。</p><p>3、有源晶振一般4个脚，一个电源，一个接地，一个信号输出端，一个NC（空脚）。有个点标记的为1脚，按逆时针（管脚向下）分别为2、3、4。<br>4、无源晶振有2个引脚，需要借助于外部的时钟电路（接到主IC内部的震荡电路）才能产生振荡信号，自身无法振荡。</p><p>晶振电路属于单片机心脏，精度非常重要，所以需要选择高Q值的元器件（Q值高电路选择性好）。<br>1、 选择NPO&#x2F;COG材质的电容（外观看起来是白色的）<br>2、 尽量选择小封装的电容（封装小的器件寄生参数小）</p><h2 id="相同值的电感的可以换封装吗"><a href="#相同值的电感的可以换封装吗" class="headerlink" title="相同值的电感的可以换封装吗"></a>相同值的电感的可以换封装吗</h2><p>不行!感量相同不代表电阻,电流也相同,4.7UH电流有0.05A-20A的要是型号不一样的话会烧坏电路板的”<br>通常在采用正电压的电路上：<br>　　VCC正电源电压<br>　　VSS电路地</p><p>　　AVCC正模拟电源电压<br>　　AVSS模拟电路地（模拟地）</p><p>　　DVCC正数字电源电压<br>　　DVSS数字电路地 （数字地）</p><p>　　AVCC&#x2F;AVSS一般为模拟部分提供电源<br>　　DVCC&#x2F;DVSS一般为数字部分和内部I&#x2F;O提供电源</p><p>为了避免引入电源干扰，通常需要把AVCC&#x2F;AVSS和DVCC&#x2F;DVSS隔离开。</p><h2 id="pcb画板规则"><a href="#pcb画板规则" class="headerlink" title="pcb画板规则"></a>pcb画板规则</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">电源线要宽于信号线,tx,rx尽量不要过孔,尽量在同一面上电容尽量靠近引脚,走线要先过电容模拟&amp;数字部分1、不同速度信号线要分开布线，最好不要在PCB板面垂直方向同时出现两种以上信号线在水平位置上重合。若需要重合，尽可能使得信号线之间的速度差尽可能少，并且尽可能减少重合面积（例如：低速和中速信号线重合、中速和高速信号线重合、低速和高速信号线重合需谨慎考虑）2、PCB不同部分不同种类电路分区布线，无特殊要求下用地隔离（部分射频电路发射端不能铺铜，具体参照IC文档说明）。3、不建议在高速信号线上走一些元器件（例如大封装元器件下边布线），如果是在低速信号线上的元器件，则低速信号线很可能会被高速信号线干扰。4、0欧电阻可以当导线用。5、晶振比较特殊，是干扰源也是敏感源，一般晶振下方不走信号线并且周围铺地隔离。6、光耦、继电器、天线等等处理方法和第5条相同，原因差不多7、热敏元器件尽可能远离大功率，要散热的元器件（如电源电路上的电感MOS管等）。8、可以的话，不建议芯片上的多个VCC引脚共用一个滤波电容。9、芯片上不同的接地引脚，尽量不要全部通过同一个过孔接到地上，单独分开更好。10、AGND和DGND单点相连。11、芯片引脚焊盘比线宽的情况下，尽量不要让焊盘和线连接处宽度突变，做成斜渐变或者圆弧更好。12、区分好IC的DVCC和AVCC，不要直接在同一输出的电源端供电。省事的办法是：可以电源输出端直接给DVCC部分供电，然后再电源输出端过一个共模电感电路（或者就一个电感也可以）给AVCC部分供电，DGND和AGND同样隔离的方法。要求低的请忽略此条。13、如果分开了AVCC和DVCC层的时候，不要把AVCC错位到DGND上面或者DVCC错位到AGND上面，会有耦合电容。就是AVCC下方必须时AGND，DVCC下方必须是DGND。14、敏感电路请远离电感。15、敏感电路请远离I&#x2F;O口。16、过孔之间距离大于5mil，过孔到铜箔之间距离大于5mil。电源部分1、不同功率的电路务必相互分开隔离（强电和弱电要隔离开来），模拟、数字、电源电路都要隔离开来，必要时要使0欧电阻甚至是磁珠等把不同电路的地隔离开来（模拟地、数字地、功率地）。2、要求高的PCB，一般有电源层和地线层。使用双面板对要求低和成本低的请忽略此条。3、考虑散热的PCB，要参考PCB安装固定地方的空气流通路线、风口设计散热（不要被大的元器件：大电容等挡住空气流通路线）。通过大面积铺铜，打散热孔，开窗、加装散热片、风扇等散热。4、满足前面要求的情况下，可以将供电的电路和被供电的电路放同一侧。5、不要把热量传递到数字、模拟电路上，必要时开槽防止热量和此类电路接触。6、在电源部分的电路中，电感封装选型要考虑PCB设计时要过多少的电流I,然后电感的额定电流Irms与I的关系最好是：I&lt;Irms*0.87、一般，输入端的小电容要靠近芯片，输出端的小电容远离芯片。8、非屏蔽电感会有漏磁，注意回避敏感电路，实在不行就用屏蔽电感。9、电源IC的VO和FB引脚走线避开与该路无关的二极管和电感，不要和电感线路平行。10、在电感引脚铺的铜或者线路不要靠太近，寄生电容会有点大。11、输入滤波CI电容（输入端的电容）对称放置会减少一点磁场影响。12、电源芯片SW引脚的线路面积不要做太大（小一点好）。13、矩形波回路的回路面积尽可能小一点。14、一个电源（LDO、开关也是）芯片的电路，配套的电容要尽可能靠近芯片。15、输入端线路要完全通过输入电容再进入芯片。（即输入端布线要完完全全从电容焊盘上方走过，可以线路比电容焊盘小一点）同样，输出端线路要完全通过输出电容再进入后面负载。16、电源反馈电路的反馈信号要在输出电容靠近后续负载的一端获得。17、输出端若需要过孔，建议过孔在电容后面。18、尽可能把输入和输出（电容、电阻......）所接的地时接到同一块地上。19、IC的散热地面积尽可能大一点。20、IC反馈电路上的电阻尽可能靠近IC，FB引脚线路覆盖面积小一点好（走线细而且短）尽量不与电感平行。21、BUCK芯片输入端可以加一个1μH电感，输出端加一个磁珠（小功率）可以抑制一定EMI。22、CI电容尽可能靠近Vin引脚是为了减少di&#x2F;dt回路面积，减少辐射EMI，如果CI集成到芯片内部就更好。23、关于FB分压电阻、COMP、SS连接到同一块地，然后单点与PGND相连或者通过过孔到背面地。24、如果不使用非一体成型电感，环绕电感一周铺地的同时预留一定空位挖空一周。25、Vout、FB走线请远离一下电感。26、CI和CO两个电容的地端，不要直接接在同一个地上。单过孔到另外一块地上。（和电感相连的电容纹波比较少，不相连的纹波比较大，直降相连的话输出纹波会变大。）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/weixin_48584490/article/details/123123214">参考文章</a></p><p>[晶振封装参考](<a href="https://www.sohu.com/a/486097858_120774276">常用的晶振尺寸有哪些?_mm (sohu.com)</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 芯片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC协议</title>
      <link href="/2022/08/11/33h-iic-xie-yi/"/>
      <url>/2022/08/11/33h-iic-xie-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="IIC-简介"><a href="#IIC-简介" class="headerlink" title="IIC 简介"></a>IIC 简介</h2><p>IIC总线时序图</p><img src="/2022/08/11/33h-iic-xie-yi/01.jpg" class="" width="01"><p>PS： 注意IIC是为了与低速设备通信而发明的，所以IIC的传输速率比不上SPI</p><h3 id="IIC的物理层"><a href="#IIC的物理层" class="headerlink" title="IIC的物理层"></a>IIC的物理层</h3><p>IIC一共有只有两个总线： 一条是双向的串行数据线ＳＤＡ，一条是串行时钟线ＳＣＬ<br>SDA(Serial data)是数据线，D代表Data也就是数据，Send Data 也就是用来传输数据的<br>SCL(Serial clock line)是时钟线，C代表Clock 也就是时钟 也就是控制数据发送的时序的</p><h3 id="为什么叫i2c总线"><a href="#为什么叫i2c总线" class="headerlink" title="为什么叫i2c总线"></a>为什么叫i2c总线</h3><blockquote><p>因为只需要单片机mcu的两个io一个作为scl,一个作为sda,所有元器件的scl都接到单片机的scl,同理所有元器件的sda都接到单片机的sda上,额可以节省很多io</p><img src="/2022/08/11/33h-iic-xie-yi/02.jpg" class="" title="IIC总线时序图"><img src="/2022/08/11/33h-iic-xie-yi/02.jpg" class="" width="02"><p>所有接到I2C总线设备上的串行数据SDA都接到总线的SDA上，各设备的时钟线SCL接<br>到总线的SCL上。I2C总线上的每个设备都自己一个唯一的地址，来确保不同设备之间访问的准确性。</p></blockquote><h3 id="单片机如何区分每一个元器件"><a href="#单片机如何区分每一个元器件" class="headerlink" title="单片机如何区分每一个元器件"></a>单片机如何区分每一个元器件</h3><p>单片机向scl总线发送一个包含从机地址的寻址字节,与该从机地址对应i2c器件,就会发送一个应答信号,建立连接<br>根据从机地址,是生产厂家所设置和规定的</p><img src="/2022/08/11/33h-iic-xie-yi/03.jpg" class="" width="03"><img src="/2022/08/11/33h-iic-xie-yi/03.jpg" class="" title="text"><img src="/2022/08/11/33h-iic-xie-yi/04.jpg" class="" width="04"><img src="/2022/08/11/33h-iic-xie-yi/04.jpg" class="" title="text"><p>前四位是固定的,后面三位是自己设置的,是A2,A1,A0的电平<br>方向位置0,表示主机对器件进行写操作,置为1,表示对器件进行读操作</p><img src="/2022/08/11/33h-iic-xie-yi/05.jpg" class="" width="05"><img src="/2022/08/11/33h-iic-xie-yi/05.jpg" class="" title="text"><p>7位从机地址加上一位方向位构成寻址字节</p><h3 id="单片机如何发送寻址字节"><a href="#单片机如何发送寻址字节" class="headerlink" title="单片机如何发送寻址字节"></a>单片机如何发送寻址字节</h3><p>由于只有一个SDA数据接口,所以只能一位一位的发送,所以是串行发送<br>单片机向24c02发送 1 0  1  0    0 0 0    0,寻址字节发送完毕,24c02接收到与自己从机地址相同的寻址字节,会给单片机发送一个应答信号,然后就可以传输数据了</p><img src="/2022/08/11/33h-iic-xie-yi/06.jpg" class="" width="06"><img src="/2022/08/11/33h-iic-xie-yi/06.jpg" class="" title="text"><p>一个存储单元为1b,也就是1个8位二进制数字</p><img src="/2022/08/11/33h-iic-xie-yi/07.jpg" class="" width="07"><img src="/2022/08/11/33h-iic-xie-yi/07.jpg" class="" title="text"><h3 id="I2C时序图"><a href="#I2C时序图" class="headerlink" title="I2C时序图"></a>I2C时序图</h3><p>MSB十数据的最高有效位</p><img src="/2022/08/11/33h-iic-xie-yi/08.jpg" class="" width="08"><img src="/2022/08/11/33h-iic-xie-yi/08.jpg" class="" title="text"><p>scl每经过一个方波周期,sda就发送一位数据</p><img src="/2022/08/11/33h-iic-xie-yi/09.jpg" class="" width="09"><img src="/2022/08/11/33h-iic-xie-yi/09.jpg" class="" title="text"><img src="/2022/08/11/33h-iic-xie-yi/10.jpg" class="" width="10"><img src="/2022/08/11/33h-iic-xie-yi/10.jpg" class="" title="text"><p>单片机要想发送信号,必须通过高脉冲信号的方式,也就是scl从低电平变为高电平,相当于向24c02发送一个采集信号,24c02收到采集信号后,会采集sda引脚的电平,如果为高电平,相当于给24c02发送一个1,反之相当于发送0</p><img src="/2022/08/11/33h-iic-xie-yi/11.jpg" class="" width="11"><img src="/2022/08/11/33h-iic-xie-yi/11.jpg" class="" title="text"><img src="/2022/08/11/33h-iic-xie-yi/12.jpg" class="" width="12"><img src="/2022/08/11/33h-iic-xie-yi/12.jpg" class="" title="text"><p>scl为低电平时,也就是没有采样前,sda可以改变,scl为高电平时,sda保持稳定,否则容易导致采样不准确,相当于拍照之前疯狂换姿势,结果照片糊了<br>一个scl高低电平的时间加在一起,就是一个时钟周期<br>发送完八位数据后,当第九个周期是,人为的将sda置为高电平,用来人为接收i2c器件产生的应答信号.当i2c器件产生因打信号后,就会把sda的电平拉置为低电平,然后用单片机判断sda的电平就可以了(while(sda&#x3D;&#x3D;1))</p><p><a href="https://www.bilibili.com/video/BV15d4y1D7jX/?spm_id_from=333.788&vd_source=e33ad22b3d91cb180bef532ce5877b2e">参考视频</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 芯片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32f407串口与tft输出adc</title>
      <link href="/2022/08/10/32h-stm32f407-adc/"/>
      <url>/2022/08/10/32h-stm32f407-adc/</url>
      
        <content type="html"><![CDATA[<h2 id="stm32f407ADC简介"><a href="#stm32f407ADC简介" class="headerlink" title="stm32f407ADC简介"></a>stm32f407ADC简介</h2><p>STM32F4xx 系列一般都有 3 个 ADC，这些 ADC 可以独立使用，也可以使用双重&#x2F;三重模式（提高采样率）。简单来说ADC就是将模拟量电压转换为数字量的工具，F4的12 位 ADC 是逐次趋近型模数转换器。有19 个复用通道，可测量来自16 个外部源、两个内部源和 VBAT 通道的信号。这些通道的 A&#x2F;D 转换可在单次、连续、扫描或不连续采样模式下进行。ADC采样的结果存储在一个左对齐或右对齐的 16 位数据寄存器中。ADC 具有模拟看门狗特性——允许应用检测输入电压是否超过了用户自定义的阈值上限或下限。</p><blockquote><p>STM32F407ZGT6 包含有 3 个 ADC。STM32F4 的 ADC 最大的转换速率为 2.4Mhz，也就是转换时间为 1us（在 ADCCLK&#x3D;36M,采样周期为 3 个 ADC 时钟下得到），不要让 ADC 的时钟超过 36M，否则将导致结果准确度下降。</p></blockquote><blockquote><p>STM32F4 将 ADC 的转换分为 2 个通道组：规则通道组和注入通道组。规则通道相当于你<br>正常运行的程序，而注入通道呢，就相当于中断。在你程序正常执行的时候，中断是可以打断<br>你的执行的。同这个类似，注入通道的转换可以打断规则通道的转换， 在注入通道被转换完成<br>之后，规则通道才得以继续转换。</p></blockquote><blockquote><p>STM32F4 的 ADC 在单次转换模式下，只执行一次转换，该模式可以通过 ADC_CR2 寄存<br>器的 ADON 位（只适用于规则通道）启动，也可以通过外部触发启动（适用于规则通道和注入<br>通道），这时 CONT 位为 0</p></blockquote><p>STM32F407内部有两个ADC模块，彼此独立可进行同步采样；<br>外部16个通道（GPIO0~15）采样精度默认为12位；<br>转换时间&#x3D;采样时间+转换周期&#x3D;1.5+12.5&#x3D;14周期；</p><h3 id="工作过程分析"><a href="#工作过程分析" class="headerlink" title="工作过程分析"></a>工作过程分析</h3><p>ADC转换是把外面输入到引脚的电压值转换成数字信号，(而DAC则是把设定的数字信号转化成电压值输出到引脚)单片机里面有一个模拟至数字的转换模块，我们可以控制它采集引脚的电压，stm32F407可以利用void ADC_SoftwareStartConv（ADC_TypeDef* ADCx）这个函数来控制转换。</p><h3 id="三种实现方法："><a href="#三种实现方法：" class="headerlink" title="三种实现方法："></a>三种实现方法：</h3><blockquote><p>1.使用定时器中断每隔一定时间进行ADC转换，这样每次都必须读ADC的数据寄存器，非常浪费时间；<br>2.把ADC设置成连续转换模式，同事对应的DMA通道开启循环模式，这样ADC就一直在进行数据采集然后通过DMA把数据搬运至内存。再加一个定时中断，用来定时读取内存中的数据。<br>3.使用ADC的定时器触发ADC转换的功能，然后使用DMA进行数据的搬运，这样只要设置好定时器的触发间隔，就能实现ADC定时采样转换的功能，然后可以在程序的死循环中一直检测DMA转换完成标志，然后进行数据的读取，或者使能DMA转换完成中断，这样每次转换完成就会产生中断。</p></blockquote><p>ADC上电开启到稳定需要一段时间。ADC外设上电，使能ADC功能，启动ADC转换，实质AD转换是不一样的动作和不同的时间点。<br>先校准再开启ADC的DMA功能。<br>在多通道ADC DMA传输时，经常出现因为缓冲区数据类型，源数据类型不一致导致的异常状况。</p><h3 id="ADC的供电及采样电压"><a href="#ADC的供电及采样电压" class="headerlink" title="ADC的供电及采样电压"></a>ADC的供电及采样电压</h3><p>ADC 电源要求：全速运行时为 2.4 V 到 3.6 V，慢速运行时为 1.8 V。<br>ADC 输入范围：VREF-   \leq  VIN  \leq  VREF+ , 并且VREF- 如果可用（取决于封装），则必须将其连接到 VSSA。而通常我们将VREF+与VDDA连接，F407的芯片引脚当中VSS、VDD引脚并不容忍5V供电，而ADC的采集引脚很多可以容忍5V，所以通常情况下，ADC采集的范围在0-3.3V。</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><blockquote><p>通过设置ADC1的三个通道采样顺序并且开启DMA相对应的通道，对数据寄存器当中每一次的采样值（对应每个通道的外部电压转换值）进行收集，并传递到CPU的内部寄存器当中，再对电压值进行串口输出</p></blockquote><h2 id="F407在ADC实验中使用的函数理解"><a href="#F407在ADC实验中使用的函数理解" class="headerlink" title="F407在ADC实验中使用的函数理解"></a>F407在ADC实验中使用的函数理解</h2><h3 id="非DMA的相关函数"><a href="#非DMA的相关函数" class="headerlink" title="非DMA的相关函数"></a>非DMA的相关函数</h3><h3 id="有关DMA的相关函数"><a href="#有关DMA的相关函数" class="headerlink" title="有关DMA的相关函数"></a>有关DMA的相关函数</h3><p>待更新….</p><h2 id="STM32F407的ADC的基础知识"><a href="#STM32F407的ADC的基础知识" class="headerlink" title="STM32F407的ADC的基础知识"></a>STM32F407的ADC的基础知识</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">　　1，ADC是12位逐次逼近型模拟数字转换器。　　2，ADC的时钟不超过36MHz。　　3，STM32F407的ADC的最小转换时间为0.41us。　　4，STM32F407将ADC的转换分为2个通道组：规则通道组和注入通道组　　　　因为规则组和注入组，我们不需要在切换AD循环扫描的通道时，重新配置AD循环扫描的通道。（某MCU就只有单次ADC扫描，切换通道时，需要重新配置ADC寄存器）　　5，有规则通道组和注入通道组的ADC外设，使MCU能在某些需要快速检测和监视的领域（如工控应用），有了优势。　　6，当使用ADC的连续模式时，建议采样DMA模式。　　7，当使用ADC的单次模式时，只进行一次转换。　　8，ADC相邻两个采样阶段之间的时间间隔是延时5个时钟-20个时钟（例如，在1ms单位时间内，延时时间越少，在采样次数越多。）　　9，对于每个要转换的通道，采样时间影响了转换结果的准确度和ADC的转换速率。采样时间越长，转换结果准确度越高，ADC的转换速率越低。　　　　ADC转换时间 &#x3D; 采样时间（3~480个ADCCLK周期） + 12个ADCCLK周期　　10，STM32F407的ADC触发极性分为四种：（1）禁止触发检测、（2）在上升沿时检测、（3）在下降时检测、（4）在上升和下降时均检测。　　　　当使用第（1）时，表示使用软件转换，我在开发中最常用这个；当使用第（2）（3）（4）时，表示使用事件来启动转换。　　11，STM32F407的ADC的分辨率有四档：6、8、10、12位。ADC的分辨率影响ADC的转换时间。　　12，如果已经使能了一个PORT的时钟，那么该PORT的时钟，不能再被使能。二，ADC实验：　　1，使用ADC1的通道PA5时，需要使能：GPIOA时钟、ADC1时钟。　　2，设置PA5为：不带上下拉电阻；模拟输入（将GPIO用于ADC采样的通道，需要设置为模拟输入，输入电压不超过3.3V）。　　3，STM32F407开发板的ADC的正模拟参考电压接的是3.3V，负模拟参考电压接的是GND。　　4，当硬件ADC开始进行转换之后，我们可以根据判断转换结束标志位是否被置一来判断是否跳出死循环。　　　　（1）当在等待ADC转换结束期间，死循环可被中断给打断，以便系统可运行其他更高需要实时处理的事件。　　　　（2）硬件ADC的转换过程，是不会被应用软件给打断的。,　　5，测试ADC1的PA5的连续转换模式，使用DMA？　　　　应用：对一阵列的传感器进行信号采集　　6，利用ADC1来测试温度传感器、内部参考电压、BAT电压？<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/weixin_30443075/article/details/99765337?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-99765337-blog-119870392.t0_eslanding_v1&spm=1001.2101.3001.4242.1&utm_relevant_index=3">参考文章</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="ADC-c"><a href="#ADC-c" class="headerlink" title="ADC.c"></a>ADC.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;初始化ADC   void  Adc_Init(void)&#123;      GPIO_InitTypeDef  GPIO_InitStructure;ADC_CommonInitTypeDef ADC_CommonInitStructure;ADC_InitTypeDef       ADC_InitStructure;  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);&#x2F;&#x2F;使能GPIOA时钟  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); &#x2F;&#x2F;使能ADC1时钟  &#x2F;&#x2F;先初始化ADC1通道5 IO口  GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_5;&#x2F;&#x2F;PA5 通道5  GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AN;&#x2F;&#x2F;模拟输入  GPIO_InitStructure.GPIO_PuPd &#x3D; GPIO_PuPd_NOPULL ;&#x2F;&#x2F;不带上下拉  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);&#x2F;&#x2F;初始化   RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1,ENABLE);  &#x2F;&#x2F;ADC1复位RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1,DISABLE);&#x2F;&#x2F;复位结束    ADC_CommonInitStructure.ADC_Mode &#x3D; ADC_Mode_Independent;&#x2F;&#x2F;独立模式  ADC_CommonInitStructure.ADC_TwoSamplingDelay &#x3D; ADC_TwoSamplingDelay_5Cycles;&#x2F;&#x2F;两个采样阶段之间的延迟5个时钟  ADC_CommonInitStructure.ADC_DMAAccessMode &#x3D; ADC_DMAAccessMode_Disabled; &#x2F;&#x2F;DMA失能  ADC_CommonInitStructure.ADC_Prescaler &#x3D; ADC_Prescaler_Div4;&#x2F;&#x2F;预分频4分频。ADCCLK&#x3D;PCLK2&#x2F;4&#x3D;84&#x2F;4&#x3D;21Mhz,ADC时钟最好不要超过36Mhz   ADC_CommonInit(&amp;ADC_CommonInitStructure);&#x2F;&#x2F;初始化  ADC_InitStructure.ADC_Resolution &#x3D; ADC_Resolution_12b;&#x2F;&#x2F;12位模式  ADC_InitStructure.ADC_ScanConvMode &#x3D; DISABLE;&#x2F;&#x2F;非扫描模式  ADC_InitStructure.ADC_ContinuousConvMode &#x3D; DISABLE;&#x2F;&#x2F;关闭连续转换  ADC_InitStructure.ADC_ExternalTrigConvEdge &#x3D; ADC_ExternalTrigConvEdge_None;&#x2F;&#x2F;禁止触发检测，使用软件触发  ADC_InitStructure.ADC_DataAlign &#x3D; ADC_DataAlign_Right;&#x2F;&#x2F;右对齐  ADC_InitStructure.ADC_NbrOfConversion &#x3D; 1;&#x2F;&#x2F;1个转换在规则序列中 也就是只转换规则序列1   ADC_Init(ADC1, &amp;ADC_InitStructure);&#x2F;&#x2F;ADC初始化 ADC_Cmd(ADC1, ENABLE);&#x2F;&#x2F;开启AD转换器&#125;  &#x2F;&#x2F;获得ADC值&#x2F;&#x2F;ch: @ref ADC_channels &#x2F;&#x2F;通道值 0~16取值范围为：ADC_Channel_0~ADC_Channel_16&#x2F;&#x2F;返回值:转换结果u16 Get_Adc(u8 ch)   &#123;  &#x2F;&#x2F;设置指定ADC的规则组通道，一个序列，采样时间ADC_RegularChannelConfig(ADC1, ch, 1, ADC_SampleTime_480Cycles );&#x2F;&#x2F;ADC1,ADC通道,480个周期,提高采样时间可以提高精确度      ADC_SoftwareStartConv(ADC1);&#x2F;&#x2F;使能指定的ADC1的软件转换启动功能 while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC ));&#x2F;&#x2F;等待转换结束return ADC_GetConversionValue(ADC1);&#x2F;&#x2F;返回最近一次ADC1规则组的转换结果&#125;&#x2F;&#x2F;获取通道ch的转换值，取times次,然后平均 &#x2F;&#x2F;ch:通道编号&#x2F;&#x2F;times:获取次数&#x2F;&#x2F;返回值:通道ch的times次转换结果平均值u16 Get_Adc_Average(u8 ch,u8 times)&#123;u32 temp_val&#x3D;0;u8 t;for(t&#x3D;0;t&lt;times;t++)&#123;temp_val+&#x3D;Get_Adc(ch);delay_ms(5);&#125;return temp_val&#x2F;times;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>3 个函数，Adc_Init 函数用于初始化 ADC1。这里我们仅开通了 1 个通道，即通道 5。第二<br>个函数 Get_Adc，用于读取某个通道的 ADC 值，例如我们读取通道 5 上的 ADC 值，就可以通<br>过 Get_Adc（ADC_Channel_5）得到。最后一个函数 Get_Adc_Average，用于多次获取 ADC 值，<br>取平均，用来提高准确度。</p></blockquote><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;sys.h&quot;#include &quot;delay.h&quot;#include &quot;usart.h&quot;#include &quot;led.h&quot;#include &quot;adc.h&quot;#include &quot;lcd_init.h&quot;#include &quot;lcd.h&quot;#include &quot;pic.h&quot;#include &quot;timer.h&quot;&#x2F;&#x2F;              ----------------------------------------------------------------&#x2F;&#x2F;              GND    电源地&#x2F;&#x2F;              VCC  接5V或3.3v电源&#x2F;&#x2F;              SCL   PG12（SCLK）&#x2F;&#x2F;              SDA   PD5（MOSI）&#x2F;&#x2F;              RES   PD4&#x2F;&#x2F;              DC    PD15&#x2F;&#x2F;              CS    PD1&#x2F;&#x2F;              BLK   PE8&#x2F;&#x2F;              ----------------------------------------------------------------&#x2F;&#x2F;更新日期 2022 08 17&#x2F;*问题1.无法读出小数部分解决:lcd函数的问题,更换了lcd的库所以函数功能改变,原来的显示小数功能的函数不适用了原函数无法直接显示小数,所以通过将小数转换成整数显示,改后的函数可直接显示小数2.printf使用报错,usart senddata发送,串口助手不显示main.c(72): error:  #167: argument of type &quot;int&quot; is incompatible with parameter of type &quot;const char *restrict&quot;解决:因为print(&#39;adc:&#39;)用了单引号3.只显示adc不显示数据解决:没加f%是时候补一补c语言了*&#x2F;int main(void)&#123;  u16 adcx;float temp;NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);&#x2F;&#x2F;设置系统中断优先级分组2delay_init(168);    &#x2F;&#x2F;初始化延时函数uart_init(115200);&#x2F;&#x2F;初始化串口波特率为115200LED_Init();&#x2F;&#x2F;初始化LED  LCD_Init();         &#x2F;&#x2F;初始化LCD接口Adc_Init();         &#x2F;&#x2F;初始化ADC&#x2F;&#x2F;POINT_COLOR&#x3D;RED;   &#x2F;&#x2F;float t&#x3D;0;delay_init(168);LED_Init();&#x2F;&#x2F;LED初始化LCD_Init();&#x2F;&#x2F;LCD初始化LCD_Fill(0,0,LCD_W,LCD_H,WHITE);LED0&#x3D;0;    LCD_ShowChinese(0,10,&quot;Increaseing Nun:&quot;,RED,WHITE,16,0);LCD_ShowString(0,20,&quot;Explorer STM32F4&quot;,RED,WHITE,16,0);LCD_ShowString(0,40,&quot;ADC TEST&quot;,RED,WHITE,16,0);LCD_ShowString(0,60,&quot;ATOM@ALIENTEK&quot;,RED,WHITE,16,0);    LCD_ShowString(0,100, &quot;ADC1_CH5_VAL:&quot;,RED,WHITE,16,0);    LCD_ShowString(0,120,&quot;ADC1_CH5_VOL:0.000V&quot;,RED,WHITE,16,0);LCD_ShowString(0,80,&quot;2014&#x2F;5&#x2F;6&quot;,RED,WHITE,16,0);while(1)&#123; adcx&#x3D;Get_Adc_Average(ADC_Channel_5,20);  &#x2F;&#x2F;获取通道5的转换值，20次取平均                                             &#x2F;&#x2F;显示ADCC采样后的原始值    LCD_ShowIntNum(110,100,adcx,3,RED,WHITE,16);temp&#x3D;(float)adcx*(3.3&#x2F;4096);            &#x2F;&#x2F;获取计算后的带小数的实际电压值，比如3.1111&#x2F;&#x2F;adcx&#x3D;temp;                            &#x2F;&#x2F;赋值整数部分给adcx变量，因为adcx为u16整形                                            &#x2F;&#x2F;显示电压值的整数部分，3.1111的话，这里就是显示3&#x2F;&#x2F;  LCD_ShowIntNum(104,120,adcx,1,RED,WHITE,16);&#x2F;&#x2F;temp-&#x3D;adcx;                           &#x2F;&#x2F;把已经显示的整数部分去掉，留下小数部分，比如3.1111-3&#x3D;0.1111&#x2F;&#x2F;temp*&#x3D;1000;                           &#x2F;&#x2F;小数部分乘以1000，例如：0.1111就转换为111.1，相当于保留三位小数。&#x2F;&#x2F;  LCD_ShowxNum(150,150,temp,3,16,0X80);   &#x2F;&#x2F;显示小数部分（前面转换为了整形显示），这里显示的就是111.    LCD_ShowFloatNum1(104,120,temp,3,RED,WHITE,16);  &#x2F;&#x2F;120  120LED0&#x3D;!LED0;delay_ms(250);     printf(&quot;ADC:%f \r\n&quot;,temp);   &#x2F;&#x2F;  &#125;&#125;1.54tft屏和串口都可以输出adc的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这个程序将每隔 250ms 读取一次 ADC通道 5 的值，并显示读到的 ADC 值（数字量），以及其转换成模拟量后的电压值。同时控制 LED0闪烁，以提示程序正在运行。</p></blockquote><p><a href="https://blog.csdn.net/qq_59194050/article/details/119870392?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166013535816782391895979%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166013535816782391895979&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-119870392-null-null.142%5Ev40%5Epc_rank_v36,185%5Ev2%5Econtrol&utm_term=stm32f407%20adc&spm=1018.2226.3001.4187">参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32F407 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的稳压芯片</title>
      <link href="/2022/08/09/31h-ams1117/"/>
      <url>/2022/08/09/31h-ams1117/</url>
      
        <content type="html"><![CDATA[<h2 id="AMS1117"><a href="#AMS1117" class="headerlink" title="AMS1117"></a>AMS1117</h2><p>AMS1117是一款正电压输出的低压降三端线性稳压电<br>路，在1A输出电流下的压降为1.2V。<br>AMS1117分为两个版本，固定电压输出版本和可调电<br>压输出版本。固定输出电压1.5V、1.8V、2.5V、3.3V、<br>5.0V和可调版本的电压精度为1％；固定电压为1.2V的产<br>品输出电压精度为2％。<br>AMS1117内部集成过热保护和限流电路，适用于各类<br>电子产品。</p><h3 id="电路示例"><a href="#电路示例" class="headerlink" title="电路示例"></a>电路示例</h3><img src="/2022/08/09/31h-ams1117/01.png" class="" title="This is an test image"><img src="/2022/08/09/31h-ams1117/02.png" class="" title="This is an test image"><p>中间的上下两个输出引脚是一根线 </p><h3 id="滤波电容"><a href="#滤波电容" class="headerlink" title="滤波电容"></a>滤波电容</h3><blockquote><p>AMS1117官方文档里推荐的是输入接10uF，输出接20uF。<br>10微法滤低频，也可以再加个0.1.微法滤高频 (0.1uf≈104nf)<br>常用的方案是输入端接0.1UF，输出端接0.1UF+10UF两个电容，用于抑制自激振荡<br>输出滤波电容，用于抑制自激振荡。如果这两个电容不接，线性稳压器的输出通常会是一个振荡波形<br>输入端接电容的作用是防止断电后电压发生倒置，所以经常输入电容的容量要大于输出电容。</p></blockquote><blockquote><p>大电容滤低频，小电容虑高频。正常只需要一个大电容就可以了。在高频的时候大电容呈现感性，滤波效果很差，这时候就靠小电容起作用了！<br>阻抗公式Z&#x3D;1&#x2F;J2πfC。当电容大的时候，低频的信号对地阻抗很小，有波动的话都通过电容跑到了地上，这样就起到了去耦的作用。一般都是10u和0.1u搭配使用</p></blockquote><h3 id="发热问题"><a href="#发热问题" class="headerlink" title="发热问题"></a>发热问题</h3><p>…..</p><h3 id="type-c接口的cc1-cc2-协议暂时还不懂"><a href="#type-c接口的cc1-cc2-协议暂时还不懂" class="headerlink" title="type-c接口的cc1,cc2(协议暂时还不懂)"></a>type-c接口的cc1,cc2(协议暂时还不懂)</h3><p>CC1与CC2<br>USB-PD对电源设备的识别 是依靠这两个引脚的，向供电端请求电源供给。在简单的设计中，通过CC1和CC2各自独立 下拉一个5.1k电阻到地 即可。而对于需要用到大功率供电或者高清视频传输功能的嵌入式设计，则必须要使用USB-PD控制芯片。<br>DFP可根据两根CC线上的电压，判断是否已经插入设备。通过判断哪根CC线上有下拉电阻来判断方向</p><img src="/2022/08/09/31h-ams1117/03.png" class="" title="This is an test image"><p><a href="https://blog.csdn.net/AirCity123/article/details/103554177?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-103554177-blog-123307773.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-103554177-blog-123307773.pc_relevant_aa&utm_relevant_index=1"></a><br>16pin的那款是带数据传输功能的，6pin的那款只能用来供电，cc1和cc2独自接一个5.1k的电阻到地即可，不接这两个5.1k的电阻，会没办法识别那种两头都是typec的线<br>简单的电子产品不需要 USB 通信。所以在6Pin的版本中，仅保留了 VBUS、GND、CC1、CC2 这四类引脚,只能用来供电<br>个人理解:识别设备.进行供电</p><p>type-c相关资料<br><a href="https://blog.csdn.net/G_C_H/article/details/120500365">参考文章</a><br><a href="https://blog.csdn.net/weixin_43772512/article/details/123307773">参考文章</a><br><a href="https://blog.csdn.net/AirCity123/article/details/103554177?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-103554177-blog-123307773.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-103554177-blog-123307773.pc_relevant_aa&utm_relevant_index=1">参考文章</a></p><p><a href="https://www.semiee.com/file/Idchip/Idchip-AMS1117.pdf">AMS1117官方文档</a><br><a href="http://www.openedv.com/posts/list/34096.htm">参考文章1</a><br><a href="http://www.openedv.com/forum.php?mod=viewthread&tid=61468&highlight=AMS1117">参考文章2</a><br><a href="http://www.openedv.com/search.php?mod=forum&searchid=706&orderby=lastpost&ascdesc=desc&searchsubmit=yes&kw=AMS1117">参考文章3</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 稳压芯片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用arduino ide开发esp8266出现的error</title>
      <link href="/2022/07/29/30h-esp8266-error/"/>
      <url>/2022/07/29/30h-esp8266-error/</url>
      
        <content type="html"><![CDATA[<h2 id="抽风玄学"><a href="#抽风玄学" class="headerlink" title="抽风玄学"></a>抽风玄学</h2><p>正常烧录突然蹦出以下error<br>esp8266wifisecureclient.cpp&#x2F;.h 巴拉巴拉…..     找到报错处,注释掉<br>xxx多个库,闲置库xxxxx                             把重复未用的库删了(删除前最好备下份)<br>esp8266wifi.h:No such file or directory          最后报这一个错误</p><img src="/2022/07/29/30h-esp8266-error/01.png" class="" title="This is an test image"><h2 id="解决"><a href="#解决" class="headerlink" title="解决:"></a>解决:</h2><p>重新搭建esp8266环境<br>1.首选项中添加esp8266官方开发板网址</p><img src="/2022/07/29/30h-esp8266-error/02.png" class="" title="This is an test image"><p><a href="http://arduino.esp8266.com/stable/package_esp8266com_index.json">http://arduino.esp8266.com/stable/package_esp8266com_index.json</a><br>然后打开开发板管理器,搜索esp8266,删除后重新安装就不报错了</p><img src="/2022/07/29/30h-esp8266-error/03.png" class="" title="This is an test image"><img src="/2022/07/29/30h-esp8266-error/04.png" class="" title="This is an test image"><p><a href="https://blog.csdn.net/Reasally/article/details/123313509">参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Esp8266 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker的安装、卸载、迁移</title>
      <link href="/2022/07/26/29l-docker/"/>
      <url>/2022/07/26/29l-docker/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Docker、Docker-compose"><a href="#安装Docker、Docker-compose" class="headerlink" title="安装Docker、Docker-compose"></a>安装Docker、Docker-compose</h2><p>更新,安装vim</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">apt-get update &amp;&amp; apt-get install -y wget vim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>非大陆Docker安装:</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">wget -qO- get.docker.com | bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看Docker版本</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">docker -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开机自动启动</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">systemctl enable docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="error-安装Docker后启动失败-Failed-to-start-docker-service-Unit-not-found"><a href="#error-安装Docker后启动失败-Failed-to-start-docker-service-Unit-not-found" class="headerlink" title="error:安装Docker后启动失败,Failed to start docker.service: Unit not found."></a>error:安装Docker后启动失败,Failed to start docker.service: Unit not found.</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">运行docker-compose up -d报错,docker无法启动运行systemctl restart docker后,提示：Failed to start docker.service: Unit not found.在 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system 下创建 docker.socket 文件cd &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system vim docker.socket <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并写入：</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">[Unit]Description&#x3D;Docker Socket for the APIPartOf&#x3D;docker.service[Socket]ListenStream&#x3D;&#x2F;var&#x2F;run&#x2F;docker.sockSocketMode&#x3D;0660SocketUser&#x3D;rootSocketGroup&#x3D;docker[Install]WantedBy&#x3D;sockets.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但创建后仍然无法启动，提示：<code>Failed to start docker.service: Unit not found</code>，换另一种方式：</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">卸载现有版本Docker：yum remove dockeryumdocker-clientyum docker-client-latestyum docker-commonyum docker-latestyum docker-latest-logrotateyum docker-logrotateyum docker-engine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后重装Docker，启动完成，注意到原来的&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system目录下没有docker.socket与docker.service文件，重装后docker.service文件出现(大佬注意到的,我没注意观察)</p><p>有大佬说是因为版本问题</p><p><a href="https://ask.csdn.net/questions/7695921?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165876565016780357234520%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165876565016780357234520&biz_id=4&utm_medium=distribute.pc_search_result.none-task-ask_topic-2~all~first_rank_ecpm_v1~hot_rank-5-7695921-null-null.142%5Ev34%5Epc_rank_34,185%5Ev2%5Econtrol&utm_term=Failed%20to%20start%20docker.service:%20Unit%20not%20found.&spm=1018.2226.3001.4187">参考文章</a></p><h2 id="非大陆Docker-compose安装"><a href="#非大陆Docker-compose安装" class="headerlink" title="非大陆Docker-compose安装"></a>非大陆Docker-compose安装</h2><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.29.2&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composesudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composedocker-compose --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以下配置会增加一段自定义内网 IPv6 地址，开启容器的 IPv6 功能，以及限制日志文件大小，防止 Docker 日志塞满硬盘（泪的教训）：</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">cat &gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;EOF&#123;    &quot;log-driver&quot;: &quot;json-file&quot;,    &quot;log-opts&quot;: &#123;        &quot;max-size&quot;: &quot;20m&quot;,        &quot;max-file&quot;: &quot;3&quot;    &#125;,    &quot;ipv6&quot;: true,    &quot;fixed-cidr-v6&quot;: &quot;fd00:dead:beef:c0::&#x2F;80&quot;,    &quot;experimental&quot;:true,    &quot;ip6tables&quot;:true&#125;EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后重启 Docker 服务：</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>给Docker的数据、配置文件新建一个文件夹，</p><blockquote><p>mkdir -p data&#x2F;docker_data</p></blockquote><h2 id="docker项目更新"><a href="#docker项目更新" class="headerlink" title="docker项目更新"></a>docker项目更新</h2><p>以halo博客项目为例</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">docker stop halo           # 先停止容器,注意容器的名字docker rm -f halo          # 删除容器,容器的名字cp -r ~&#x2F;.halo ~&#x2F;.halo.archive   #&#96;!!!备份数据&#96;（非常非常非常重要），注意你挂载出来的路径地址rm -rf ~&#x2F;.halo&#x2F;.leveldb    # 这一步是halo特有的,其他项目不用docker pull halohub&#x2F;halo:1.5.3   # 拉取最新的镜像，一般的话你知道特定的版本号就直接写即可，比如这边的1.5.3，如果不知道版本号，可以直接写latest，即 docker pull halohub&#x2F;halo:latestdocker run -it -d --name halo -p 8090:8090 -v ~&#x2F;.halo:&#x2F;root&#x2F;.halo --restart&#x3D;unless-stopped halohub&#x2F;halo:1.5.3    # 重新运行容器 注意和搭建时候唯一不同的就是最后面的版本号不同，                                              #如果你是latest 那就把1.5.3改成latestdocker image prune # 删除掉旧的镜像（可选）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="docker-compose搭建的更新方法"><a href="#docker-compose搭建的更新方法" class="headerlink" title="docker-compose搭建的更新方法"></a>docker-compose搭建的更新方法</h2><p>以qbittorrent为例：</p><p>搭建命令：</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">cd ~mkdir -p &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;qBittorrent #创建qbitorrent数据文件夹cd &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;qBittorrentmkdir config downloads #创建配置文件目录与下载目录nano docker-compose.yml #创建并编辑文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>docker-compose.yml配置文件</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">version: &quot;2&quot;services:  qbittorrent:    image: linuxserver&#x2F;qbittorrent:4.4.0    container_name: qbittorrent    environment:      - PUID&#x3D;1000      - PGID&#x3D;1000      - TZ&#x3D;Asia&#x2F;Shanghai # 你的时区      - UMASK_SET&#x3D;022      - WEBUI_PORT&#x3D;8081 # 将此处修改成你欲使用的 WEB 管理平台端口     volumes:      - &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;qBittorrent&#x2F;config:&#x2F;config # 绝对路径请修改为自己的config文件夹      - &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;qBittorrent&#x2F;downloads:&#x2F;downloads # 绝对路径请修改为自己的downloads文件夹    ports:      # 要使用的映射下载端口与内部下载端口，可保持默认，安装完成后在管理页面仍然可以改成其他端口。      - 6881:6881       - 6881:6881&#x2F;udp      # 此处WEB UI 目标端口与内部端口务必保证相同，见问题1      - 8081:8081    restart: unless-stopped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更新方法：</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">docker-compose pull     # 注意到上方docker-compose.yml里面linuxserver&#x2F;qbittorrent后面有版本号4.4.0，                        #（如果没有默认就是latest），所以更新需要修改版本号为新的版本号（更新到特定版本），或者直接删去现在的版本号（更新到最新版本）cp -r qBittorrent qBittorrent.archive    # 备份一下,也可以直接备份配置文档，因为有些时候，downloads里面文件很浪费空间 docker-compose up -d   #完成docker image prune # 删除掉旧的镜像（可选）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="docker迁移"><a href="#docker迁移" class="headerlink" title="docker迁移"></a>docker迁移</h2><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">tar -czvf .halo.tar.gz .halo.archive   #文件的备份压缩scp -P 22 -r .halo.tar.gz root@192.248.190.156:&#x2F;root  # scp -P 端口 -r &#x2F;root&#x2F;backup&#x2F;backup.tar 用户名@IP:目标目录tar -zxvf .halo.tar.gz                #解压mv .halo.archive .halo                #把.halo.archive重命名成.halo确保迁移到的服务器有docker和docker compose环境执行容器&#96;docker-compose up -d &#96;如果无法完全启动,将&#96;docker-compose.yml&#96;删除,重建后再运行&#96;docker-compose up -d&#96;(docker-compose搭建的lsky-pro迁移成功)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Docker项目卸载（包括卸载Docker、docker-compose）"><a href="#Docker项目卸载（包括卸载Docker、docker-compose）" class="headerlink" title="Docker项目卸载（包括卸载Docker、docker-compose）"></a>Docker项目卸载（包括卸载Docker、docker-compose）</h2><h3 id="docker命令搭建的常用卸载方法"><a href="#docker命令搭建的常用卸载方法" class="headerlink" title="docker命令搭建的常用卸载方法"></a>docker命令搭建的常用卸载方法</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">docker ps docker stop 容器名字cd ~docker rm -f 容器名字rm -rf 映射出来的路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="docker-compose搭建的卸载方法"><a href="#docker-compose搭建的卸载方法" class="headerlink" title="docker-compose搭建的卸载方法"></a>docker-compose搭建的卸载方法</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">cd &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;qBittorrentdocker-compose down cd ~rm -rf &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;qBittorrent # rm -rf 映射出来的路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="卸载docker本身"><a href="#卸载docker本身" class="headerlink" title="卸载docker本身"></a>卸载docker本身</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-compose-pluginsudo rm -rf &#x2F;var&#x2F;lib&#x2F;dockersudo rm -rf &#x2F;var&#x2F;lib&#x2F;containerd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<a href="https://docs.docker.com/engine/install/debian/">https://docs.docker.com/engine/install/debian/</a></p><h3 id="卸载docker-compose"><a href="#卸载docker-compose" class="headerlink" title="卸载docker-compose"></a>卸载docker-compose</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">cd &#x2F;usr&#x2F;local&#x2F;bin&#x2F;rm -rf docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.docker.com/engine/install/debian/">https://docs.docker.com/engine/install/debian/</a></p><p><a href="https://www.runoob.com/linux/linux-comm-scp.html">https://www.runoob.com/linux/linux-comm-scp.html</a></p><p><a href="https://www.runoob.com/linux/linux-comm-tar.html">https://www.runoob.com/linux/linux-comm-tar.html</a></p><p><a href="https://docs.halo.run/getting-started/upgrade">https://docs.halo.run/getting-started/upgrade</a><br><a href="https://blog.laoda.de/archives/docker-issues#3.2-docker-compose%E6%90%AD%E5%BB%BA%E7%9A%84%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95">参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker搭建lsky-pro</title>
      <link href="/2022/07/26/28l-docker-compose-lsky-pro/"/>
      <url>/2022/07/26/28l-docker-compose-lsky-pro/</url>
      
        <content type="html"><![CDATA[<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>服务器:一台<br>系统：Debian 10（DD脚本,用原来的系统也可以）<br>域名:一枚，解析到服务器上<br>安装好Docker、Docker-compose<br>安装好Nginx Proxy Manager(非必需本教程采用)</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><blockquote><p>注意：VPS的内存如果过小，建议设置一下SWAP，一般为内存的1-1.5倍即可，可以让运行更流畅！<br>设置SWAP可以用脚本:<br>wget -O box.sh <a href="https://raw.githubusercontent.com/BlueSkyXN/SKY-BOX/main/box.sh">https://raw.githubusercontent.com/BlueSkyXN/SKY-BOX/main/box.sh</a> &amp;&amp; chmod +x box.sh &amp;&amp; clear &amp;&amp; .&#x2F;box.sh<br>选择18，然后输入你想要扩容的数值即可。</p></blockquote><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">sudo -i # 切换到root用户apt update -y  # 升级packagesapt install wget curl sudo vim git  # Debian系统比较干净，安装常用的软件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建安装目录"><a href="#创建安装目录" class="headerlink" title="创建安装目录"></a>创建安装目录</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">mkdir -p &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;lsky-procd &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;lsky-pronano docker-compose.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>docker-compose.yml填入以下内容：</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">version: &#39;3&#39;services:    lsky-pro:        container_name: lsky-pro        image: dko0&#x2F;lsky-pro        restart: always        volumes:            - &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;lsky-pro&#x2F;lsky-pro-data:&#x2F;var&#x2F;www&#x2F;html  #映射到本地        ports:            - 7791:80        environment:            - MYSQL_HOST&#x3D;mysql            - MYSQL_DATABASE&#x3D;lsky-pro            - MYSQL_USER&#x3D;lsky-pro            - MYSQL_PASSWORD&#x3D;lsky-pro    mysql:        image: mysql:8.0        container_name: lsky-pro-db        restart: always        environment:          - MYSQL_DATABASE&#x3D;lsky-pro          - MYSQL_USER&#x3D;lsky-pro          - MYSQL_PASSWORD&#x3D;lsky-pro          - MYSQL_ROOT_PASSWORD&#x3D;lsky-pro        volumes:          - &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;lsky-pro&#x2F;db:&#x2F;var&#x2F;lib&#x2F;mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ctrl+x退出，按y保存，enter确认。(vim也可)</p><blockquote><p>apt install lsof  #安装lsof</p></blockquote><blockquote><p>lsof -i:7791  #查看7791端口是否被占用，如果被占用，重新自定义一个端口</p></blockquote><blockquote></blockquote><p>访问：<code>http:服务ip:7791</code> 即可。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">cp -r &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;lsky-pro&#x2F;lsky-pro-data &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;lsky-pro&#x2F;lsky-pro-data.archive  # 万事先备份，以防万一cp -r &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;lsky-pro&#x2F;db &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;lsky-pro&#x2F;db.archive #数据库也备份一下cd &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;lsky-pro  # 进入docker-compose所在的文件夹docker-compose pull    # 拉取最新的镜像docker-compose up -d   # 重新更新当前镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最后一句命令docker-compose-up-d容易出现报错"><a href="#最后一句命令docker-compose-up-d容易出现报错" class="headerlink" title="最后一句命令docker-compose up -d容易出现报错"></a>最后一句命令<code>docker-compose up -d</code>容易出现报错</h3><h4 id="bash-docker-compose-未找到命令"><a href="#bash-docker-compose-未找到命令" class="headerlink" title="-bash: docker-compose: 未找到命令"></a><code>-bash: docker-compose: 未找到命令</code></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">dnf install docker-compose # fedorayum install docker-compose # CentOS 7&#x2F; RHEL7apt-get install docker-compose # debian及其变种如Ubuntuapk add docker-compose # alpinepacman -S docker-compose # arch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你的发行版没有提供 docker-compose（例如 CentOS 6），<br>也可以通过 GitHub 进行下载 docker-compose 二进制文件<br>从 GitHub 下载的速度可能会很慢，所以可以使用一些国内的镜像，例如 get.daocloud.io</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">curl -L https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.29.2&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composechmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose可以从 GitHub 获取到最新的版本号。最后，测试安装是否成功docker-compose version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ERROR-In-file-‘-docker-compose-yml’-the-service-name-True-must-be-a-quoted-string-i-e-‘True’"><a href="#ERROR-In-file-‘-docker-compose-yml’-the-service-name-True-must-be-a-quoted-string-i-e-‘True’" class="headerlink" title="ERROR: In file ‘.&#x2F;docker-compose.yml’, the service name True must be a quoted string, i.e. ‘True’"></a>ERROR: In file ‘.&#x2F;docker-compose.yml’, the service name True must be a quoted string, i.e. ‘True’</h4><p>一般是.yml文件里面格式不对,重新复制一下</p><h4 id="RROR-for-635e40a642c2-mine-app-1-Cannot-start-service-app-driver-failed-programming-external-connectivity-on-endpoint"><a href="#RROR-for-635e40a642c2-mine-app-1-Cannot-start-service-app-driver-failed-programming-external-connectivity-on-endpoint" class="headerlink" title="RROR: for 635e40a642c2_mine-app-1  Cannot start service app: driver failed programming external connectivity on endpoint"></a>RROR: for 635e40a642c2_mine-app-1  Cannot start service app: driver failed programming external connectivity on endpoint</h4><p>可能是服务器重启过程中，docker 程序运行异常，我们可以通过重启 docker 服务解决这个问题。</p><blockquote><p>service docker restart<br>重启后，再次运行 <code>docker-compose</code> 命令，容器服务正常启动</p></blockquote><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">cd &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;lsky-pro  # 进入docker-compose所在的文件夹docker-compose down    # 停止容器，此时不会删除映射到本地的数据rm -rf &#x2F;root&#x2F;data&#x2F;docker_data&#x2F;&#x2F;root&#x2F;data&#x2F;docker_data&#x2F;lsky-pro  # 完全删除映射到本地的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="反向代理把IP-端口变成域名来访问"><a href="#反向代理把IP-端口变成域名来访问" class="headerlink" title="反向代理把IP+端口变成域名来访问"></a>反向代理把IP+端口变成域名来访问</h2><p>通过反向代理,把ip:端口访问变成域名访问<br>安装Nginx Proxy Manager<br>在添加反向代理之前，确保你已经完成了域名解析，</p><p>Nginx Proxy Manager会用到80、443端口，本机不能占用（比如原来就有Nginx）<br>建一个docker-compose.yml配置文件<br>vim docker-compose.yml</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">version: &quot;3&quot;services:  app:    image: &#39;jc21&#x2F;nginx-proxy-manager:latest&#39;    restart: unless-stopped    ports:      # These ports are in format &lt;host-port&gt;:&lt;container-port&gt;      - &#39;80:80&#39; # Public HTTP Port      - &#39;443:443&#39; # Public HTTPS Port      - &#39;81:81&#39; # Admin Web Port      # Add any other Stream port you want to expose      # - &#39;21:21&#39; # FTP    environment:      DB_MYSQL_HOST: &quot;db&quot;      DB_MYSQL_PORT: 3306      DB_MYSQL_USER: &quot;npm&quot;      DB_MYSQL_PASSWORD: &quot;npm&quot;      DB_MYSQL_NAME: &quot;npm&quot;      # Uncomment this if IPv6 is not enabled on your host      # DISABLE_IPV6: &#39;true&#39;    volumes:      - .&#x2F;data:&#x2F;data      - .&#x2F;letsencrypt:&#x2F;etc&#x2F;letsencrypt    depends_on:      - db  db:    image: &#39;jc21&#x2F;mariadb-aria:latest&#39;    restart: unless-stopped    environment:      MYSQL_ROOT_PASSWORD: &#39;npm&#39;      MYSQL_DATABASE: &#39;npm&#39;      MYSQL_USER: &#39;npm&#39;      MYSQL_PASSWORD: &#39;npm&#39;    volumes:      - .&#x2F;data&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>docker-compose up -d 即可部署。</p></blockquote><p>docker container ls 查看容器的运行情况。<br>登陆Nginx Proxy Manager<br>浏览器输入<code>主机ip:81</code></p><p>默认登陆名和密码：<br>Email:    <a href="mailto:&#97;&#x64;&#109;&#105;&#110;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#x6d;">admin@example.com</a><br>Password: changeme</p><p>如果以前登陆过,可能账号为邮箱</p><p>查看Docker容器内部IP：<br>ip addr show docker0</p><img src="/2022/07/26/28l-docker-compose-lsky-pro/01.png" class="" title="This is an test image"><img src="/2022/07/26/28l-docker-compose-lsky-pro/02.png" class="" title="This is an test image"><img src="/2022/07/26/28l-docker-compose-lsky-pro/03.png" class="" title="This is an test image"><img src="/2022/07/26/28l-docker-compose-lsky-pro/04.png" class="" title="This is an test image"><img src="/2022/07/26/28l-docker-compose-lsky-pro/05.png" class="" title="This is an test image"><h2 id="配置lsky-pro"><a href="#配置lsky-pro" class="headerlink" title="配置lsky-pro"></a>配置lsky-pro</h2><p>数据库连接地址，填docker-compose文件里的容器名称lsky-pro-db，连接端口不用填。</p><img src="/2022/07/26/28l-docker-compose-lsky-pro/06.png" class="" title="This is an test image"><p>安装完成</p><p><a href="https://blog.laoda.de/archives/docker-compose-install-lskypro#6.-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">参考文章</a><br><a href="https://hub.docker.com/r/dko0/lsky-pro">使用的docker镜像地址</a><br><a href="https://docs.lsky.pro/">图床文档</a><br><a href="https://github.com/lsky-org/lsky-pro">兰空图床github</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决ssh暴力破解</title>
      <link href="/2022/07/24/27l-ssh-attack/"/>
      <url>/2022/07/24/27l-ssh-attack/</url>
      
        <content type="html"><![CDATA[<h2 id="ssh登录警告"><a href="#ssh登录警告" class="headerlink" title="ssh登录警告"></a>ssh登录警告</h2><p>通过ssh登录时受到以下警告</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">There were 151 failed login attempts since the last successful login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有人正在暴力破解我的ssh密码</p><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><h3 id="除root之外，是否还有其它特权用户-uid-为0"><a href="#除root之外，是否还有其它特权用户-uid-为0" class="headerlink" title="除root之外，是否还有其它特权用户(uid 为0)"></a>除root之外，是否还有其它特权用户(uid 为0)</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">awk -F: &#39;$3&#x3D;&#x3D;0&#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwdroot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="可以远程登录的帐号信息"><a href="#可以远程登录的帐号信息" class="headerlink" title="可以远程登录的帐号信息"></a>可以远程登录的帐号信息</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">awk &#39;&#x2F;\$1|\$6&#x2F;&#123;print $1&#125;&#39; &#x2F;etc&#x2F;shadowroot:$6$38cKfZDjsTiUe58V$FP.UHWMObqeUQS1Z2KRj&#x2F;4EEcOPi.6d1XmKHgK3j3GY9EGvwwBei7nUbbqJC.&#x2F;qK12HN8jFuXOfEYIKLID6hq0::0:99999:7:::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来，我们想到的是&#x2F;var&#x2F;log&#x2F;secure，这个日志文件记录了验证和授权方面的信息，只要涉及账号和密码的程序都会记录下来。</p><h3 id="确认攻击情况："><a href="#确认攻击情况：" class="headerlink" title="确认攻击情况："></a>确认攻击情况：</h3><p>1、统计日志，大约有126254次登录失败的记录，确认服务器遭受暴力破解</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">grep -o &quot;Failed password&quot; &#x2F;var&#x2F;log&#x2F;secure|uniq -c     126254 Failed password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、输出登录爆破的第一行和最后一行，确认爆破时间范围：</p><blockquote><p>grep “Failed password” &#x2F;var&#x2F;log&#x2F;secure|head -1</p></blockquote><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">Jul  8 20:14:59 localhost sshd[14323]: Failed password for invalid user qwe from 111.13.xxx.xxx port 1503 ssh2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>grep “Failed password” &#x2F;var&#x2F;log&#x2F;secure|tail -1</p></blockquote><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">Jul 10 12:37:21 localhost sshd[2654]: Failed password for root from 111.13.xxx.xxx port 13068 ssh2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、定位爆破IP</p><blockquote><p>grep “Failed password” &#x2F;var&#x2F;log&#x2F;secure|grep -E -o “(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)”|uniq -c | sort -nr </p></blockquote><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">12622 23.91.xxx.xxx 8942 114.104.xxx.xxx 8122 111.13.xxx.xxx 7525 123.59.xxx.xxx ...................<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、爆破用户名字典<br>grep “Failed password” &#x2F;var&#x2F;log&#x2F;secure|perl -e ‘while($_&#x3D;&lt;&gt;){ &#x2F;for(.*?) from&#x2F;; print “$1\n”;}’|uniq -c|sort -nr</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">9402  root3265  invalid user oracle1245  invalid user admin1025  invalid user user.....................<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="管理员最近登录情况："><a href="#管理员最近登录情况：" class="headerlink" title="管理员最近登录情况："></a>管理员最近登录情况：</h3><p>1、登录成功的日期、用户名、IP：</p><blockquote><p>grep “Accepted “ &#x2F;var&#x2F;log&#x2F;secure | awk ‘{print $1,$2,$3,$9,$11}’ </p></blockquote><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">Jul 9 09:38:09 root 192.168.143.100Jul 9 14:55:51 root 192.168.143.100Jul 10 08:54:26 root 192.168.143.100............................<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过登录日志分析，并未发现异常登录时间和登录IP。<br>2、顺便统计一下登录成功的IP有哪些：</p><blockquote><p>grep “Accepted “ &#x2F;var&#x2F;log&#x2F;secure | awk ‘{print $11}’ | sort | uniq -c | sort -nr | more</p></blockquote><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">27 192.168.204.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="禁止密码登录-使用密钥登录"><a href="#禁止密码登录-使用密钥登录" class="headerlink" title="禁止密码登录,使用密钥登录"></a>禁止密码登录,使用密钥登录</h3><p>密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。</p><ol><li>在服务器上制作密钥对<blockquote><p>ssh-keygen  &lt;&#x3D;&#x3D; 建立密钥对</p></blockquote></li></ol><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">Generating public&#x2F;private rsa key pair.Enter file in which to save the key (&#x2F;root&#x2F;.ssh&#x2F;id_rsa): &lt;&#x3D;&#x3D; 按 &#96;Enter&#96;Created directory &#39;&#x2F;root&#x2F;.ssh&#39;.Enter passphrase (empty for no passphrase): &lt;&#x3D;&#x3D; 输入密钥锁码，或直接按 &#96;Enter&#96; 留空Enter same passphrase again: &lt;&#x3D;&#x3D; 再输入一遍密钥锁码,直接按 &#96;Enter&#96; 留空Your identification has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa. &lt;&#x3D;&#x3D; 私钥Your public key has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub. &lt;&#x3D;&#x3D; 公钥<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>密钥锁码在使用私钥可以保护私钥不被盗用。也可以留空，实现无密码登录。</p><p>现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。<br>2. 在服务器上安装公钥<br>键入以下命令，在服务器上安装公钥：</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">cd .sshcat id_rsa.pub &gt;&gt; authorized_keys         #如果已经有公钥文件了,新的会加到文件中chmod 600 authorized_keyschmod 700 ~&#x2F;.ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>设置 SSH，打开密钥登录功能<br><code>vim /etc/ssh/sshd_config</code></li></ol><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">RSAAuthentication yesPubkeyAuthentication yes测试root 用户能否通过 SSH 登录：PermitRootLogin yes以密钥方式登录成功后，再禁用密码登录：PasswordAuthentication noservice sshd restart    #重启 SSH 服务或者 systemctl restart sshd <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>将私钥下载到客户端，登录时选择密钥登陆,并导入私钥</li></ol><h3 id="改默认端口"><a href="#改默认端口" class="headerlink" title="改默认端口"></a>改默认端口</h3><p>高级的攻击方式会扫描系统所有开放端口，并很方便地找到修改后的 SSHD 端口<br>所以,有用,但是用处不大</p><h3 id="手动禁用登陆失败的IP地址"><a href="#手动禁用登陆失败的IP地址" class="headerlink" title="手动禁用登陆失败的IP地址"></a>手动禁用登陆失败的IP地址</h3><p>查看登录失败的ip</p><blockquote><p>grep “Failed password for invalid user” &#x2F;var&#x2F;log&#x2F;secure | awk ‘{print $13}’ | sort | uniq -c | sort -nr<br>或者<br>cat &#x2F;var&#x2F;log&#x2F;secure|awk ‘&#x2F;Failed&#x2F;{print $(NF-3)}’|sort|uniq -c|awk ‘{print $2”&#x3D;”$1;}’<br>将登陆失败的 IP 加入服务器访问限制名单<br>cat &#x2F;var&#x2F;log&#x2F;secure |  grep “Failed password for invalid user” | awk ‘{print $13}’ | sort | uniq -c | sort -n | tail -10 |awk ‘{print “sshd:”$2”:deny”}’ &gt;&gt; &#x2F;etc&#x2F;hosts.allow<br>或者<br>cat &#x2F;var&#x2F;log&#x2F;secure|awk ‘&#x2F;Failed&#x2F;{print $(NF-3)}’|sort|uniq -c | awk ‘$1&gt;50 {print “sshd:”,$2}’&gt;&gt;&#x2F;etc&#x2F;hosts.deny<br>tail -20 &#x2F;etc&#x2F;hosts.allow</p></blockquote><h3 id="使用iptables工具-还未验证"><a href="#使用iptables工具-还未验证" class="headerlink" title="使用iptables工具(还未验证)"></a>使用iptables工具(还未验证)</h3><p>可能会用到的命令：</p><blockquote><p>iptables -I INPUT -s 221.0.0.0&#x2F;8 -j DROP 封禁整个221开头的网段<br>iptables -I INPUT -s 221.181.185.159 -j DROP 封禁指定IP<br>iptables -L –line-numbers 展示iptables策略列表并显示序号<br>iptables -D INPUT 1 根据上一条显示的序号，删除INPUT链的第一条</p></blockquote><p>在系统重启后，iptables的策略并不会保存<br>持久化步骤:</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">iptables-save &gt; &#x2F;etc&#x2F;sysconfig&#x2F;iptables使用该命令将 iptables 的配置保存在&#x2F;etc&#x2F;sysconfig&#x2F;iptables中在&#x2F;etc&#x2F;rc.d&#x2F;rc.local中添加iptables-restore &lt; &#x2F;etc&#x2F;sysconfig&#x2F;iptables 即在开机后自动导入之前保存的 iptables 策略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大佬的两条策略</p><blockquote><p>iptables -I INPUT -p tcp –dport 22 -i eth0 -m state –state NEW -m recent –set<br>iptables -I INPUT -p tcp –dport 22 -i eth0 -m state –state NEW -m recent –update –seconds 60 –hitcount 3 -j DROP</p></blockquote><p>第一句是说，对于外来数据，如果是 TCP 协议，目标端口号是 22，网络接口是eth0，状态是新连接,那么把它加到最近列表中<br>第二句是说，对于这样的连接，如果在最近列表中，并且在 60秒内达到或者超过四次，那么丢弃该数据。<br>其中的-m是模块的意思。也就是说，如果有人从一个 IP 一分钟内连接尝试四次ssh登录的话,就会被加入黑名单,后续连接将会被丢弃.</p><h2 id="finalshell连接后会自动命令"><a href="#finalshell连接后会自动命令" class="headerlink" title="finalshell连接后会自动命令"></a>finalshell连接后会自动命令</h2><p>set +o history   #隐藏命令记录<br>export LANG&#x3D;”en_US”;export LANGUAGE&#x3D;”</p><p>开始以为有人爆破成功连接上了,结果是finalshell的问题<br>并且finalshell的智能加速相当于cdn,节点不一样,登陆的ip就不一样,关掉就可以了</p><p><a href="https://www.runoob.com/w3cnote/set-ssh-login-key.html">参考文章</a><br><a href="https://bypass007.github.io/Emergency-Response-Notes/Linux/%E7%AC%AC1%E7%AF%87%EF%BC%9ASSH%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3.html">2.参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ip5306的简易充电宝</title>
      <link href="/2022/07/23/26h-ip5306/"/>
      <url>/2022/07/23/26h-ip5306/</url>
      
        <content type="html"><![CDATA[<h2 id="ip5306芯片介绍"><a href="#ip5306芯片介绍" class="headerlink" title="ip5306芯片介绍"></a>ip5306芯片介绍</h2><p><a href="https://item.szlcsc.com/datasheet/IP5306/193089.html">IP5306 -PDF数据手册-参考资料-立创商城</a><br>典型应用原理图</p><img src="/2022/07/23/26h-ip5306/01.png" class=""><img src="/2022/07/23/26h-ip5306/01.png" class="" width="01"><p>引脚图</p><img src="/2022/07/23/26h-ip5306/02.png" class=""><img src="/2022/07/23/26h-ip5306/02.png" class="" width="02"><p>注意:IP5306使用芯片底部焊盘作为GND极，这一点在PCB布线时需要特别注意,如果更换前，没有给芯片底部焊盘加锡的，芯片的GND未与PCB连接上，导致芯片上的GND没有连接到PCB板上，<code>可能</code>会出现测到的输出电压很低，只有2-3V，没有了升压。</p><h2 id="画板"><a href="#画板" class="headerlink" title="画板"></a>画板</h2><p>注意:<br>1,<code>VIN</code>走线加粗<code>50MIL</code>以上,<code>电容靠芯摆放</code><br>2,8脚<code>VOUT</code>走线加粗<code>50MIL</code>以上,<code>电容靠芯摆放,不然烧芯片</code>,切记!<br>3,7脚到<code>电感</code>走线加粗<code>80MIL</code>以上,<code>电感到电池端加粗80MIL</code><br>4,6脚经电容再到芯片,从<code>电池焊点端走线不要跟电感并线</code>,10MIL左右即可<br>5,<code>芯片底部</code>如果是手焊<code>多打些过孔</code>,能打多大打多大,如果是生产要注意漏锡造成假焊<br>6,电感要大功率电感,1uH&#x2F;6A以上饱和电流</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>1.充放电芯片过热,测量过输入输出电压,均为5.1v<br>2.灯正常亮,无法充放电-&gt;芯片引脚连锡<br>3.发光二极管如何判断正负<br>正面:绿色那角为负<br>反面:三角形尖对着那边为负</p><img src="/2022/07/23/26h-ip5306/06.png" class="" title="This is an test image"><img src="/2022/07/23/26h-ip5306/07.jpg" class="" title="This is an test image"><img src="/2022/07/23/26h-ip5306/06.png" class="" width="06"><img src="/2022/07/23/26h-ip5306/07.jpg" class="" width="07"><p><img src="https://pic4.zhimg.com/80/v2-26cb0b049367006c0ea1ca767f8e634f_1440w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-2f46b3db84ad092171dc72a8783ecb83_1440w.webp" alt="img"></p><p>4.正方形或者长方形的贴片发光二极管中有一个缺角，缺角的那端是正极<br>5.用万用表的二极管档进行测量，显示压降就代表发光二极管导通，红表笔对应二极管的正极<code>或者</code>用万用表的200k电阻档，如果有读数，那么红表笔就是二极管的正极</p><p>其他人遇到的问题,我暂时还未出现</p><h3 id="开机半分钟自动休眠"><a href="#开机半分钟自动休眠" class="headerlink" title="开机半分钟自动休眠"></a>开机半分钟自动休眠</h3><blockquote><p>官方手册中提到，负载自动检测时间 TloadD 负载电流持续小于 45mA 32 s时，芯片会自动进入休眠状态。但实际应用中，此芯片个体差异很大，有部分芯片负载电流需要达到70mA以上才不会自动休眠，对试产阶段的产品很不友好。<br>解决方法：<br>1.在开机时，对5脚KEY输入50ms的脉冲，周期小于30S；<br>2.在芯片输出端接入阻值较小的电阻（大小根据实际需要的电流确定），使系统正常工作时电流足够大。</p></blockquote><h3 id="不断关机重启"><a href="#不断关机重启" class="headerlink" title="不断关机重启"></a>不断关机重启</h3><blockquote><p>芯片不断关机重启很可能是芯片检测到过流或者短路引起的；我曾在IP5306输出端接过PMOS以实现后端的电源开关，每次开启PMOS时，系统就会不断地关机重启；用示波器抓芯片输出电压并没有持续的低电压出现，后来以为是PMOS后端的大电容充电触发了短路检测，但是拆掉电容后情况依旧。<br>官方手册过流及短路检测说明：<br>负载过流检测时间 TUVD 输出电压持续低于 4.4V 50 ms；<br>负载短路检测时间 TOCD 输出电流持续大于 4A 150 200 us。<br>解决方法：<br>在PMOS栅极加了一个100K和100nF的电容，使PMOS开启需要的时间变长，注意输出后端大电容；</p></blockquote><h3 id="芯片烧毁"><a href="#芯片烧毁" class="headerlink" title="芯片烧毁"></a>芯片烧毁</h3><blockquote><p>芯片提到可以提供多种充放电防护，所以我直接按照手册把没有保护板的电池接到了IP5306的电池脚，后来经常出现机器用了几周后芯片烧毁的情况，芯片所有管脚对地都出现低阻状态，电池持续放电、发热导致芯片烧毁，电池损坏。<br>官方手册多重保护说明：<br>输出过流、过压、短路保护；<br>输入过压、过充、过放、过流放电保护；<br>整机过温保护；<br>ESD 4KV，瞬间耐压 12V。<br>解决方法：电池增加保护板，防止过冲过放，可以有效防止芯片烧毁。</p></blockquote><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p>虽然不太好看,也有很多的问题,但还是要记录一下</p><img src="/2022/07/23/26h-ip5306/03.png" class="" title="This is an test image"><img src="/2022/07/23/26h-ip5306/03.png" class="" width="03"><img src="/2022/07/23/26h-ip5306/04.png" class="" title="参考大佬开源的带灯的"><img src="/2022/07/23/26h-ip5306/04.png" class="" width="04"><img src="/2022/07/23/26h-ip5306/05.jpg" class="" width="05"><img src="/2022/07/23/26h-ip5306/05.jpg" class="" title="莫得洗板水,不然应该会干净一些"><h2 id="待解决-发热问题"><a href="#待解决-发热问题" class="headerlink" title="待解决:发热问题"></a>待解决:发热问题</h2><p><a href="https://oshwhub.com/wzw666/IP5306">参考文章</a><br><a href="https://blog.csdn.net/weixin_43164032/article/details/116158088?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165857800016781790778976%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165857800016781790778976&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-1-116158088-null-null.142%5Ev33%5Epc_rank_34,185%5Ev2%5Econtrol&utm_term=ip5306%E5%85%85%E7%94%B5%E6%97%B6%E5%8F%91%E7%83%AD%E6%AD%A3%E5%B8%B8%E5%90%97&spm=1018.2226.3001.4187">参考文章</a><br><a href="https://www.elecfans.com/d/1776755.html">3参考文章</a></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>2025&#x2F;1&#x2F;17</p><p>【[开源]DIY一个超迷你、简易、亮瞎眼的充电宝，18650电池充电器。】<a href="https://www.bilibili.com/video/BV1Zg411V7rZ?vd_source=f525a47bd6d8cb5b154158289da1d4d4">https://www.bilibili.com/video/BV1Zg411V7rZ?vd_source=f525a47bd6d8cb5b154158289da1d4d4</a></p><h3 id="AP3032KTR-G1"><a href="#AP3032KTR-G1" class="headerlink" title="AP3032KTR-G1"></a>AP3032KTR-G1</h3><p><strong>电感在芯片</strong>电路中的主要<strong>作用</strong>是限制电流变化速度，使得电路中电能能够稳定地传输。</p><p>BOOST电路，储能升压</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电源芯片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Nginx为服务器绑定多个域名</title>
      <link href="/2022/07/21/25l-nginx-domain-name/"/>
      <url>/2022/07/21/25l-nginx-domain-name/</url>
      
        <content type="html"><![CDATA[<p>Nginx绑定多个域名，可通过把多个域名规则写一个配置文件里实现，也可通过分别建立多个域名配置文件实现，为了管理方便，建议每个域名建一个文件，有些同类域名则可写在一个总的配置文件里</p><h2 id="一个域名建立一个单独的配置文件"><a href="#一个域名建立一个单独的配置文件" class="headerlink" title="一个域名建立一个单独的配置文件"></a>一个域名建立一个单独的配置文件</h2><p>进入Nginx服务的配置文件目录</p><blockquote><p>mkdir &#x2F;etc&#x2F;nginx&#x2F;vhost<br>cd &#x2F;etc&#x2F;nginx&#x2F;vhost</p></blockquote><h3 id="创建域名规则配置文件"><a href="#创建域名规则配置文件" class="headerlink" title="创建域名规则配置文件"></a>创建域名规则配置文件</h3><blockquote><p>vi 域名.conf     例:vi <a href="http://www.npnpnp.com.conf/">www.npnpnp.com.conf</a></p></blockquote><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">server &#123;  listen 80;                           #监听端口设为80。  server_name www.testa.com; #绑定您的域名。  root &#x2F;home&#x2F;website&#x2F;testa;            #指定网站根目录。  location &#x2F; &#123;    index index.html index.htm index.php;#指定默认文件。  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">vi 域名.confserver &#123;  listen 80;  server_name www.testb.com;  root &#x2F;home&#x2F;website&#x2F;testb;  location &#x2F; &#123;    index index.html index.htm index.php;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成后就可以ping通了</p><h3 id="静态页面html配置路径"><a href="#静态页面html配置路径" class="headerlink" title="静态页面html配置路径"></a>静态页面html配置路径</h3><p>testa –&gt; &#x2F;home&#x2F;website&#x2F;testa<br>testb –&gt; &#x2F;home&#x2F;website&#x2F;testb</p><blockquote><p>mkdir -p &#x2F;home&#x2F;website&#x2F;testa       #-p是如果一级或二级文件夹不存在的话就生成一个<br>mkdir -p &#x2F;home&#x2F;website&#x2F;testb</p></blockquote><p>将网站的源码放进去就可以了(放入解压缩后文件夹里面的具体文件)</p><h3 id="修改nginx配置"><a href="#修改nginx配置" class="headerlink" title="修改nginx配置"></a>修改nginx配置</h3><p>在nginx的主配置文件里，设置包含这两个站点的配置文件(默认加载3个conf文件)<br>vi &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">...http &#123;  ...  # Load modular configuration files from the &#x2F;etc&#x2F;nginx&#x2F;conf.d directory.  # See http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;ngx_core_module.html#include  # for more information.  # include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;  # 加上路径  include &#x2F;etc&#x2F;nginx&#x2F;vhost&#x2F;*.conf;     #这个vhost文件夹是指你在nginx下创建的放置域名&#96;.conf&#96;的文件夹(我之前直接放在conf.d文件夹下了)  ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新加载nginx配置</p><blockquote><p>nginx -s reload<br>service nginx restart</p></blockquote><h2 id="多个域名一个配置文件"><a href="#多个域名一个配置文件" class="headerlink" title="多个域名一个配置文件"></a>多个域名一个配置文件</h2><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">server &#123;  listen 80;                           #监听端口设为80。  server_name www.testa.com; #绑定您的域名。  root &#x2F;home&#x2F;website&#x2F;testa;            #指定网站根目录。  location &#x2F; &#123;    index index.html index.htm index.php;#指定默认文件。  &#125;&#125;server &#123;  listen 80;  server_name www.testb.com;  root &#x2F;home&#x2F;website&#x2F;testb;  location &#x2F; &#123;    index index.html index.htm index.php;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/caojengineer/article/details/104528455?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165838746916782248560542%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165838746916782248560542&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-15-104528455-null-null.142%5Ev33%5Epc_rank_34,185%5Ev2%5Econtrol&utm_term=nginx%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D&spm=1018.2226.3001.4187">参考文章</a><br><a href="https://blog.csdn.net/weixin_36331058/article/details/119558435?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165838746916782248560542%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165838746916782248560542&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-17-119558435-null-null.142%5Ev33%5Epc_rank_34,185%5Ev2%5Econtrol&utm_term=nginx%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D&spm=1018.2226.3001.4187">参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客无法显示图片</title>
      <link href="/2022/07/21/24l-hexo-image/"/>
      <url>/2022/07/21/24l-hexo-image/</url>
      
        <content type="html"><![CDATA[<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>版本：Hexo 3以上<br>官方文档：<a href="https://hexo.io/zh-cn/docs(%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%9C%89%E8%AE%B2%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87)">https://hexo.io/zh-cn/docs(官方文档有讲如何插入图片)</a></p><blockquote><p>解决方案如下：<br>　　&gt;1. 将根目录下配置文件<code>_config.yml</code> 中有<code>post_asset_folder:false</code>改为true。<br>建立新文章时,Hexo会自动建立一个与文章同名的文件夹，将图片放到该文件夹就可以了<br>　　&gt;2. git bash安装插件：<code>npm install https://github.com/7ym0n/hexo-asset-image --save</code>（这是个修改过的插件，经测试无问题），使用这个插件来引入图片，而不是网上那些方法里说的用传统md语法相对路径的方法。<br>　　&gt;3. 插入图片时用这种方式：<br><code>&#123;% asset_img test.jpg This is an test image %&#125;</code><br>　　　&gt;其中test.jpg就是你要引用的图片，我这里就是test.jpg，后面的This is an test image是图片描述，可以自己修改。<br>　　&gt;4. 这样就能成功显示了，测试下：hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</p></blockquote><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>图片过大可能会拖慢网站的加载速度,可以使用工具压缩图片<br><a href="https://tinypng.com/">tinypng</a><br>一个在线压缩的网站。 压缩后的图片也保留了很高的质量，在知乎上很多人推荐，不过免费版有限制。(个人比较常用这个)</p><img src="/2022/07/21/24l-hexo-image/01.png" class="" title="This is an test image"><p><a href="https://saerasoft.com/caesium/">caesium</a><br>开源软件，支持Windows和macOS。 可以批量压缩软件，无限制。</p><img src="/2022/07/21/24l-hexo-image/02.png" class="" title="This is an test image"><p><a href="https://github.com/marketplace/imgbot">imgbot</a></p><img src="/2022/07/21/24l-hexo-image/03.png" class="" title="This is an test image"><p>imgbot 是一款 Github 插件。<br>安装后，你上传图片到 Github 去，imgbot 会自动压缩图片并推送 PR，我们只需要合并 PR 就行<br>你可以配置 imgbot 的侦测方法、压缩方法（有损&#x2F;无损），具体可以查看插件的文档</p><p><a href="http://t.zoukankan.com/Jesee-p-11234387.html">1参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用宝塔面板搭建hexo</title>
      <link href="/2022/07/20/23l-bt-entablish-hexo/"/>
      <url>/2022/07/20/23l-bt-entablish-hexo/</url>
      
        <content type="html"><![CDATA[<p>上次搭建完hexo博客之后,想用宝塔面板在服务器上搭建别的网站,结果所有的域名显示的都是同一个内容,查了一下发现是没有更改nginx的原因,重新用宝塔面板搭建,方面管理</p><h2 id="安装git及git配置"><a href="#安装git及git配置" class="headerlink" title="安装git及git配置"></a>安装git及git配置</h2><blockquote><p>yum install git</p></blockquote><h3 id="安装git时可能会出现的问题"><a href="#安装git时可能会出现的问题" class="headerlink" title="安装git时可能会出现的问题"></a>安装git时可能会出现的问题</h3><p>1.openssl&#x2F;ssl.h：没有那个文件或目录</p><blockquote><p>原因:缺少openssl依赖库，但我无法获得这些库</p></blockquote><blockquote><p>解决:<br>centos使用yum安装：<br>yum install curl-devel expat-devel gettext-devel <br>  openssl-devel zlib-devel<br>Debian,Ubuntu使用apt安装：<br>apt-get install libcurl4-gnutls-dev libexpat1-dev gettext <br>  libz-dev libssl-dev</p></blockquote><p>2.&#x2F;bin&#x2F;sh: cc: 未找到命令</p><blockquote><p>yum -y install gcc automake autoconf libtool make </p></blockquote><h3 id="配置git仓库"><a href="#配置git仓库" class="headerlink" title="配置git仓库"></a>配置git仓库</h3><p>在root用户下输入</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">useradd git    # 创建用户gitpasswd git     # 为用户git设置密码chmod 740 &#x2F;etc&#x2F;sudoers     # 修改文件权限vim &#x2F;etc&#x2F;sudoers # 找到           root ALL&#x3D;(ALL)  ALL # 在下面添加一行  git  ALL&#x3D;(ALL)  ALL # 输入:wq即可保存并退出编辑chmod 400 &#x2F;etc&#x2F;sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切换git用户</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">su git   # 切换到git用户,这步最关键sudo mkdir  -p  &#x2F;www&#x2F;wwwroot&#x2F;blog  # 把博客目录放在宝塔网站的根目录下cd &#x2F;home&#x2F;gitmkdir reposcd reposgit init --bare blog.git  # 创建一个裸库blog.gitcd blog.git&#x2F;hooks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>vim post-receive</p></blockquote><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">#!&#x2F;bin&#x2F;shgit --work-tree&#x3D;&#x2F;www&#x2F;wwwroot&#x2F;blog --git-dir&#x3D;&#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git checkout -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改权限</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">chmod +x post-receiveexit                           #回到root用户         chown -R git:git &#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git #赋予git用户可操作仓库blog.git的权限chown -R git:git &#x2F;www&#x2F;wwwroot&#x2F;blog        #赋予git用户可操作仓库blog.git的权限<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="免密登录配置"><a href="#免密登录配置" class="headerlink" title="免密登录配置"></a>免密登录配置</h2><p>之前配置过，只要复制公钥到服务器了就可以了。<br>本地终端创建 ssh key</p><blockquote><p>ssh-keygen -t rsa -C “<a href="mailto:&#121;&#111;&#x75;&#114;&#x5f;&#x65;&#109;&#x61;&#105;&#108;&#x40;&#x79;&#x6f;&#x75;&#x72;&#101;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;">your_email@youremail.com</a>“</p></blockquote><p>将公钥添加到服务器authorized_keys文件中<br>git用户下输入</p><blockquote><p>mkdir ~&#x2F;.ssh<br>vim ~&#x2F;.ssh&#x2F;authorized_keys        #复制过来就可以了</p></blockquote><hr><p>以上这部分跟之前在服务器上直接配置是一样的</p><h2 id="安装宝塔面板"><a href="#安装宝塔面板" class="headerlink" title="安装宝塔面板"></a>安装宝塔面板</h2><blockquote><p>yum install -y wget &amp;&amp; wget -O install.sh <a href="http://download.bt.cn/install/install_6.0.sh">http://download.bt.cn/install/install_6.0.sh</a> &amp;&amp; sh install.sh</p></blockquote><p>正常安装nginx,php等,添加站点时将根目录改成&#x2F;www&#x2F;wwwroot&#x2F;blog(这里注意目录不能建在根目录下和根目录吓得其他目录里,暂时还不知道为什么,就是如果这样改的话,面板会报错,会告诉你不能放在哪些目录,通常网站都放在&#x2F;www&#x2F;wwwroot目录下)<br><img src="http://212.90.123.174:7788/i/2022/07/20/62d80586764ef.jpg" alt="01.jpg"></p><h2 id="本地hexo配置"><a href="#本地hexo配置" class="headerlink" title="本地hexo配置"></a>本地hexo配置</h2><img src="/2022/07/20/23l-bt-entablish-hexo/02.jpg" class="" title="This is an test image"><p>下面这两张图片仅供参考,是从其他文章复制过来的</p><img src="/2022/07/20/23l-bt-entablish-hexo/03.jpg" class="" title="This is an test image"><img src="/2022/07/20/23l-bt-entablish-hexo/04.jpg" class="" title="This is an test image"><img src="/2022/07/20/23l-bt-entablish-hexo/8.jpg" class="" title="This is an test image"><p>建站完成！</p><p><a href="https://blog.csdn.net/weixin_45588247/article/details/1198873560">1.1参考文章</a><br><a href="https://www.qyxie.top/2021/07/31/21073101/">3参考文章</a><br><a href="https://blog.csdn.net/diaoao8515/article/details/102293551">1.2参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Esp8266的一些基础知识</title>
      <link href="/2022/07/08/22h-esp8266/"/>
      <url>/2022/07/08/22h-esp8266/</url>
      
        <content type="html"><![CDATA[<h2 id="关于NodeMCU开发板"><a href="#关于NodeMCU开发板" class="headerlink" title="关于NodeMCU开发板"></a>关于NodeMCU开发板</h2><blockquote><p>NodeMCU是一个开源的IoT物联网硬件开发板,NodeMCU尺寸与Arduino Nano类似。它并不是Arduino团队开发的，但是我们也可以使用Arduino IDE 对它进行开发。而且它还有一颗地道的“中国芯”—ESP8266模块。</p></blockquote><p>ESP8266是一块芯片<br><img src="http://212.90.123.174:7788/i/2022/07/12/62cd3c68648cf.jpg" alt="01.jpg"><br>NodeMCU则是以ESP8266芯片为核心的开发板<br><img src="http://212.90.123.174:7788/i/2022/07/12/62cd3c63428b1.jpg" alt="02.jpg"></p><p>当引脚以数字输出模式工作时，低电平是0V (灌电流)，高电平是3.3V (拉电流)。</p><p>请注意:ESP8266芯片与Arduino Uno&#x2F;Mega&#x2F;Nano等开发板的引脚电平电压有所区别。Arduino开发板的高电平是+5V，低电平是0V。</p><p><img src="http://212.90.123.174:7788/i/2022/07/12/62cd3c6768e82.jpg" alt="03.jpg"></p><h3 id="可用引脚"><a href="#可用引脚" class="headerlink" title="可用引脚"></a>可用引脚</h3><p>ESP8266芯片有17个GPIO引脚（GPIO0～GPIO16）。这些引脚中的GPIO6～GPIO 11被用于连接开发板的闪存（Flash Memory）。如果在实验电路中使用GPIO6～GPIO11，NodeMCU开发板将无法正常工作。因此建议您不要使用GPIO6～GPIO 11。</p><img src="/2022/07/08/22h-esp8266/04.png" class="" title="This is an test image">电压电流限制<p>NodeMCU开发板引脚的输入输出电压限制是3.3 V。如果向引脚施加3.6V以上的电压就有可能对芯片电路造成损坏。同时请注意，这些引脚的最大输出电流是12mA。</p><blockquote><p>由于NodeMCU开发板的引脚允许电压和电流都是低于Arduino开发板的引脚，所以想要将二者引脚相互连接,注意两个开发板的引脚电压和电流的区别,操作不当可能会损坏NodeMCU开发板</p></blockquote><h3 id="特殊引脚情况说明"><a href="#特殊引脚情况说明" class="headerlink" title="特殊引脚情况说明"></a>特殊引脚情况说明</h3><ul><li><p>GPIO2引脚 在NodeMCU开发板启动时是不能连接低电平的。</p></li><li><p>GPIO15引脚在开发板运行中一直保持低电平状态。因此请不要使用GPIO15引脚来读取开关状态或进行I²C通讯。</p></li><li><p>GPIO0引脚在开发板运行中需要一直保持高电平状态。否则ESP8266将进入程序上传工作模式也就无法正常工作了。您无需对GPIO0引脚进行额外操作，因为NodeMCU的内置电路可以确保GPIO0引脚在工作时连接高电平而在上传程序时连接低电平。</p></li><li><p>GPIO 0-15引脚都配有内置上拉电阻。这一点与Arduino十分类似。GPIO16 引脚配有内置下拉电阻。</p></li></ul><h3 id="模拟输入引脚"><a href="#模拟输入引脚" class="headerlink" title="模拟输入引脚"></a>模拟输入引脚</h3><ul><li><p>ESP8266 只有一个模拟输入引脚（该引脚通过模拟-数字转换将引脚上的模拟电压数值转化为数字量）。此引脚可以读取的模拟电压值为 0 – 1.0V。请注意：ESP8266 芯片模拟输入引脚连接在1.0V以上电压可能损坏ESP8266芯片。</p></li><li><p>NodeMCU开发板配有降压电路。您可以用NodeMCU开发板的模拟输入引脚读取0-3.3V的模拟电压信号。</p></li></ul><h3 id="通讯-串行端口"><a href="#通讯-串行端口" class="headerlink" title="通讯&#x2F;串行端口"></a>通讯&#x2F;串行端口</h3><p>ESP8266有2个硬件串行端口（UART)</p><ul><li>串行端口0（UART0）使用GPIO1(TX0)和GPIO3(RX0)引脚。</li><li>串行端口1（UART1）使用GPIO2(TX1)和GPIO8(RX1)引脚。注意，由于GPIO8被用于连接闪存芯片，串行端口1只能使用GPIO2来向外发送串行数据。</li></ul><p>I²C</p><blockquote><p>ESP8266只有软件模拟的I²C端口，没有硬件I²C端口。也就是说我们可以使用任意的两个GPIO引脚通过软件模拟来实现I²C通讯。ESP8266的数据表（datasheet）中，GPIO2标注为SDA，GPIO14标注为SCL。</p></blockquote><p>SPI</p><blockquote><p>ESP8266的SPI端口情况如下：<br>GPIO14 — CLK<br>GPIO12 — MISO<br>GPIO13 — MOSI<br>GPIO 15 — CS(SS)</p></blockquote><h2 id="ESP8266引脚功能一览"><a href="#ESP8266引脚功能一览" class="headerlink" title="ESP8266引脚功能一览"></a>ESP8266引脚功能一览</h2><p><img src="http://212.90.123.174:7788/i/2022/07/12/62cd3c67a14ef.jpg" alt="05.jpg"></p><p><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/esp8266-nodemcu-tutorial-index/nodemcu-board/">参考文章:太极创客</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Esp8266 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过正则表达式爬虫</title>
      <link href="/2022/06/27/21p-re-spider/"/>
      <url>/2022/06/27/21p-re-spider/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h3><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="报错UnicodeEncodeError-‘gbk’-codec-can’t-encode-character-‘-xe7’-in-position-10"><a href="#报错UnicodeEncodeError-‘gbk’-codec-can’t-encode-character-‘-xe7’-in-position-10" class="headerlink" title="报错UnicodeEncodeError: ‘gbk’ codec can’t encode character ‘\xe7’ in position 10"></a>报错UnicodeEncodeError: ‘gbk’ codec can’t encode character ‘\xe7’ in position 10</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">大多数的做法是f &#x3D; open(&quot;blog.csv&quot;,mode&#x3D;&quot;w&quot;)在这个后面加上一个encoding&#x3D;utf-8,加上之后可以运行,但写入表格的数据出现乱码,有的让将utf-8改成utf-8-sig,还有其他的方法是改成GB啥啥的我忘了,基本都没用解决:resp &#x3D; requests.get(url,headers&#x3D;headers)resp.encoding &#x3D; &#39;utf-8&#39;      #暂时不知道为什么加在这里就可以page_content&#x3D;resp.text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常见的爬虫中文乱码问题"><a href="#常见的爬虫中文乱码问题" class="headerlink" title="常见的爬虫中文乱码问题"></a>常见的爬虫中文乱码问题</h2><h3 id="网址编码为gbk"><a href="#网址编码为gbk" class="headerlink" title="网址编码为gbk"></a>网址编码为gbk</h3><blockquote><p>1.查看网页源代码的head部分的编码：</p></blockquote><meta http-equiv="Content-Type" content="text/html; charset=gb2312">，发现网页编码为gbk类型2.利用requests库的方法查看默认输出的编码类型<pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsurl &#x3D; &#39;https:&#x2F;&#x2F;chengdu.chashebao.com&#x2F;yanglao&#x2F;19077.html&#39;response &#x3D; requests.get(url)print(response.encoding)  输出结果为编码ISO-8859-1，并不是原网页的编码类型。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.利用requests库改变输出结果的编码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsurl &#x3D; &#39;https:&#x2F;&#x2F;chengdu.chashebao.com&#x2F;yanglao&#x2F;19077.html&#39;response &#x3D; requests.get(url)response.encoding &#x3D; &#39;gbk&#39;print(response.encoding)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为编码gbk，与原网页保持一致。</p><p>基于以上三个步骤，即可解决爬虫中文乱码问题。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsdef get_html(url):    try:        response &#x3D; requests.get(url)        response.encoding &#x3D; &#39;gbk&#39;  # 改变编码        print(response.encoding)        html &#x3D; response.text        return html    except:        print(&#39;请求网址出错&#39;)url &#x3D; &#39;https:&#x2F;&#x2F;chengdu.chashebao.com&#x2F;yanglao&#x2F;19077.html&#39;html &#x3D; get_html(url)print(html)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="网址编码为utf-8"><a href="#网址编码为utf-8" class="headerlink" title="网址编码为utf-8"></a>网址编码为utf-8</h3><p>对于有些网页编码为utf-8的网址，输出事发现中文为乱码，此时我们需要进行两次重编码。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">response &#x3D; requests.get(url, headers&#x3D;headers)response.encoding &#x3D; &#39;GBK&#39;      (#我没加这个也是可以的)response.encoding &#x3D; &#39;utf-8&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="网址编码为gb2312"><a href="#网址编码为gb2312" class="headerlink" title="网址编码为gb2312"></a>网址编码为gb2312</h3><p>response.encoding &#x3D; ‘GBK’</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为什么这么改,和为什么会出现这样的报错我暂时还不懂,学懂了之后会写上<br><a href="https://blog.csdn.net/weixin_44321116/article/details/104280012?ops_request_misc=&request_id=&biz_id=102&utm_term=gbk%27%20codec%20can%27t%20encode%20charac&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-104280012.142%5Ev24%5Epc_rank_34,157%5Ev15%5Enew_3&spm=1018.2226.3001.4187">参考文章1</a><br><a href="https://blog.csdn.net/qq_17249717/article/details/98472363?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165634565316782395370345%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165634565316782395370345&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-98472363-null-null.142%5Ev24%5Epc_rank_34,157%5Ev15%5Enew_3&utm_term=python%E7%88%AC%E8%99%AB%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81&spm=1018.2226.3001.4187">参考文章2</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32f103平衡小车</title>
      <link href="/2022/06/24/20h-stm32f103-balance-car/"/>
      <url>/2022/06/24/20h-stm32f103-balance-car/</url>
      
        <content type="html"><![CDATA[<h2 id="材料清单"><a href="#材料清单" class="headerlink" title="材料清单"></a>材料清单</h2><blockquote><p>1.stm32f103c8t6最小系统板<br>2.TB6612电机驱动(可用L298N或者DRV8848替代)<br>3.MPU6050<br>4.两轮小车底盘(电机需要带编码器)<br>5.0.96oled屏幕<br>6.降压模块</p></blockquote><ul><li>资源分配图</li></ul><img src="/2022/06/24/20h-stm32f103-balance-car/image-20240406142348401.png" class="" title="image-20240406142348401"><h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><p>编写程序之前,先画一个思维导图,理清各个程序之间的关系,以及小车正常工作的流程图<br>基础的程序包含以下几个部分</p><blockquote><p>1.motor<br>2.pwm<br>3.encoder<br>4.mpu6050<br>5.exti<br>6.oled<br>7.control<br>后续还可以进行二次开发,加上led,key,bluetooth(usart),避障等功能</p></blockquote><h3 id="motor"><a href="#motor" class="headerlink" title="motor"></a>motor</h3><p>1.让电机转起来<br>motor,引脚设置成输出,两个电机需要四个引脚对应AIN1,AIN2,BIN1,BIN2<br>ENA  IN1  IN2<br>0       任意  任意   停止<br>1       0         0       停止<br>1       0         1        正转</p><blockquote><p>具体接线描述：L298N的out1和out2接电机的正负极，IN1和IN2分别对应开发板的PA4和PA5，12V电源接入L298N的12V供电和GND，然后将开发板的gnd和l298n的gnd连接（一定要共地）接线完工<br>PWM设置值,就是电机的速度</p></blockquote><h3 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h3><p><img src="https://img-blog.csdnimg.cn/b94068adf5894da797e5b296b3985d38.png" alt="img"></p><p>好像改变ARR(自动重装载值)会改变占空比(CCR&#x2F;ARR), 周期也会变, 改变psc应该改变的是斜率, 越大斜率越小, 所以改变占空比, 也就是高电平所占的时间,会改变电机速度,改变频率,会改变电机响应速度,频率过低会有噪音和震动</p><p>ARR : 决定PWM周期(在时钟频率一定的情况下,当前为默认内部时钟CK_INT)</p><p>CCRx : 决定PWM占空比(高低电平所占整个周期比例)</p><ol><li><p><code>TIM1_PWM_Init(899, 0)</code>: 这种设置下，ARR被设置为899，PSC被设置为0。这意味着PWM的周期为ARR+1个计数值，也就是900个计数值，而预分频因子为1。这种设置适用于需要较快的PWM输出频率的情况。</p></li><li><p><code>PWM_Init_TIM1(0, 7199)</code>: 这种设置下，ARR被设置为0（实际上是最大值65535），PSC被设置为7199。这意味着PWM的周期为1个计数值，预分频因子为7200。这种设置适用于需要较慢的PWM输出频率的情况。</p><h3 id="代码构建"><a href="#代码构建" class="headerlink" title="代码构建"></a>代码构建</h3><blockquote><ul><li><p>初始化GPIO结构体</p></li><li><p>初始化时基结构体</p></li><li><p>配置输出比较参数</p></li><li><p>使能定时器</p></li></ul></blockquote></li></ol><blockquote><p>也就是，在一定的频率下，通过不同的占空比 即可得到不同的输出模拟电压<br>pwm就是通过这种原理实现D&#x2F;A转换的。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/3380f0796eab461eb64bf86559486cb8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAfuWxseacieacqOWFrg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p><strong>为什么编码器读数要强制转换成short</strong></p><p>TIM_GetCounter 函数本身读回的是 uint16_t 数据类型,short强制类型转换。本来我们从定时器读取到的计数值范围是0到65535，但转换成short后范围就变成了-32768到32767，这是为了使得轮子的正转和反转(编码器向上和向下计数)能够对应正的计数值和负的计数值</p><p><strong>那么short与int的区别是什么, int不也可以吗</strong></p><p>可以, 区别在keil中所占字节不同</p><blockquote><p>int 占用 4 字节</p><p>short int 占用 2 字节</p></blockquote><p>[-BanlanceCar&#x2F;平衡小车V2&#x2F;keil STM32数据类型问题.png at master · Frank-zheng-C&#x2F;-BanlanceCar · GitHub](<a href="https://github.com/Frank-zheng-C/-BanlanceCar/blob/master/%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6V2/keil">https://github.com/Frank-zheng-C/-BanlanceCar/blob/master/平衡小车V2/keil</a> STM32数据类型问题.png)</p><p><strong>Encoder.c是否需要中断函数</strong></p><p>个人觉得可加可不加, 因为这里中断函数只是在溢出的时候清除中断标志位, 防止计数停止</p><p>由于函数里编码器读取计数值后会对清零计数值, 所以一般不会溢出</p><table><thead><tr><th>名称</th><th>全称类型说明符</th><th>缩写类型说明符</th><th>位数</th><th>范围</th></tr></thead><tbody><tr><td>整型</td><td>int</td><td>int</td><td>16位</td><td>-32768至+32767</td></tr><tr><td>无符号整型</td><td>unsigned int</td><td>unsigned</td><td>16位</td><td>0 至 65,535</td></tr><tr><td>短整型</td><td>short int</td><td>short</td><td>16位</td><td>-32768至+32767</td></tr><tr><td>无符号短整型</td><td>unsigned short int</td><td>unsigned short</td><td>16位</td><td>0 至 65,535</td></tr><tr><td>长整型</td><td>long int</td><td>long</td><td>32位</td><td>-2,147,483,648 至 2,147,483,647</td></tr><tr><td>无符号长整型</td><td>unsigned long int</td><td>unsigned long</td><td>32位</td><td>0至4,294,967,295</td></tr></tbody></table><p>编码器线数：线数就是编码器的分辨率，即转一圈发出的脉冲数</p><p>脉冲值正比于实际速度,但不是实际速度,需要进一步计算</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;速度测量值   velocity &#x3D; ( read_encoder2() + read_encoder3() )&#x2F;2;&#x2F;&#x2F;获取最新速度偏差&#x3D;&#x3D;测量速度（左右编码器之和）-目标速度（此处为零） Encoder_Least &#x3D;0-(encoder_left+encoder_right); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>个人理解:这个偏差最后要*kp,相当于直接算到kp里面了,<code>PWM_out=Velocity_Kp*EnC_Err_Lowout+Velocity_Ki*Encoder_S;</code></p><p><a href="https://blog.csdn.net/zhao_ke_xue/article/details/108305821?ops_request_misc=%7B%22request_id%22:%22169148867816800213097839%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=169148867816800213097839&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-3-108305821-null-null.142%5Ev92%5Einsert_down28v1&utm_term=%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E7%9A%84%E5%AE%9E%E9%99%85%E9%80%9F%E5%BA%A6&spm=1018.2226.3001.4187">平衡小车从原理到实践_平衡小车控制原理_白茶-清欢的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_56760882/article/details/123935485?ops_request_misc=&request_id=&biz_id=102&utm_term=%E9%9C%8D%E5%B0%94%E7%BC%96%E7%A0%81%E7%94%B5%E6%9C%BA%E7%9A%84%E7%BA%BF%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-123935485.142%5Ev89%5Einsert_down28v1,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">【一文读懂】如何用编码器测速_荒野火狐的博客-CSDN博客</a></p><h3 id="MPU6050"><a href="#MPU6050" class="headerlink" title="MPU6050"></a>MPU6050</h3><p>参考<a href="">     </a></p><p>有一个问题:<br>mpu6050供电时候的位姿不同确定的机械中值也不同</p><img src="/2022/06/24/20h-stm32f103-balance-car/01.jpg" class="" title="大佬的方法"><h1 id="重学平衡小车"><a href="#重学平衡小车" class="headerlink" title="重学平衡小车"></a>重学平衡小车</h1><h2 id="PID控制"><a href="#PID控制" class="headerlink" title="PID控制"></a>PID控制</h2><p>比例项：提高响应速度，减小静差。</p><p>积分项：消除稳态误差。只要有偏差，我就积分，有一丁点偏差，我也会积分。积积，就会非常大。直到你偏差变为0.</p><p>微分项：减小震荡以及超调。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Pwm&#x3D;Kp*e(k)+Ki*∑e(k)+Kd*[e(k)-e(k-1)]Kp*e(k)Ki*∑e(k)Kd*[e(k)-e(k-1)]Ki&#x3D;Kp*(1&#x2F;Ti) *TiKd&#x3D;Kp*(1&#x2F;T)*Td可见Ki、Kd都有Kp、所以Kp的值也会影响Ki、Kd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="位置PID"><a href="#位置PID" class="headerlink" title="位置PID"></a>位置PID</h3><p><strong>1.理论分析</strong></p><p>位置闭环控制就是根据编码器的脉冲累加测量电机的位置信息，并与目标值进行比较，得到控制偏差，</p><p>然后通过对偏差的比例、积分、微分进行控制，使偏差趋向于零的过程。</p><p><strong>2.公式</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Pwm&#x3D;Kp\*e(k)+Ki\*∑e(k)+Kd\*[e(k)-e(k-1)]e(k)：本次偏差e(k-1)：上一次的偏差  ∑e(k)：e(k)以及之前的偏差的累积和;其中k为1,2,,k;Pwm代表输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.结构框图</p><style>.iqymmvwycnzy{zoom:150%;}</style><img src="/2022/06/24/20h-stm32f103-balance-car/wps1.jpg" class="iqymmvwycnzy" alt="img"><ol start="4"><li>C语言实现</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">int Position_PID (int Encoder , int Target) &#123;   static float Bias, Pwm, Integral_bias, Last_Bias;  Bias&#x3D;Encoder-Target; &#x2F;&#x2F;计算偏差  Integral_bias+&#x3D;Bias; &#x2F;&#x2F;求出偏差的积分     Pwm&#x3D;Position_KP*Bias+Position_KI*Integral_bias+Position_KD*(Bias-Last_Bias);  &#x2F;&#x2F;位置式PID控制器     Last_Bias&#x3D;Bias;    &#x2F;&#x2F;保存上一次偏差   return Pwm;      &#x2F;&#x2F;输出 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-公式为什么kp不-误差"><a href="#2-公式为什么kp不-误差" class="headerlink" title="2.公式为什么kp不*误差"></a>2.公式为什么kp不*误差</h1><h3 id="串级PID"><a href="#串级PID" class="headerlink" title="串级PID"></a>串级PID</h3><p><strong>直立环</strong></p><ol><li><p>平衡理论</p><p>小车往那边倒，车轮就往哪边开，既可以保持车子的平衡。</p><img src="/2022/06/24/20h-stm32f103-balance-car/wps2.jpg" class="" title="img"></li><li><p>公式</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a&#x3D;b1*θ+b2*θ;——&gt;比例微分控制【PDout&#x3D;Kp*Angle+Kd*( Angle-Angle_last)】<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>结构框图</p></li></ol><style>.jojqpqjfxjnv{zoom:150%;}</style><img src="/2022/06/24/20h-stm32f103-balance-car/wps3.jpg" class="jojqpqjfxjnv" alt="img"> <p><strong>直立环：让小车角度趋近0；</strong></p><p><strong>速度环：让电机速度趋近0；</strong></p><h3 id="速度环、串级PID"><a href="#速度环、串级PID" class="headerlink" title="速度环、串级PID"></a>速度环、串级PID</h3><style>.txvbntnpmngo{zoom: 150%;}</style><img src="/2022/06/24/20h-stm32f103-balance-car/wps4.jpg" class="txvbntnpmngo" alt="img"> <p>速度环输入：1.给定速度。2.速度反馈。</p><p>输出：<strong>角度值</strong>（直立环的期望速度输入）</p><p>直立环输入：1.给定角度（速度环输出）。2.角度反馈</p><p>输出：PWM（直接控制小车）</p> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Vertical_out&#x3D;Kp1*( real_Angle- expect_Angle)+Kd*D( real_Angle- expect_Angle) &#x2F;&#x2F;直立PD控制器Velocity_out &#x3D;Kp2*(Encoder_ real- Encoder_ expect)+Ki*S(Encoder_ real- Encoder_ expect) &#x2F;&#x2F;速度PI控制器（NOTE：（1）Velocity_out &#x3D; expect_Angle.（2）Kp1：Vertical_Kp.（3）Kp2：Velocity_Kp.）&#x2F;&#x2F;解释直立环输出&#x3D;Kp1*（真实角度-期望角度+机械中值）+Kd*角度偏差的微分  &#x2F;&#x2F;角度偏差&#x3D;真实角度-期望角度速度环输出&#x3D;Kp2*（反馈编码器值-期望编码器值）+Ki*编码器偏差的积分&#x2F;&#x2F;编码器偏差&#x3D;反馈编码器值-期望编码器值（NOTE：（1）速度环输出&#x3D;直立环的期望角度。（2）Kp1：直立环Kp。（3）Kp2：速度环Kp。）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><strong>为什么输出是角度值呢</strong></li></ol><p>​是因为就是这样定义的吗,这样的Kp就相当于<strong>计数值与角度值的线性关系</strong></p><blockquote><p>在这个控制系统中，速度环的输出实际上是一个<strong>中间变量</strong>，它将速度控制转换为角度控制的设定值。这样做的原因在于平衡小车的物理和动力学特性。小车为了向前或向后移动，必须倾斜到一定角度，利用重力分力来产生前进或后退的驱动力。因此，通过调整小车的倾斜角度，我们可以间接控制它的速度。</p></blockquote><p>也就是说, 这样的Kp就相当于<strong>计数值与角度值的线性关系</strong>, 是人为定义通过调节kp达到的输出的角度值, 也可以输出别的, 改变kp就变成了其他的输出量</p><blockquote><p>对，你的理解是正确的。在平衡小车的PID控制中，Kp（比例系数）的设定基本上定义了输入（如速度误差或角度误差）与输出（如倾斜角度或PWM信号）之间的线性关系。通过调节Kp的大小，可以改变这种线性关系的敏感度和响应速度，从而影响小车的控制效果。</p><p>总结来说，Kp的设定是人为定义的，通过调节它可以改变控制系统的行为。不仅限于输出角度或PWM，理论上可以调整PID控制器来输出任何通过数学关系能够从输入误差计算得到的量。这种灵活性使得PID控制器非常适用于各种需要精确控制的自动化系统。</p></blockquote><p>我的理解是这个角度输出<strong>我定义的</strong>,我也可以打那将其定义为角速度,加速度,力矩,都可以对吗,因为我可以通过调节kp调节他们之间的线性关系,比如我需要输入5时,输出10的,力矩,那么kp,就为2,输出就为力矩</p><blockquote><p>对, 输出的物理量（如角度、角速度、加速度、力矩等）是由设计者根据具体应用需求来定义的。通过调节PID控制器的参数（Kp、Ki、Kd），你可以设定输入和输出之间的具体数学关系，从而控制系统的行为。</p></blockquote><p>直立环输入：1.给定角度（速度环输出）。2.角度反馈</p><p>输出：PWM（直接控制小车）</p> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Vertical_out&#x3D;Kp1*( real_Angle- expect_Angle)+Kd*D( real_Angle- expect_Angle) &#x2F;&#x2F;直立PD控制器Velocity_out &#x3D;Kp2*(Encoder_ real- Encoder_ expect)+Ki*S(Encoder_ real- Encoder_ expect) &#x2F;&#x2F;速度PI控制器（NOTE：（1）Velocity_out &#x3D; expect_Angle.（2）Kp1：Vertical_Kp.（3）Kp2：Velocity_Kp.）【中文】直立环输出&#x3D;Kp1*（真实角度-期望角度+机械中值）+Kd*角度偏差的微分  &#x2F;&#x2F;角度偏差&#x3D;真实角度-期望角度速度环输出&#x3D;Kp2*（反馈编码器值-期望编码器值）+Ki*编码器偏差的积分&#x2F;&#x2F;编码器偏差&#x3D;反馈编码器值-期望编码器值（NOTE：（1）速度环输出&#x3D;直立环的期望角度。（2）Kp1：直立环Kp。（3）Kp2：速度环Kp。）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>速度环是正反馈还是负反馈</strong></li></ol><blockquote><p>正反馈</p><p>因为当车身向右倾斜时,会产生误差,如果此时是负反馈,导致车轮反转和停止都会加速小车倒下</p><p>所以车身右倾车轮需要往右转,倾斜角度越大,转速越快</p></blockquote><ol start="3"><li><p>速度环起什么作用</p></li><li><p>只用直立环是否可行</p></li></ol><blockquote><p><strong>只有直立环的情况</strong></p><ul><li><strong>直立环</strong>：保持垂直。直立环通过比较当前角度与目标角度（通常是0度，即完全垂直）的差异来计算控制信号，调整电机以维持平衡。如果小车被推动，它会自动调整角度回到平衡点，但不会主动返回到原始位置。</li><li>也就是说,向右推,小车会向右走,直到角度变为期望角度(0),但是<code>如果幅度较大,加速来不及,小车会直接诶倒下</code></li></ul><p><strong>加入速度环</strong></p><ul><li><strong>速度环</strong>：当加入速度环后，系统不仅能维持平衡，还能控制小车的位置或速度。速度环通过监测小车的实际位置或速度与期望位置或速度的偏差来生成控制信号。</li></ul></blockquote><blockquote><p>关于直立环反应慢的原因，以及速度环如何提升系统响应速度的具体机制，这些问题都涉及到PID控制理论和平衡小车的动态性质。我们一步步来探讨这些问题，包括串级PID和并级PID在控制策略上的不同及其对系统性能的影响。</p><h3 id="为什么直立环反应较慢？"><a href="#为什么直立环反应较慢？" class="headerlink" title="为什么直立环反应较慢？"></a>为什么直立环反应较慢？</h3><ol><li><strong>物理和系统动力学限制</strong>：</li></ol><ul><li>直立环的目的是维持小车垂直平衡，这通常依赖于倾角传感器（如陀螺仪）的反馈。倾角的测量和响应虽然在时间上很短，但存在物理延迟，特别是在倾角变化速度很快时，系统需要时间来产生足够的反馈力。</li><li>直立环的PID参数设置必须谨慎，特别是微分项（Kd），它对小车的动态响应非常敏感，过高可能会导致振荡，过低则可能响应不足。</li></ul><ol start="2"><li><strong>计算延迟</strong>：</li></ol><ul><li>PID控制算法虽然执行速度快，但仍受限于处理周期和控制算法的复杂性。尤其是在需要高精度或高反应速度的场合，控制器的计算能力可能成为瓶颈。</li></ul><h3 id="速度环如何加快响应？"><a href="#速度环如何加快响应？" class="headerlink" title="速度环如何加快响应？"></a>速度环如何加快响应？</h3><ol><li>预测和前馈控制</li></ol><ul><li>速度环可以视作一种前馈控制机制，当直立环计算出需要改变倾斜角度以保持平衡时，速度环通过调整小车的移动速度来辅助这一变化。这样可以提前调整，而不是完全依赖于倾角的被动响应。</li><li>速度环通过增加或减少小车的整体速度，加速达到直立环计算的目标倾斜角度，从而加快系统对失衡状态的响应。</li></ul><h3 id="串级PID与并级PID的区别"><a href="#串级PID与并级PID的区别" class="headerlink" title="串级PID与并级PID的区别"></a>串级PID与并级PID的区别</h3><p>尽管在最终输出上，串级和并级PID可能看起来类似（都是调整PWM信号），但控制逻辑和系统的内部动态有本质的不同：</p><ol><li><strong>串级PID</strong>：</li></ol><ul><li>在串级PID中，外环（速度环或位置环）的输出是内环（直立环）的输入。这意味着外环设定了一个目标倾斜角度，直立环根据这个目标倾斜角度调整PWM输出以尝试达到这个倾角。</li><li>这种层级结构使得每个环可以专注于一个具体的控制目标，如速度环控制行驶速度，直立环确保倾角调整，提升了控制精度和系统稳定性。</li></ul><ol start="2"><li><strong>并级PID</strong>：</li></ol><ul><li>在并级PID中，直立环和速度环各自独立计算各自的控制信号（PWM），然后将这些信号合并应用到驱动系统。每个环对最终的驱动信号直接贡献，无须通过另一个环的中介。</li><li>这种结构简化了控制系统的设计，但可能降低了控制的准确性和反应的协调性，因为各环的输出可能在没有足够协调的情况下直接叠加。</li></ul></blockquote><h1 id="没关系-岁月还长-有些问题可以慢慢想"><a href="#没关系-岁月还长-有些问题可以慢慢想" class="headerlink" title="没关系,岁月还长,有些问题可以慢慢想"></a>没关系,岁月还长,有些问题可以慢慢想</h1><p><a href="https://www.bilibili.com/video/BV1H7411k76N?vd_source=f525a47bd6d8cb5b154158289da1d4d4">平衡小车的代码框架——代码开源-第3.1节</a></p><h3 id="并级PID"><a href="#并级PID" class="headerlink" title="并级PID"></a>并级PID</h3><p>其实这个并级PID ,相当于二元函数,两个KP对应线性关系,输出PWM,请问对吗</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">是的，你的理解是正确的。在这个并级PID控制系统中，可以将其视为一个处理两个输入变量的二元函数，其中每个变量分别通过自己的PID控制器处理。这里的两个变量是小车的角度（直立环）和速度（速度环），每个环都有自己的比例系数（Kp），积分系数（Ki）以及微分系数（Kd）（虽然在速度环的代码示例中没有展示微分控制）。&#x2F;&#x2F;解析并级PID在并级PID中，每个控制环独立地计算其PID输出，然后将这些输出合并以形成最终的控制信号（如PWM）。在你提到的例子中，这种合并是简单的算术加法，即：每个控制环通过其比例（Kp）、积分（Ki）、和微分（Kd）参数独立响应其控制变量的偏差，这样的设计使得系统可以灵活调整对不同类型误差的响应。这里的关键是，**虽然每个环的输出是独立计算的，但在最终的执行动作上（如驱动电机的PWM信号）是相互影响的**&#x2F;&#x2F;特点与应用灵活性高：可以独立调整对角度和速度控制的敏感度和响应特性，使其适应不同的运行条件和性能要求。简化调试：调试时可以分别优化每个控制环，而不必担心其相互作用，简化了调试过程。然而，这也可能导致一些挑战：相互影响：在实际应用中，两个控制环的输出可能会相互影响，特别是在系统动态变化较大时，需要仔细调整参数以避免冲突。总的来说，你的理解是准确的，这种并级PID控制方式通过独立的线性关系（各自的PID环）合并输出，共同决定了最终的控制行为。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并级这里速度环是用来提高直立环的输出,从而提高这个系统的响应速度, 那我直接增到直立环的kp不行吗</p><h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><h2 id="pid调节过程及方法"><a href="#pid调节过程及方法" class="headerlink" title="pid调节过程及方法"></a>pid调节过程及方法</h2><h3 id="调参步骤："><a href="#调参步骤：" class="headerlink" title="调参步骤："></a>调参步骤：</h3><blockquote><p>1.确立机械中值。<br>2.直立环（内环）—Kp极性、Kp大小。Kd极性、Kd大小。<br>3.速度环（外环）——Kp&amp;Ki极性、Kp&amp;Ki大小。<br>4.转向环——系数极性、系数大小。</p></blockquote><h4 id="机械中值："><a href="#机械中值：" class="headerlink" title="机械中值："></a>机械中值：</h4><p>把平衡小车放在地面上，从前向后以及从后向前绕电机轴旋转平衡小车，两次的向另一边倒下的角度的中值，就是机械中值。</p><h4 id="直立环"><a href="#直立环" class="headerlink" title="直立环"></a>直立环</h4><p>Kp极性：</p><blockquote><p>极性错误：小车往哪边倒，车轮就往反方向开，会使得小车加速倒下。<br>极性正确：小车往哪边倒，车轮就往哪边开，以保证小车有直立的趋势。<br>Kp大小：<br>Kp一直增加，直到出现大幅低频震荡。<br>Kd极性：()调试kd时,kp暂时设为0()<br>极性错误：拿起小车绕电机轴旋转，车轮反向转动，无跟随。<br>极性正确：拿起小车绕电机轴旋转，车轮同向转动，有跟随。</p><p><strong>（那么这是为什么呢？？？）</strong></p><p>Kd大小：<br>Kd一直增加，直到出现高频震荡。</p></blockquote><p>直立环调试完毕后，对所有确立的参数乘以0.6作为最终参数。<br>原因：之前得到的参数都是Kp、Kd最大值，根据工程经验平衡小车的理想参数为最大参数乘以0.6求得。<br>结果：乘以0.6后，小车的抖动消失，但同时直立效果也变差。待下面加入速度环就能得到更好的性能。</p><h4 id="速度环"><a href="#速度环" class="headerlink" title="速度环"></a>速度环</h4><p>速度环参数调节前注意：</p><ul><li>在调试<code>速度环参数极性时</code>：需要去掉（注释掉）<code>直立环运算</code></li><li>在调试<code>速度环参数大小</code>时：再次引入（取消注释）<code>直立环运算</code></li></ul><blockquote><p> <code>转向环运算</code>始终是去掉（注释）的一个状态。若转向环已提前将参数调试好，则未注释也影响不大。<br>Kp&amp;Ki：</p><p>线性关系、Ki&#x3D;(1&#x2F;200)*Kp、仅调Kp即可。</p></blockquote><ul><li><p>Kp&amp;Ki极性：<br>极性错误：手动转动其中一个车轮，另一车轮会以同样速度反向旋转——典型负反馈。<br>极性正确：手动转动其中一个车轮，两个车伦会同向加速，直至电机最大速度——典型正反馈。</p></li><li><p>Kp&amp;Ki大小：<br>增加Kp&amp;Ki，直至：小车保持平衡的同时，速度接近于零。且回位效果较好。</p></li></ul><h4 id="转向环"><a href="#转向环" class="headerlink" title="转向环"></a>转向环</h4><ul><li>Kp极性：<br>极性错误：拿起小车，并将小车绕Z轴旋转，两车轮旋转的趋势与小车旋转趋势一致——典型正反馈。<br>极性正确：拿起小车，并将小车绕Z轴旋转，两车轮旋转的趋势与小车旋转趋势相反——典型负反馈。</li><li>Kp大小：<br>加大Kp，直至走直线效果较好，且无剧烈抖动。</li></ul><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><ol><li>在电源打开的情况下,试图拔电机线,结果板子烧了,不知道原因,又买了一块,我以为只是底板和核心板烧了,其他的元器件都是好的,结果又烧了(其他元器件也是坏的),损失亿点点,<code>之后所有的拔线插线操作我都关闭电源进行</code></li><li><code>蓝牙串口发送的数据与收到的数据不符</code>,收到的数据为asc码+回车的asc码,也就是发送1收到48,13,<br>解决:</li></ol><blockquote><p>代码是if(data&#x3D;&#x3D;0x01),我发送的数据也是0x01,实际上,前面的0x表示的是16进制,我只需要发送1就可以了,(否则就是十六进制发送四个字符)另外代码是if(data&#x3D;&#x3D;1),也没反应,因为字符需要加引号,即’1’<br>比如说75 &#x2F;16&#x3D;4…..11<br>11是b,所以<code>75化成十六进制是4b</code>,<code>写作0x4b</code>或4BH<br>4.目前遇到的问题:<br>oled闪屏<br>原因:I2C刷新频率太低,导致屏幕一闪一闪的,spi通信没有遇到这个问题<br>1，刷屏方式有没有问题，刷完第一屏，不用清屏，接着刷第二屏，可以减少闪烁感</p></blockquote><ol start="2"><li><p>iic通信速度调快点，iic 通信跳到1mbps试试</p></li><li><p>打点方式是不是最快的，屏幕可以iic连续写入方式，一个启始信号后面跟尽可能多的写入数据。一个启示一个数据，这样打点也会慢很多</p></li><li><p>刷新频率不够，你可以尝试提高刷新屏幕的任务的优先级</p></li><li><p>清屏太快？刚写完显示然后不加延时就清屏会闪烁的，OLED 屏幕是静态显示的，不重新写入数据是不会更新显示的，闪烁也有可能是在同一位置数据刷新过快，检查一遍程序</p></li><li><p>有可能你对屏幕进行了写入操作 但是这个操作不是连续完成的  被其他任务中断了</p></li><li><p>刷新的时间太长了，可能你的刷新操作被中断打断而中断又占用时间比较长</p></li><li><p>刷新率不够,估计是延时用多了</p></li><li><p>iic数据传输的速度太慢了可能，如果传输速度没问题可以看看有没有别的任务占用大量的资源。</p><blockquote><p><a href="https://www.icxbk.com/ask/detail/11888.html?page=2">参考文章</a><br><a href="https://blog.csdn.net/weixin_44457994/article/details/122116964?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-122116964-blog-123651067.pc_relevant_aa_2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-122116964-blog-123651067.pc_relevant_aa_2&utm_relevant_index=10">参考资料</a><br>接下来:找到提高刷新率的方法<br>1.mpu6050用硬件iic oled用软件iic<br>2.先尝试只让mpu6050显示在oled上</p></blockquote><h3 id="MPU6050-1"><a href="#MPU6050-1" class="headerlink" title="MPU6050"></a>MPU6050</h3></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">void MPU6050_EXIT_Init(void)&#123;  EXTI_InitTypeDef EXTI_InitStructure;  GPIO_InitTypeDef GPIO_InitStructure;  NVIC_InitTypeDef NVIC_InitStructure;                                              &#x2F;&#x2F;1.不加优先级,无法显示数据 &#x2F;&#x2F;2.为什么设置了kp值,小车没反应-&gt;因为玄学,重建文件夹复制进去就好了,也有可能是主控出问题了 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);  &#x2F;&#x2F;使能定时器PB的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);   &#x2F;&#x2F;外部中断，需要使能AFIO时钟                                        &#x2F;&#x2F;3.改oled要改.c初始化设置,.h引脚定义 &#x2F;&#x2F;4.改mpu要改.c初始化,.h引脚设置,但是因为用到了int中断引脚,所以还要去改int中断引脚的初始化.c,.h机的都要改&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.bluetooth(usart)出现电脑发送的的数据和单片机收到的数据不符的问题</p><blockquote><p>1.可能的原因,数据位不是8位<br>2.晶振问题,波特率问题</p></blockquote><p>4.玄学问题<br>同样的代码,其中一个就是不好使,从另一个工程复制过来的就好使,然后我把文件夹删了重新复制了.c,.h文件,你猜怎么着,誒,好使了,脑仁都要气没了</p><p>5.出现问题的检查步骤</p><ul><li>1.看下代码有没有引脚用错的问题</li><li>2.看看硬件有没有接线错误什么的,换个硬件试一下好使不(因为有的硬件他坏了但是没完全坏,他只是这个功能不能用了,也相当于坏了)</li><li>3.仔细检查程序,恩,就是不停的试错吧(煎熬的过程)</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【平衡小车在线编程课程视频（1~3节合集版本）（2月12日更新）】<a href="https://www.bilibili.com/video/BV1j7411z7uX?p=3&vd_source=f525a47bd6d8cb5b154158289da1d4d4">https://www.bilibili.com/video/BV1j7411z7uX?p=3&amp;vd_source=f525a47bd6d8cb5b154158289da1d4d4</a></p><p><a href="">教程</a><br>感谢大佬’天下行走’<br><a href="https://blog.csdn.net/Fanxy__/article/details/123113682?spm=1001.2101.3001.6650.9&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-9-123113682-blog-113866015.pc_relevant_multi_platform_whitelistv2_ad_hc&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-9-123113682-blog-113866015.pc_relevant_multi_platform_whitelistv2_ad_hc&utm_relevant_index=12">参考文章</a>    </p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32F103 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nonebot2的插件编写</title>
      <link href="/2022/06/15/19p-nonebot2-plugin/"/>
      <url>/2022/06/15/19p-nonebot2-plugin/</url>
      
        <content type="html"><![CDATA[<h2 id="我的第一个插件-ping"><a href="#我的第一个插件-ping" class="headerlink" title="我的第一个插件-ping"></a>我的第一个插件-ping</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsimport nonebotimport httpximport jsonfrom nonebot import on_commandfrom nonebot.matcher import Matcherfrom nonebot.params import ArgPlainText, CommandArgfrom fastapi import FastAPIfrom nonebot.rule import to_mefrom nonebot.typing import T_Statefrom nonebot.adapters import Bot, Eventfrom nonebot.permission import SUPERUSERfrom nonebot.adapters import Messageping &#x3D; on_command(&quot;ping &quot;, aliases&#x3D;&#123;&quot;p&quot;, &quot;pingg&quot;&#125;, priority&#x3D;10)     @ping.handle()async def ip_address(event: Event,matcher: Matcher, args: Message &#x3D; CommandArg()):    ip &#x3D; str(event.get_message()).strip(&quot;&#x2F;ping &quot;) #strip 剥离       #if args:        #return    #async with httpx.AsyncClient() as client:        #response &#x3D; await client.get(f&quot;https:&#x2F;&#x2F;api.iyk0.cn&#x2F;api&#x2F;ip?ip&#x3D;&#123;ip&#125;&quot;)    #if response.is_error:        #logger.error(&quot;获取信息失败&quot;)        #return    #data &#x3D; response.json()    headers&#x3D;&#123;     &quot;user-agent&quot;: &quot;Mozilla&#x2F;5.0 (Linux; Android 6.0; Nexus 5 Build&#x2F;MRA58N) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;106.0.0.0 Mobile Safari&#x2F;537.36 Edg&#x2F;106.0.1370.52&quot;    &#125;    url &#x3D; f&quot;https:&#x2F;&#x2F;api.iyk0.cn&#x2F;api&#x2F;ip?ip&#x3D;&#123;ip&#125;&quot;       resp &#x3D; requests.get(url, headers&#x3D; headers)    resp.encoding &#x3D; &#39;utf-8&#39;    #resp &#x3D; resp.text      #retdata &#x3D; json.loads(resp.text)    #msp &#x3D; str(resp.json())    retdata &#x3D; resp.json()        data &#x3D;&#123;    &quot;code&quot;: retdata[&#39;code&#39;],    &quot;country&quot;: retdata[&#39;data&#39;][&#39;country&#39;],      &quot;city&quot;: retdata[&#39;data&#39;][&#39;city&#39;],    &quot;lon&quot;: retdata[&#39;data&#39;][&#39;lon&#39;],    &quot;lat&quot;: retdata[&#39;data&#39;][&#39;lat&#39;],   &#125;   #data2 &#x3D; json.dumps(data, indent&#x3D;4)    data2 &#x3D;str(&quot;code:&quot;+data[&quot;code&quot;]+&quot;\n&quot;+&quot;国家:&quot;+data[&#39;country&#39;]+&quot;\n&quot; +&quot;城市:&quot;+ data[&#39;city&#39;]+&quot;\n&quot;+&quot;经度:&quot;+str(data[&quot;lon&quot;])+&quot;\n&quot; +&quot;纬度:&quot;+str(data[&#39;lat&#39;]))    #msg &#x3D; data[&#39;data&#39;][&#39;country&#39;]    await ping.finish( data2)               # 提取json 关键数据方法        # 用res变量接收 get_url返回的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>第2行导入的on_command 注册一个消息类型的命令处理器，也就是说，让机器人识别你的命令需要用到他。logger是nb 日志记录器对象。详见： NoneBot.log 模块</p></blockquote><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><blockquote><p>ping表示命令名<br>aliases 表示命令别名，即 p、pingg、 都会响应这个事件<br>priority表示优先级，数值越小越优先<br>第30行，紧接着@ping.handle() ping被事件响应器的装饰器装饰从而成为事件响应器的事件处理函数,<br>handle()是简单的为事件响应器添加一个事件处理函数，这个函数将会在上一个处理函数正常返回执行完毕后立即执行。</p></blockquote><blockquote><p>我们在注册事件时传入了Event故这里可以直接ping.send(message&#x3D;xxx),我们也可以：bot.send(event&#x3D;event,message&#x3D;xxx)</p></blockquote><blockquote><p>其中message参数是我们要发送的消息，可以是纯文本 message&#x3D;”你好” ，这里使用的 MessageSegment 是nb对cq协议的适配，可用于发送CQ码等（个人理解），即</p></blockquote><h3 id="如果你要发送图片"><a href="#如果你要发送图片" class="headerlink" title="如果你要发送图片"></a>如果你要发送图片</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">await sixty.send(message&#x3D;MessageSegment.image(img_url))等价于（不推荐）rely&#x3D;[&#123;      &quot;type&quot;: &quot;image&quot;,      &quot;data&quot;: &#123;      &quot;file&quot;: img_url              &#125;&#125;]await sixty.send(message&#x3D;rely)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如果你要发送文本-图片，如下写法皆可："><a href="#如果你要发送文本-图片，如下写法皆可：" class="headerlink" title="如果你要发送文本+图片，如下写法皆可："></a>如果你要发送文本+图片，如下写法皆可：</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">await sixty.send(message&#x3D;&quot;今日早报&quot;+MessageSegment.image(img_url))rely&#x3D;[&#123;      &quot;type&quot;: &quot;text&quot;,      &quot;data&quot;: &#123;      &quot;text&quot;: &quot;今日早报&quot;              &#125;&#125;,&#123;      &quot;type&quot;: &quot;image&quot;,      &quot;data&quot;: &#123;      &quot;file&quot;: img_url              &#125;&#125;]await sixty.send(message&#x3D;rely)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="发送本地图片-暂时还没用过发本地图片-："><a href="#发送本地图片-暂时还没用过发本地图片-：" class="headerlink" title="发送本地图片(暂时还没用过发本地图片)："></a>发送本地图片(暂时还没用过发本地图片)：</h3><p>利用gocq+nb作为机器人发送本地图片时，若使用相对路径，要记得 路径是相对gocq的 而不是相对nb项目的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">await sixty.send(message&#x3D;MessageSegment.image(&quot;file:&#x2F;&#x2F;&#x2F;路径&quot;))rely&#x3D;[&#123;      &quot;type&quot;: &quot;image&quot;,      &quot;data&quot;: &#123;      &quot;file&quot;: &quot;file:&#x2F;&#x2F;&#x2F;路径&quot;              &#125;&#125;]await sixty.send(message&#x3D;rely)路径问题本人一般使用Path:from pathlib import Pathimg_path &#x3D; Path() &#x2F; &quot;xxx.png&quot;# .resolve() 转为绝对路径img_path2 &#x3D; img_path.resolve()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>实际上就是爬取数据,提取需要部分,调用nonebot发送<br>要学会爬取动态页面的数据</p></blockquote><p>(插件编写参考大佬)[<a href="https://yzyyz.top/archives/nb2b1.html#%E7%BC%96%E5%86%99%E6%8F%92%E4%BB%B6]">https://yzyyz.top/archives/nb2b1.html#%E7%BC%96%E5%86%99%E6%8F%92%E4%BB%B6]</a></p><h2 id="定时器任务"><a href="#定时器任务" class="headerlink" title="定时器任务"></a>定时器任务</h2><p>基本示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import nonebotfrom nonebot import require,get_bots#[nonebot本模块主要定义了 NoneBot 启动所需函数，供 bot 入口文件调用。](https:&#x2F;&#x2F;v2.nonebot.dev&#x2F;docs&#x2F;api&#x2F;index#get_bot)#使用nonebot.require模块导入nonebot_plugin_apscheduler的schedulertiming &#x3D; require(&quot;nonebot_plugin_apscheduler&quot;).scheduler#设置在几点启动脚本@timing.scheduled_job(&quot;cron&quot;, hour&#x3D;&#39;22&#39;, minute&#x3D;&#39;56&#39;, id&#x3D;&quot;drink_tea&quot;)#启动的脚本async def drink_tea():    bot, &#x3D; get_bots().values()    # 发送一条群聊信息    await bot.send_msg(        message_type&#x3D;&quot;group&quot;,        group_id&#x3D;123456789,        message&#x3D;&#39;这是一条群聊信息&#39;  )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/starvapour/article/details/124780376">参考文章</a><br><a href="https://blog.csdn.net/a1255652/article/details/118740313">参考文章2</a><br><a href="https://github.com/botuniverse/onebot-11/blob/master/event/message.md">onebot-11文档</a><br><a href="https://docs.go-cqhttp.org/">go-cqhttp文档</a><br><a href="https://v2.nonebot.dev/">nonebot2文档</a><br><a href="https://github.com/MRSlouzk/Nonebot-plugintutorials">一个大佬的教程文档</a><br><a href="https://www.bilibili.com/read/cv19736511?spm_id_from=333.999.0.0">大佬的入门建议</a></p>]]></content>
      
      
      <categories>
          
          <category> QQbot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nonebot2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>立创EDA的使用</title>
      <link href="/2022/06/12/18h-eda-error/"/>
      <url>/2022/06/12/18h-eda-error/</url>
      
        <content type="html"><![CDATA[<h1 id="使用立创EDA画PCB"><a href="#使用立创EDA画PCB" class="headerlink" title="使用立创EDA画PCB"></a>使用立创EDA画PCB</h1><p>EDA的优势是原理图库和封装库比较多,比较方便,所以一般只需要绘制原理图和PCB即可</p><h2 id="使用过程中遇到的问题"><a href="#使用过程中遇到的问题" class="headerlink" title="使用过程中遇到的问题"></a>使用过程中遇到的问题</h2><h3 id="该网络标签未与任何引脚连接"><a href="#该网络标签未与任何引脚连接" class="headerlink" title="该网络标签未与任何引脚连接"></a>该网络标签未与任何引脚连接</h3><p>解决</p><blockquote><p>1.可能没有连接好删除重新连接<br>2.网络标签的白色十字要放在导线或者管脚上<br>3.不是在库文件画好再放置到原理图的，直接在原理图画符号不是一个完整的符号,需要&gt;文件&gt;新建&gt;符号,把对应的原理图部分放进去,保存好</p></blockquote><h3 id="报错网络未连接完整"><a href="#报错网络未连接完整" class="headerlink" title="报错网络未连接完整"></a>报错网络未连接完整</h3><blockquote><p>检查,可能是有的原理图的网络标签打错了,(还原力吐的时候点要朝外)<br>pcb的话按着提示一个一个找,可能是有的导线没有连接到中心点,gnd线也要连接,之前看的铺铜gnd就不用连接了,后来说需要什么过孔,我暂时还未了解,我把gnd都连上了</p></blockquote><h2 id="原理图部分建议"><a href="#原理图部分建议" class="headerlink" title="原理图部分建议"></a>原理图部分建议</h2><blockquote><p>原理图一定要检查好,网络标签是否打错,填没填加到符号,有没有封装,引脚是否都对应正确,按顺序走一下能够减少很多错误</p></blockquote><h2 id="PCB部分建议"><a href="#PCB部分建议" class="headerlink" title="PCB部分建议"></a>PCB部分建议</h2><blockquote><p>同样,元器件摆放好之后(元器件摆放需要提前量好间距),按顺序走一下,看看每根线连接的引脚是否正确(放大可以看到引脚的网络标签),添加丝印(个人喜欢添加日期),然后布线要考虑间距,最后铺铜,检查电气规则</p></blockquote><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>一定要开启自动备份,并且时不时ctrl+s一下,完成后再克隆一份,毕竟数据很重要</p><p><a href="https://blog.csdn.net/qq_41560850/article/details/124307758">参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 立创EDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos挂载硬盘</title>
      <link href="/2022/06/09/17l-centos-download-disk/"/>
      <url>/2022/06/09/17l-centos-download-disk/</url>
      
        <content type="html"><![CDATA[<h1 id="centos挂载硬盘"><a href="#centos挂载硬盘" class="headerlink" title="centos挂载硬盘"></a>centos挂载硬盘</h1><h2 id="挂载磁盘前需要查看的信息"><a href="#挂载磁盘前需要查看的信息" class="headerlink" title="挂载磁盘前需要查看的信息"></a>挂载磁盘前需要查看的信息</h2><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">df -h     　　　　#查看linux下的硬盘挂载的空间、使用空间fdisk -l         #查看磁盘信息lsblk    　　　　 #列出块设备信息（df -h不能看到的卷）mount      　　   #挂载命令#Mounted on 显示的是挂载的目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>df -h<br>没有看见未挂载的盘，现在我们要挂载<br>lsblk<br>查看没有挂载的硬盘是否检测在系统中<br><img src="http://45.92.193.42:7788/i/2022/07/12/62cd3bc716c9e.jpg" alt="01.jpg"><br>我这个是已经挂载完的,未挂载的磁盘 mountpoint应该没有挂载目录,我这里的挂载目录是&#x2F;data,而vda1挂载目录是&#x2F;也就是系统盘</p></blockquote><h2 id="开始挂载"><a href="#开始挂载" class="headerlink" title="开始挂载"></a>开始挂载</h2><ul><li><h3 id="查看所有识别到的磁盘情况"><a href="#查看所有识别到的磁盘情况" class="headerlink" title="查看所有识别到的磁盘情况"></a>查看所有识别到的磁盘情况</h3><blockquote><p>fdisk -l<br> lsblk           </p></blockquote></li><li><h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><blockquote><p>fdisk &#x2F;dev&#x2F;vdb1<br>依次输入<br>n      #添加一个分区<br>p      #主分区<br>1<br>回车   #两个回车指是开始和结束的磁盘扇区大小；<br>回车<br>w      #写入磁盘</p></blockquote></li><li><h3 id="通知系统分区表的变化"><a href="#通知系统分区表的变化" class="headerlink" title="通知系统分区表的变化"></a>通知系统分区表的变化</h3><blockquote><p>partprobe</p></blockquote></li><li><h3 id="查看磁盘分区情况"><a href="#查看磁盘分区情况" class="headerlink" title="查看磁盘分区情况"></a>查看磁盘分区情况</h3><blockquote><p>df -TH<br>（centos7以下版本系统，此时可能看不到最新分区）</p></blockquote></li><li><h3 id="格式化磁盘"><a href="#格式化磁盘" class="headerlink" title="格式化磁盘"></a>格式化磁盘</h3><blockquote><p>mkfs -t ext4 &#x2F;dev&#x2F;vdb1</p></blockquote></li><li><h3 id="创建目录，挂载磁盘"><a href="#创建目录，挂载磁盘" class="headerlink" title="创建目录，挂载磁盘"></a>创建目录，挂载磁盘</h3><blockquote><p>mkdir &#x2F;data<br>mount &#x2F;dev&#x2F;vdb1&#x2F;data<br>再次查看磁盘分区情况<br>df -TH<br>（可以看到新分区了，表示挂载成功）</p></blockquote></li><li><h3 id="获取磁盘UUID"><a href="#获取磁盘UUID" class="headerlink" title="获取磁盘UUID"></a>获取磁盘UUID</h3><blockquote><p>blkid &#x2F;dev&#x2F;vdb1<br>（获取挂载点uuid值，用于第九步添加fstab使用）</p></blockquote></li><li><h3 id="修改fstab文件"><a href="#修改fstab文件" class="headerlink" title="修改fstab文件"></a>修改fstab文件</h3><p>系统开机时会主动读取&#x2F;etc&#x2F;fstab这个文件中的内容，根据文件里面的配置挂载磁盘。</p><blockquote><p>每一列代表的含义：<br>第一列：磁盘的编号或者UUID &#x2F;&#x2F;挂载点需要使用UUID来进行挂载<br>第二列：需要挂载到的目录<br>第三列：文件系统格式<br>第四列：系统的默认参数，一般填defaults<br>第五列：是否做dump备份，0表示不备份，1表示每天备份，2表示不定期备份<br>第六列：是否开机检查扇区：0表示不检查，1表示最早检验，2表示在1之后开始检验</p></blockquote><blockquote><p>vi &#x2F;etc&#x2F;fstab</p></blockquote><blockquote><p>UUID&#x3D;fc331ce5-695c-4ff9-ae9a-d68f4541e10f &#x2F;app ext4 defaults 0 2</p></blockquote><p>#防止服务器重启磁盘挂载失效</p><blockquote><p>挂载的限制：<br>根目录必须挂载<br>挂载点必须是已经存在的目录<br>所有挂载点在同一时间只能被挂载一次<br>所有分区在同一时间只能挂在一次<br>若进行卸载，需要先umount并删除fstab</p></blockquote></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/zysh888/article/details/103287590">参考文章1</a><br><a href="https://blog.csdn.net/guibear/article/details/94899450?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2-94899450-blog-124615494.pc_relevant_downloadblacklistv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2-94899450-blog-124615494.pc_relevant_downloadblacklistv1&utm_relevant_index=4">参考文章2</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python常见报错以及解决</title>
      <link href="/2022/06/03/16p-python-command-erro/"/>
      <url>/2022/06/03/16p-python-command-erro/</url>
      
        <content type="html"><![CDATA[<h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><h3 id="添加-删除然软连接"><a href="#添加-删除然软连接" class="headerlink" title="添加&#x2F;删除然软连接"></a>添加&#x2F;删除然软连接</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">#添加python3软链接：ln -s &#x2F;usr&#x2F;local&#x2F;python3.10.1&#x2F;bin&#x2F;python3.10.1 &#x2F;usr&#x2F;bin&#x2F;python3#添加pip3软链接：ln -s &#x2F;usr&#x2F;local&#x2F;python3.10.1&#x2F;bin&#x2F;pip3.10.1 &#x2F;usr&#x2F;bin&#x2F;pip3#删除软连接的方法(&#96;慎用,不然会连着文件一起删除&#96;)unlink &#x2F;usr&#x2F;local&#x2F;python3.10.1&#x2F;bin&#x2F;python3.10.1&#x2F;usr&#x2F;bin&#x2F;python3rm -rf &#x2F;usr&#x2F;local&#x2F;python3.10.1&#x2F;bin&#x2F;python3.10.1&#x2F;usr&#x2F;bin&#x2F;python3    #末尾有&#96;&#x2F;&#96;的是连文件一起删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="centos安装python时易出现的error"><a href="#centos安装python时易出现的error" class="headerlink" title="centos安装python时易出现的error"></a>centos安装python时易出现的error</h2><h3 id="WARNING-Retrying-Retry-total-1"><a href="#WARNING-Retrying-Retry-total-1" class="headerlink" title="WARNING: Retrying (Retry(total&#x3D;1,"></a>WARNING: Retrying (Retry(total&#x3D;1,</h3><p>connect&#x3D;None, read&#x3D;None, redirect&#x3D;None, status&#x3D;None)) after connec<br>原因:其实就是找第三方库的时候链接超时，总是获取不到。自带的pip命令去国外的服务器请求第三方包了，所以超时，因而换成国内镜像下载即可，并且要信任镜像的URL。</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">解决：以阿里的镜像为例第一步：开始报错pip3 install xlrd第二步：加上镜像地址，继续报错（因为未信任请求站点）pip3 install xlrd -i http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;第三步：加上镜像，加上信任站点pip3 install xlrd -i http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F; --trusted-host mirrors.aliyun.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ModuleNotFoundError-No-module-named-‘-ssl‘问题"><a href="#ModuleNotFoundError-No-module-named-‘-ssl‘问题" class="headerlink" title="ModuleNotFoundError: No module named ‘_ssl‘问题"></a>ModuleNotFoundError: No module named ‘_ssl‘问题</h3><p>centos安装python3时,查阅知需要的openssl版本最低为1.0.2，但是centos 默认的为1.0.1，所以需要重新更新openssl<br>安装依赖库</p><blockquote><p>yum install -y zlib zlib-dev openssl-devel sqlite-devel bzip2-devel libffi libffi-devel gcc gcc-c++</p></blockquote><h4 id="安装新版本的openssl"><a href="#安装新版本的openssl" class="headerlink" title="安装新版本的openssl"></a>安装新版本的openssl</h4><p>注意！openssl配置是用config，而不是configure，另外openssl编译安装依赖zlib动态库，所以一定要shared zlib 自行到官网查阅最新版本~</p><p><a href="http://www.openssl.org/source/">openssl安装包官网下载地址</a></p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">wget http:&#x2F;&#x2F;www.openssl.org&#x2F;source&#x2F;openssl-1.1.1.tar.gz            #（有网就可以直接下载，没网下载安装包通上传到centos中）tar -zxvf openssl-1.1.1k.tar.gz                                      （ 解压对应版本安装包）cd openssl-1.1.1k                                                     （进入对应的解压目录）.&#x2F;config --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;openssl shared zlib  (prefix为配置安装目录，shared zlib 安装依赖库）这一步最重要，一定要sharedmake &amp;&amp; make install                                                         （编译、安装）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置环境变量LD-LIBRARY-PATH（二选一）"><a href="#设置环境变量LD-LIBRARY-PATH（二选一）" class="headerlink" title="设置环境变量LD_LIBRARY_PATH（二选一）"></a>设置环境变量LD_LIBRARY_PATH（二选一）</h4><p>这一步一定要有！！LD_LIBRARY_PATH环境变量主要用于指定查找共享库（动态链接库）时除了默认路径之外的其他路径。当执行函数动态链接.so时，如果此文件不在缺省目录下‘&#x2F;lib’ and ‘&#x2F;usr&#x2F;lib’，那么就需要指定环境变量LD_LIBRARY_PATH</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">（1）用户环境变量：echo &quot;export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;usr&#x2F;local&#x2F;openssl&#x2F;lib&quot; &gt;&gt; &#x2F;usr&#x2F;local&#x2F;.bash_profile     (在用户环境变量文件中添加openssl的环境变量)source &#x2F;usr&#x2F;local&#x2F;.bash_profile                        （重新加载该路径下的用户环境变量文件）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注：在实际服务器上应用过程中发现，该环境变量只会当前shell脚本生效，如果下次重新进入shell脚本会失效，故如果嫌麻烦每次启动服务都要用的话，可直接设置到path环境变量中。（该步涉及到Centos系统使用习惯，一般程序环境变量设置入用户变量即可，path专门保存系统变量，但一般用户环境变量会失效，放入path会全局生效）。</p><p>（2）系统环境变量：</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">如果选择将其设置为全局的在path系统环境变量中设置命令如下：#在系统环境变量文件中添加openssl的环境变量echo &quot;export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;usr&#x2F;local&#x2F;openssl&#x2F;lib&quot; &gt;&gt;  &#x2F;etc&#x2F;profile    #重新加载该路径下的系统环境变量文件 source &#x2F;etc&#x2F;profile                              <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解压python3-10-1并安装，指定刚才安装的1-1-1版本的openssl！"><a href="#解压python3-10-1并安装，指定刚才安装的1-1-1版本的openssl！" class="headerlink" title="解压python3.10.1并安装，指定刚才安装的1.1.1版本的openssl！"></a>解压python3.10.1并安装，指定刚才安装的1.1.1版本的openssl！</h4><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">tar -zxvf Python-3.10.1.tgz                                                               .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;&#x2F;python3 --with-openssl&#x3D;&#x2F;usr&#x2F;local&#x2F;&#x2F;openssl       (配置安装目录，指定openssl环境的安装目录)make &amp;&amp; make install                                                               （编译、安装）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>检验ssl模块能否被导入<br>创建python软连接</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3  &#x2F;usr&#x2F;bin&#x2F;pip        #pip命令行调用指向pip3pip -Vln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3  &#x2F;usr&#x2F;bin&#x2F;python             #python命令行调用指向python3,如果同时安装有其他版本python可通过该命令指定用到的python版本ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3  &#x2F;usr&#x2F;bin&#x2F;python3        #python3命令行调用指向python3,由于某些程序执行时要求是python3命令调用，该步可根据需要进行设置python --version           #查看当前python安装版                                         导入ssl模块python3                      （进入python3命令行）import ssl                   （导入ssl模块）import _ssl                  （导入_ssl模块）exit()                       （退出python3命令行）查看python软连接指向whereis python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>以上Centos安装python3导入ssl时解决 ModuleNotFoundError: No module named &#39;_ssl&#39;问题的全部解决过程！</code></p><h3 id="执行python3命令的时候出现-can‘t-open-file-‘XXX‘-Errno-2-No-such-file-or-directory"><a href="#执行python3命令的时候出现-can‘t-open-file-‘XXX‘-Errno-2-No-such-file-or-directory" class="headerlink" title="执行python3命令的时候出现 can‘t open file ‘XXX‘: [Errno 2] No such file or directory"></a>执行python3命令的时候出现 can‘t open file ‘XXX‘: [Errno 2] No such file or directory</h3><p>检查一下命令是不是打错了</p><p><a href="%5B(72%E6%9D%A1%E6%B6%88%E6%81%AF">参考文章</a> 问题总结python: can‘t open file ‘XXX‘: <a href="https://blog.csdn.net/weixin_51736742/article/details/119863044">Errno 2] No such file or directory_++加油呀的博客-CSDN博客</a>)</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="ubuntu安装python是易出现的error"><a href="#ubuntu安装python是易出现的error" class="headerlink" title="ubuntu安装python是易出现的error"></a>ubuntu安装python是易出现的error</h2><p>待完成…</p><h3 id="error98-address-already-in-use"><a href="#error98-address-already-in-use" class="headerlink" title="[error98]address already in use"></a>[error98]address already in use</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">lsof -t -i tcp:8080 | xargs kill -9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="库相关error"><a href="#库相关error" class="headerlink" title="库相关error"></a>库相关error</h2><h3 id="Do-you-need-to-install-a-parser-library"><a href="#Do-you-need-to-install-a-parser-library" class="headerlink" title="Do you need to install a parser library"></a>Do you need to install a parser library</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">#方法一pip3 install lxml#方法二：换一种解析方式将soup &#x3D; BeautifulSoup(r.text, ‘lxml’)修改成如下形式即可：soup &#x3D; BeautifulSoup(r.text, ‘html.parser’)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(lxml是python的一个解析库，支持HTML和XML的解析，支持XPath解析方式，而且解析效率非常高。<br>XML 指可扩展标记语言（eXtensible Markup Language）。<br>XML 被设计用来传输和存储数据。)</p><h3 id="no-moudle-xxxx"><a href="#no-moudle-xxxx" class="headerlink" title="no moudle xxxx"></a>no moudle xxxx</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">#缺什么安装什么就行#PILpip install Pillow#常用库pip install requestspip install beautifulsoup4pip install openpyxl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="go-cqhttp提示风控后不重启服务器怎么处理"><a href="#go-cqhttp提示风控后不重启服务器怎么处理" class="headerlink" title="go-cqhttp提示风控后不重启服务器怎么处理"></a>go-cqhttp提示风控后不重启服务器怎么处理</h2><p>ctrl c以后再执行就提示打开数据库失败: open backend error: open level ldb error: resource temporarily unavailable</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">删除gocq的“session”文件ps -ef|grep mongod#查找进程，kill -9 2928#关闭进程重新打开gocq即可。 作者：四块sikuai https:&#x2F;&#x2F;www.bilibili.com&#x2F;read&#x2F;cv14682893&#x2F; 出处：bilibili<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装地三方库的时候出现下载慢-并且出现一大段红字报错"><a href="#安装地三方库的时候出现下载慢-并且出现一大段红字报错" class="headerlink" title="安装地三方库的时候出现下载慢,并且出现一大段红字报错"></a>安装地三方库的时候出现下载慢,并且出现一大段红字报错</h2><p>原因:error翻译过来是 hash值和包不匹配<br>大概是pip源地址是国外的，在国内下载速度特慢，网速问题导致的下载错误，从而导致对用的哈希值不匹配<br><img src="http://45.92.193.42:7788/i/2022/07/12/62cd3ba5d6910.jpg" alt="01.jpg"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install (要安装的库) -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple --trusted-host&#x3D;pypi.douban.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="pip‘s-dependency-resolver-does-not-currently-take-into-account-all-the-packages"><a href="#pip‘s-dependency-resolver-does-not-currently-take-into-account-all-the-packages" class="headerlink" title="pip‘s dependency resolver does not currently take into account all the packages"></a>pip‘s dependency resolver does not currently take into account all the packages</h2><p>pip 的依赖项解析器当前未考虑安装的所有包<br>根据错误提示，分别重新安装了报错要求的包</p><h2 id="TypeError-object-of-type-‘Response’-has-no-len"><a href="#TypeError-object-of-type-‘Response’-has-no-len" class="headerlink" title="TypeError: object of type ‘Response’ has no len()"></a>TypeError: object of type ‘Response’ has no len()</h2><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">#TypeError：“响应”类型的对象没有 len()soup&#x3D;BeautifulSoup(web,&#39;lxml&#39;)这个地方有错，web在这里是一个response对象，无法用BeautifulSoup解析，如果要解析，解析对象应该是web.content，所以正确的写法是soup&#x3D;BeautifulSoup(web.content,&#39;lxml&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TypeError-Value-must-be-a-list-tuple-range-or-generator"><a href="#TypeError-Value-must-be-a-list-tuple-range-or-generator" class="headerlink" title="TypeError: Value must be a list, tuple, range or generator,"></a>TypeError: Value must be a list, tuple, range or generator,</h2><p> or a dict. Supplied value is &lt;class ‘str’&gt;</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">#value 必须是列表、元组、范围或生成器，或 dict。 提供的值为 &lt;class &#39;str&#39;&gt;for data in article_data:   ws.append(data)解决方法：ws.append([data])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="python版本问题-要多看官方给的文档"><a href="#python版本问题-要多看官方给的文档" class="headerlink" title="python版本问题,要多看官方给的文档"></a>python版本问题,要多看官方给的文档</h2><p>…待完成</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_44985985/article/details/124241962">参考文章</a><br><a href="https://blog.csdn.net/csdn_avatar_2019/article/details/122303978">2.1参考文章</a><br><a href="https://blog.csdn.net/qq_39715000/article/details/125009276">2.2参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习python爬虫</title>
      <link href="/2022/06/01/15p-pythonspider/"/>
      <url>/2022/06/01/15p-pythonspider/</url>
      
        <content type="html"><![CDATA[<h2 id="关于爬虫"><a href="#关于爬虫" class="headerlink" title="关于爬虫"></a>关于爬虫</h2><ul><li>1.网络爬虫（又被称为网页蜘蛛，网络机器人）就是通过编写程序让其模拟浏览器向服务器发送网络请求，接收请求响应,是一种按照一定的规则,自动地抓取互联网信息的程序.</li><li>2.而浏览器作为客户端从服务器端获取信息，然后将信息解析，并展示给我们</li><li>3.模拟：浏览器是一个纯天然的爬虫工具<br>浏览器原理：在浏览器中输入一个网址，然后浏览器就会去这个网址所在的服务器要数据，这个过程也叫请求。</li><li>4.爬取：<ul><li>爬取一整张页面数据(通用爬虫)</li><li>爬取页面局部数据（聚焦爬虫）</li></ul></li><li>5.爬虫并不是Python独有的，可以做爬虫的语言有很多例如：PHP,JAVA,C#,C++,Python，选择Python做爬虫是因为Python相对来说比较简单，而且功能比较齐全。<br>原则上,只要是浏览器(客户端)能做的事情，爬虫都能够做。</li></ul><h2 id="爬虫的基础步骤"><a href="#爬虫的基础步骤" class="headerlink" title="爬虫的基础步骤"></a>爬虫的基础步骤</h2><h3 id="审查元素"><a href="#审查元素" class="headerlink" title="审查元素"></a>审查元素</h3><ul><li><p>在浏览器的地址栏输入URL地址(就是网址)，在网页处右键单击，找到检查，如下图所示：(不同浏览器的叫法不同，Chrome浏览器叫做检查，Firefox浏览器叫做查看元素，但是功能都是相同的)(<code>快捷键F12</code>)<br><img src="http://tu.uuudiy.com/i/2022/06/01/zg76zq.jpg" alt="01"><br><img src="http://tu.uuudiy.com/i/2022/06/01/zg8r7j.jpg" alt="02"></p></li><li><p>HTML 超文本标记语言  由一个个标签组成,我们想要的数据就在标签里</p></li><li><p>网页的html代码如图,点击箭头所指的图标,然后将鼠标移动到网页的任意一部分,右侧会出现与之对应的代码,将鼠标移动到代码上同理.<br><img src="http://tu.uuudiy.com/i/2022/06/01/zj6mgf.jpg" alt="03"></p></li></ul><p>箭头所指的就是标签,class是标签的属性用来区分标签的不同</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(soup.p.text)                    #打印网页中的p标签的内容,会打印出来第一个p标签的数据print(soup.find(&#39;p&#39;).text)            #和上一个一样获取第一个符合标签名的内容print(soup.find(&#39;div&#39;,class_&#x3D;&quot;content__list--item&quot;).text) #精确查找,class后面一定要有_,不能停和python的关键字重名,否则会被当做关键字,报错print(soup.find_all(&quot;div&quot;))#精确查找   #所有div标签print(soup.fin_all(&#39;dib&#39;,class_&#x3D;&quot;content__list--item&quot;)[1].text)   #findall也可以精确查找,符合条件的第一条数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="写代码前需要掌握的内容"><a href="#写代码前需要掌握的内容" class="headerlink" title="写代码前需要掌握的内容"></a>写代码前需要掌握的内容</h2><p>urllib库是python内置的，无需我们额外安装，只要安装了Python就可以使用这个库。<br>requests库是第三方库，需要我们自己安装。<br>安装命令,在cmd中输入</p><blockquote><p>pip install requests<br>pip install beautifulsoup4</p></blockquote><p>如果运行时有报错No module named ‘openpyxl’则说明该模块没有安装,安装一下就可以了<br>如果安装出现error,最底下出现黄色warning说你的pip版本是多少,然而现在的版本是多少,更新一下pip就可以了</p><blockquote><p>pip install openpyxl<br>python -m pip install -U pip       #更新pip命令<br>(安装失败也可以尝试管理员运行)</p></blockquote><h3 id="代码步骤"><a href="#代码步骤" class="headerlink" title="代码步骤"></a>代码步骤</h3><ul><li>导入模块</li><li>指定网址</li><li>发起请求    <ul><li>requests模块</li></ul></li><li>获取响应数据<ul><li>requests.get(url)</li></ul></li></ul><h3 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h3><ul><li>就是获取页面局部数据的过程</li><li>网页中显示的数据在哪？在网页标签中（包裹在里面）</li><li>解析原理：<ul><li>定位标签</li><li>提取数据</li></ul></li><li>用python如何实现？<ul><li>bs4模块</li></ul></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requests          #导入requests模块(请求)#url &#x3D; &#39;&#39;                #网址#res&#x3D;requests.get(url)   #请求#print(res)              #打印结果为200#print(res.text)         #查看数据 .text#HTML 超文本标记语言  由一个个标签组成import bs4               #导入bs4模块(解析)#soup&#x3D;bs4.BeautifulSoup(res.text,&#39;html.parser&#39;)  #加工成可以标签定位的数据import openpyxl          #导入写入excel的模块wb &#x3D; openpyxl.Workbook() #创建工作薄ws &#x3D; wb.active           #创建工作表ws.append([&quot;详细信息&quot;,&quot;优势&quot;,&quot;价格&quot;])    #写入表头 for i in range(1,6): #生成一个1-5的序列  [1,2,3,4,5]    url &#x3D; &quot;https:&#x2F;&#x2F;bj.lianjia.com&#x2F;zufang&#x2F;pg&#123;&#125;&#x2F;#contentList&quot;.format(i)  #在扩号里放入i的值,通过观察发现1-5页的网址的规律    res&#x3D; requests.get(url)    soup &#x3D; bs4.BeautifulSoup(res.text)    for i in soup.find_all(&quot;div&quot;,class_&#x3D;&quot;content__list--item&quot;):        lst &#x3D;[]        lst.append(i.find(&quot;p&quot;,class_&#x3D;&quot;content__list--item--des&quot;).text)        lst.append(i.find(&quot;p&quot;,class_&#x3D;&quot;content__list--item--bottom oneline&quot;).text)        lst.append(i.find(&quot;span&quot;,class_&#x3D;&quot;content__list--item-price&quot;).text)        ws.append(lst)wb.save(&quot;链家租房信息.xlsx&quot;)                                            #保存为excel文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux搭建基于nonebot2和go-cqhttp的qq机器人</title>
      <link href="/2022/05/28/14l-nonebot2-qqbot/"/>
      <url>/2022/05/28/14l-nonebot2-qqbot/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>1.一台linux系统服务器(或者虚拟机)<br>1.python 3.7.3以上<br>2.Python能力<br>3.读文档能力<br>4.Linux能力（部署于linux）</p><h3 id="关于nb和go-cqhttp"><a href="#关于nb和go-cqhttp" class="headerlink" title="关于nb和go-cqhttp"></a>关于nb和go-cqhttp</h3><p><a href="https://v2.nonebot.dev/">nb官方文档</a><br><a href="https://docs.go-cqhttp.org/">gocq官方文档</a><br>你需要记住他们，因为你需要随时查阅文档</p><p>简单来说，gocq就是一个QQ，即你需要用它来登录，接收消息，发送消息；而nb则用来实现机器人的各种功能</p><blockquote><p>创作本文时，nb最新版本为Release v2.0.0-beta.3，gocq最新版本为&#96;v1.0.0-rc1 ，请注意内容时效！</p></blockquote><h2 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">#获取安装包wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.10.1&#x2F;Python-3.10.1.tgz#下载完成之后，将安装包解压到当前目录：tar xvf Python-3.10.1.tgz#安装需要的依赖apt -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel#先进入Python3目录下的Python-3.9.13目录：cd Python-3.10.1#指定python3安装路径：.&#x2F;configure prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3.10.1若出现以下报错&#96;&#96;&#96;linuxchecking build system type... x86_64-pc-linux-gnuchecking host system type... x86_64-pc-linux-gnuchecking for python3.8... nochecking for python3... nochecking for python... pythonchecking for --enable-universalsdk... nochecking for --with-universal-archs... nochecking MACHDEP... &quot;linux&quot;checking for gcc... nochecking for cc... nochecking for cl.exe... noconfigure: error: no acceptable C compiler found in $PATH执行yum -y groupinstall &quot;Development Tools&quot;重新执行.&#x2F;configure prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3.10.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#编译+安装</p><blockquote><p>make &amp;&amp; make install</p></blockquote><p>此处容易出现报错:make命令报错：gcc：命令未找到&#x2F;bin&#x2F;sh: cc: 未找到命令</p><p>系统中缺少gcc</p><blockquote><p>yum -y install gcc automake autoconf libtool make</p><p><a href="%5B(72%E6%9D%A1%E6%B6%88%E6%81%AF">参考文章</a> 执行make命令报错：gcc：命令未找到&#x2F;bin&#x2F;sh: cc: 未找到命令_超级码里喵的博客-CSDN博客_&#x2F;bin&#x2F;sh: cc: 未找到命令](<a href="https://blog.csdn.net/qq_30999361/article/details/124447365">https://blog.csdn.net/qq_30999361/article/details/124447365</a>))</p></blockquote><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">#添加python3软链接：ln -s &#x2F;usr&#x2F;local&#x2F;python3.10.1&#x2F;bin&#x2F;python3.10.1 &#x2F;usr&#x2F;bin&#x2F;python3#添加pip3软链接：ln -s &#x2F;usr&#x2F;local&#x2F;python3.10.1&#x2F;bin&#x2F;pip3.10.1 &#x2F;usr&#x2F;bin&#x2F;pip3#删除软连接的方法(&#96;慎用,不然会连着文件一起删除&#96;)unlink &#x2F;usr&#x2F;local&#x2F;python3.10.1&#x2F;bin&#x2F;python3.10.1&#x2F;usr&#x2F;bin&#x2F;python3rm -rf &#x2F;usr&#x2F;local&#x2F;python3.10.1&#x2F;bin&#x2F;python3.10.1&#x2F;usr&#x2F;bin&#x2F;python3    #末尾有&#96;&#x2F;&#96;的是连文件一起删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#配置python环境变量<br>配置环境变量主要是能快速使用pip3安装命令。</p><p>vi ~&#x2F;.bash_profile添加如下配置</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">export PYTHON_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;python3.10.1export PATH&#x3D;$PYTHON_HOME&#x2F;bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>#使配置生效</p><blockquote><p>source ~&#x2F;.bash_profile</p></blockquote><p>#检查版本<br>python3 –version<br>python3<br>pip3 -V    #查看已安装的库</p><pre class="line-numbers language-none"><code class="language-none">## 安装nb安装脚手架通过脚手架安装(官方推荐)：&gt;pip install nb-cli安装脚手架时会自动安装nb安装时可能会出现的报错：1.很长一段结尾出现 read time outpip3 install nb-cli -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple 2.ModuleNotFoundError: No module named ‘_ctypes‘解决方法原因:Python3中有个内置模块叫ctypes，它是Python3的外部函数库模块，它提供兼容C语言的数据类型，并通过它调用Linux系统下的共享库(Shared library)，此模块需要使用CentOS7系统中外部函数库(Foreign function library)的开发链接库(头文件和链接库)。由于在CentOS7系统中没有安装外部函数库(libffi)的开发链接库软件包，所以在安装pip的时候就报了&quot;ModuleNotFoundError: No module named &#39;_ctypes&#39;&quot;的错误。安装一下外部函数库(libffi)就可以了yum install libffi-devel -y安装完成后,源码安装的python3 重新编译安装， 如果通过yum安装的 那么直接执行命令 yum install python         .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3make &amp;&amp; make install3.WARNING: Additional context:user &#x3D; Falsehome &#x3D; Noneroot &#x3D; Noneprefix &#x3D; None使用下面的命令升级pip即可python3 -m -pip3 install -upgrade p其他国内镜像：阿里云 http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;中国科技大学 https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;豆瓣(douban) http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;清华大学 https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;中国科学技术大学 http:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/u011817217/article/details/102662307">参考报错1</a></p><p><a href="%5B(72%E6%9D%A1%E6%B6%88%E6%81%AF">参考报错2</a> ModuleNotFoundError: No module named ‘_ctypes‘解决方法_wuyepiaoxue789的博客-CSDN博客](<a href="https://blog.csdn.net/wuyepiaoxue789/article/details/117958240?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-117958240-blog-118799671.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-117958240-blog-118799671.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=2">https://blog.csdn.net/wuyepiaoxue789/article/details/117958240?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-117958240-blog-118799671.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-117958240-blog-118799671.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=2</a>))</p><p>[参考报错3](<a href="https://stackoverflow.com/questions/67244301/warning-value-for-scheme-data-does-not-match-when-i-try-to-update-pip-or-inst">python - “警告：scheme.data 的值不匹配”，当我尝试更新 pip 或安装软件包时 - 堆栈溢出 (stackoverflow.com)</a>)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">安装适配器(使用脚手架安装时已经安装,可以省略)&gt;pip install nonebot-adapter-onebot## go-cqhttp的安装与配置### 下载前往[release](https:&#x2F;&#x2F;github.com&#x2F;Mrs4s&#x2F;go-cqhttp&#x2F;releases)下载安装包,新建文件夹qqbot,在qqbot下新建cq文件夹,安装包上传到这里&#96;&#96;&#96;ccd qqbot&#x2F;cq            #切换到cq文件夹chmod 777 go-cqhttp    #赋予权限.&#x2F;go-cqhttp 运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>选择<code>反向WebSocket</code>回车<br>此时目录下会生成配置文件<code>config.yml</code><br>对其进行配置修改：</p><ul><li><p>QQ号及密码  (行4、5)</p></li><li><p>反向ws地址  (行96)</p><blockquote><p>universal: ws:&#x2F;&#x2F;your_websocket_universal.server<br>修改为<br>universal: ws:&#x2F;&#x2F;127.0.0.1:8080&#x2F;onebot&#x2F;v11&#x2F;ws</p></blockquote></li></ul><p>8080是端口号，(可以自行更改对应的nonebot2的端口号也要跟着更改)，再次执行.&#x2F;go-cqhttp，即可登录成功</p><h3 id="登录时的小问题"><a href="#登录时的小问题" class="headerlink" title="登录时的小问题"></a>登录时的小问题</h3><p>直接密码登录会说什么要拖动验证码,然后让你扫码登录,扫码然后说什么什么有风险,连接到同一网络下再重新扫码</p><p>出现这个有两个问题</p><blockquote><ul><li>首先注意设备是否连接同一个wifi,未连接同一个wifi可能导致无法登陆</li><li>,如果wifi已连接,依然无法登陆,去<a href="https://github.com/Mrs4s/go-cqhttp/releases">release</a>下载windows的安装包安装到自己电脑上,运行,将运行后产生的device和tocken传上服务器(或者除了.go-cqhttp.exe整个挪过来也行),重新运行go-cqhttp,就可以解决了</li></ul></blockquote><p>登陆成功后会有黄色字的warning,暂时不用管,报错的原因是还未启动nb2</p><h2 id="创建nb项目"><a href="#创建nb项目" class="headerlink" title="创建nb项目"></a>创建nb项目</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">nb create<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按照如下步骤创建项目</p><blockquote><p>输入项目名称 我这里输入了robot<br>使用 ↓ 选择src文件夹<br>选择一款预置插件，我按下<code>空格</code>选择echo，回车<br>按下<code>空格</code>键选择noebot v11回车<br>(注意空格或者鼠标点击也可以,选项为绿色选中状态即可)</p></blockquote><h3 id="配置-env文件"><a href="#配置-env文件" class="headerlink" title="配置.env文件"></a>配置.env文件</h3><p>打开<code>.env.</code>并做出修改</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"># .envENVIRONMENT&#x3D;devCUSTOM_CONFIG&#x3D;common config  # 这个配置项在任何环境中都会被加载<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="配置-env-dev文件"><a href="#配置-env-dev文件" class="headerlink" title="配置.env.dev文件"></a>配置.env.dev文件</h3><p>打开<code>env.dev</code>并做出修改</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">HOST&#x3D;127.0.0.1PORT&#x3D;8080DEBUG&#x3D;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>官方示例<code>.env.dev</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">HOST&#x3D;0.0.0.0  # 配置 NoneBot2 监听的 IP&#x2F;主机名PORT&#x3D;8080  # 配置 NoneBot2 监听的端口SUPERUSERS&#x3D;[&quot;123456789&quot;, &quot;987654321&quot;]  # 配置 NoneBot 超级用户NICKNAME&#x3D;[&quot;awesome&quot;, &quot;bot&quot;]  # 配置机器人的昵称COMMAND_START&#x3D;[&quot;&#x2F;&quot;, &quot;&quot;]  # 配置命令起始字符COMMAND_SEP&#x3D;[&quot;.&quot;]  # 配置命令分割字符# Custom ConfigsCUSTOM_CONFIG1&#x3D;&quot;config in env file&quot;CUSTOM_CONFIG2&#x3D;  # 留空则从系统环境变量读取，如不存在则为空字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加守护进程"><a href="#添加守护进程" class="headerlink" title="添加守护进程"></a>添加守护进程</h2><p>避免服务器断开连接时,进程关闭<br>我用的是<code>screen</code>,也可以使用其他的进程守护</p><h3 id="安装screen"><a href="#安装screen" class="headerlink" title="安装screen"></a>安装screen</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;yum install -y screen#(1)创建进程名称&gt;screen -S xxx   #(2)查看创建的进程&gt;screen -ls#(3)常用命令&gt;screen -S session_name   # 新建进程名&gt;screen -ls（或者screen-list）      # 列出所有session&gt;screen-r session_name              # 回到session_name这个session&gt;screen -d session_name             # 远程detach某个session&gt;screen -d -r session_name          # 结束当前session并回到session_name这个session&gt;screen -XS session_name  quit     #杀死名为seesion_name的screen在 screen 中，如果想翻看之前的屏幕输出，使用向上键和pageUp 都是不行的，这时候使用&gt;ctrl + a + [&#123; &gt;从后台进程里出来，按键：ctrl+A+D，回到主终端。&gt;但如果在主进程里ctrl+A+D，就会断开ssh连接结束当前screen窗口&gt;exit 或者 ctrl+d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;screen -S go-cqhttp.&#x2F;go-cqhttp(在go-cq所在的文件夹下)&gt;screen -S  botnb run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h3><p>然后就大功告成,可以给机器人发送消息测试了</p><blockquote><p>&#x2F;echo 你好<br>这个echo是内置插件,其他的功能插件商店可以下载,还可以自行编写</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> QQbot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nonebot2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AD一些基础的使用方法</title>
      <link href="/2022/05/25/13h-ad-mesures/"/>
      <url>/2022/05/25/13h-ad-mesures/</url>
      
        <content type="html"><![CDATA[<p>我使用的是AD 20</p><h2 id="个人遇到的一些小问题"><a href="#个人遇到的一些小问题" class="headerlink" title="个人遇到的一些小问题"></a>个人遇到的一些小问题</h2><blockquote><p>1.丝印翻转,虽然鼠标拖住按x可以x轴翻转,y可以y轴翻转,但还是有一部分在底层丝印<code>未解决</code></p></blockquote><blockquote><p>2.刚导入PCB拖进黑框里的元器件全部报绿<br>解决:右键&gt;冲突&gt;我直接把冲突的那条规则删了(因为我这里是放上去就报错,所以很可能是规则的问题,其他不一样的规则问题,修改就可以了,不一定非要删掉)</p></blockquote><blockquote><p>3.红,蓝是顶层和底层铺铜布线的<br>紫是切割板子,确定形状的<br>黄色是丝印层<br>鼠标拖着按L可以改变元器件层数</p></blockquote><blockquote><p>3.按q可以切换ad的单位</p></blockquote><h2 id="画板大概步骤"><a href="#画板大概步骤" class="headerlink" title="画板大概步骤"></a>画板大概步骤</h2><blockquote><p>元器件的放置、网络编号、封装添加(封装管理器)、编译、导入到PCB<br>注:新建的PCB需要保存才可以导入</p></blockquote><h3 id="PCB绘制"><a href="#PCB绘制" class="headerlink" title="PCB绘制"></a>PCB绘制</h3><blockquote><p>布局、布线、铺铜、电气规则检查(规则设置)</p></blockquote><h3 id="PCB布局"><a href="#PCB布局" class="headerlink" title="PCB布局"></a>PCB布局</h3><blockquote><p>编辑&gt;设置原点&gt;画线设置长度(在机械层)把引脚拖过去完善边框(选中框框&gt;设计&gt;板子形状&gt;按照选择对象定义)就可以得到板子的形状了</p></blockquote><blockquote><p>window&gt;平铺(可以使窗口并排)</p></blockquote><blockquote><p>工具&gt;交叉选择模式(ctrl+shift+x)可以使在原理图选中的可以再PCB中凸显出来</p></blockquote><blockquote><p>工具&gt;器件摆放可以将选中的元器件排列在自己选中的区域</p></blockquote><blockquote><p>布局要考虑到布线问题</p></blockquote><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ul><li><h3 id="原理图绘制"><a href="#原理图绘制" class="headerlink" title="原理图绘制"></a>原理图绘制</h3></li></ul><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">连线  快捷键线 CTRL+W,空格把线变直  Place→Deirectives→给引脚打上红叉  不进行DRC检查元器件编号  Tools→Annotation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="封装添加-编译-交互"><a href="#封装添加-编译-交互" class="headerlink" title="封装添加 编译 交互"></a>封装添加 编译 交互</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">封装添加  可以借助&quot;Find Similar Objects...&quot;批量添加封装  取消阴影 shift+C  右键元器件&quot;Find Similar Objects...&quot;,可以查找同类型元器件,会出现阴影.  封装管理器 T+G,用于检查封装的问题编译  右键Project编译，检查error  导入到PCB交互 | 原理图与PCB之间  原理图中选中模块，按shift+ctrl+x，PCB中才能选中我们需要的模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="PCB绘制-布线-自动布线"><a href="#PCB绘制-布线-自动布线" class="headerlink" title="PCB绘制 布线 自动布线"></a>PCB绘制 布线 自动布线</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">PCB绘制shift+s单独查看每层  布局    隐藏飞线 N    布线时再用    逐个模块布局    用Tools→Component Placement把元器件选出来    元器件放底层:要在移动中按L，按空格旋转  布线    手动布线    隐藏Top&#x2F;Bottom Overlay    可视性管理面板快捷键L进行恢复          快捷键N,调出飞线，并隐藏GND飞线    普通布线10mil，电源线15mil    打开可见性管理面板ctrl+D      如隐藏文字，方便布线;还可调节布线时的亮度 Dimmed objects        Design→Rules...改为6mil        →Electrical 电气属性        →Manufacturing    ctrl+W调出布线(十字架)    布线不能有锐角&#x2F;直角    *键调出过孔，连接顶层和底层    过孔一般12mil&#x2F;24mil     自动布线    先去设置规则Design→Rules...      Electrical 电气属性      Clearance 间距      改6mil      Routing 布线      Widrh 线宽      Design→Rule Wizard      添加电源线改线宽15mil            Routing Via Style 过孔      12mil&#x2F;24mil            快捷键TE， 画泪滴      Tools→Teardrops...    Route→Auto Route→All...    过孔Tab→Find Similiar Objects→去掉阻焊层 Solder Mask  Expansion 改0mil    按g改网格单位    短路:打过孔Tab→自动移除回路Automatically Remove Loops<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="铺铜-丝印-电气规则"><a href="#铺铜-丝印-电气规则" class="headerlink" title="铺铜 丝印 电气规则"></a>铺铜 丝印 电气规则</h3><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">覆铜  快捷键 F3  Tab    Net选GND    勾选 Remove Dead Copper  移除死铜(会全部报错)    Tools→ Polygon Pours→ Repout All 全部重覆    顶层&#x2F;底层都要覆铜    *键切换底层查看    Design→ Rules...→ Electrical 电气属性→Clearance间距→Advanced → Poly 那一行改10mil    报错重覆 →0Repout All          放置小过孔:连接两层覆铜;加固    Design→ Rules...→Plane→Polygon Connect Style→最右Via Connection    改成直连，就不是十字架形了     丝印层    重新调出丝印    调出Tab    改文字高度，字体   三维模式下，直接拖文字改位置电气规则检查(规则设置)  可以与覆铜转换顺序    Tools→ Design RuleCheck...→ Run    调出Messages→双击可以定位    一定要重新覆铜     再更新错误，改错...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原理图库-封装库"><a href="#原理图库-封装库" class="headerlink" title="原理图库 封装库"></a>原理图库 封装库</h3><p>原理图库绘制</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">&gt;注意引脚的小白点(指焊点)向外  利用向导 Tools→ Symbal Wizard...注意改引脚属性→Passive  自己找资源:立创EDADesign→ Make Schematic&#x2F;PCB Library<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PCB封装库绘制</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">&gt;最关键:焊盘的大小和距离    孔径比插针大0.1-0.2mm    焊盘比孔径大0.45-0.5mm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看芯片手册</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">&gt;快捷键G&#x2F;ctrl+shift+G 改变焊盘距离灰色覆铜，紫色阻焊层改变原点在中心或一脚 Edit→ Set Refeience更改元器件名称原理图元件库文件 + PCB元件库文件添加到*.Libpkg，编译后就会出现*.IntLib 元件集成库文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><p>默认位置 System-default locations</p><p>安装库Data management-&gt;File-based libraries</p><p>AD自带常用库，也可去官方下载</p><img src="/2022/05/25/13h-ad-mesures/image-20250119113207520.png" class="" title="image-20250119113207520"><p>立创导入库，生成库，然后保存改名</p><h3 id="关联原理图和封装"><a href="#关联原理图和封装" class="headerlink" title="关联原理图和封装"></a>关联原理图和封装</h3><p>add footprint</p><p><a href="https://blog.csdn.net/qq_41671937/article/details/116902775">Altium Designer库文件格式详解及关联-CSDN博客</a></p><p>###集成库</p>]]></content>
      
      
      <categories>
          
          <category> Altium Designer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索者综合测试实验报错</title>
      <link href="/2022/05/23/12h-f407-tan-suo-zhe-yu-dao-de-wen-ti/"/>
      <url>/2022/05/23/12h-f407-tan-suo-zhe-yu-dao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="综合测试实验报错Ex-Flash-Error"><a href="#综合测试实验报错Ex-Flash-Error" class="headerlink" title="综合测试实验报错Ex Flash Error!"></a>综合测试实验报错Ex Flash Error!</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><blockquote><p>如下图所示，为了充分的运用STM32F407的IO资源，原理图设计的时候，<code>JTAG</code>接口的<code>JTRST</code>和<code>JTDO</code>，分别与<code>SPI FLASH</code>的<code>SPI1_MISO</code>和<code>SPI1_SCK</code>共用了PB4和PB3。这样在拿到开发板接上J_LINK测试，综合实验检测SPI FLASH的时候J_LINK比较容易干扰SPI1_MISO和SPI1_SCK，从而造成检测出错（Ex Flash Error！！）。</p></blockquote><blockquote><p>个人理解是端口占用<br><img src="http://tu.uuudiy.com/i/2022/05/27/y1zvem.jpg" alt="01"></p></blockquote><p><img src="http://tu.uuudiy.com/i/2022/05/27/y1ztu1.jpg" alt="02"></p><p><img src="http://tu.uuudiy.com/i/2022/05/27/y1zzjo.jpg" alt="03"></p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h3><blockquote><p>光盘里的文件比较老了,下载最新的正点原子探索者资料盘,重新烧录综合测试实验,烧录时不要打开开发板的开关,<code>烧录后拔掉jlink</code>,打开开关即可</p></blockquote><h2 id="综合实验报错SYSTEM-FILE-LOST"><a href="#综合实验报错SYSTEM-FILE-LOST" class="headerlink" title="综合实验报错SYSTEM FILE LOST!"></a>综合实验报错SYSTEM FILE LOST!</h2><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><blockquote><p>原因:系统文件缺失,需要更新一下系统文件</p></blockquote><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><blockquote><p>1.将光盘根目录SD卡根目录文件中的SYSTEM 文件夹拷贝到SD卡&#x2F;U盘，然后将SD卡&#x2F;U 盘插入开发板的对应接口。</p></blockquote><blockquote><p>2.按着 KEY2 不放，然后按复位，松开复位（KEY2一直按着）， 加载到FLASH容量时,屏幕提示是否擦除所有文件(Erase all system files?),松开 KEY2，然后再按 KEY2选择擦除所有系统文件， 将整个 SPI FLASH 擦除。</p></blockquote><blockquote><p>3.等待系统自动更新完成。在第 2 步执行完以后（ 需要约 3 分钟时间），系统会自动更新字库、系统文件，然后进入主界面。</p></blockquote><blockquote><p>注意:需要sd卡&#x2F;u盘,否则会出现<code>font error</code>的错误</p></blockquote><h2 id="综合实验报错font-error"><a href="#综合实验报错font-error" class="headerlink" title="综合实验报错font error!"></a>综合实验报错font error!</h2><h3 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h3><blockquote><p>字库缺失</p></blockquote><h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><blockquote><p>将光盘目录下SD卡根目录中的SYSTEM文件夹拷贝到SD卡,插入开发板</p></blockquote><blockquote><p>按住<code>KEY1不放</code>按一下复位,直到出现Update font!!,等待一会,即可进入系统</p></blockquote><blockquote><p>第二种方法是将system拖入U盘插入开发板,操作同上,我自己试没有成功,不知道是不是u盘的问题,不显示update font!</p></blockquote><p><a href="http://www.openedv.com/forum.php?mod=viewthread&tid=83751&highlight=system+file+lost">参考文章1</a><br><a href="http://www.openedv.com/posts/list/54412.htm">参考文章2</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32f407 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32f407串口打印编码器测速</title>
      <link href="/2022/05/17/11h-f407-encoder/"/>
      <url>/2022/05/17/11h-f407-encoder/</url>
      
        <content type="html"><![CDATA[<p>对于电机测速用到的正交编码器，测速时需要捕获2路脉冲，输入捕获，编程较为复杂。单片机的通用定时器具有专门的正交编码器接口，只需配置相应的寄存器，就可实现编码器输入的上下沿自动捕获与计数，便于编码器的测速。</p><p>编码器模式,原理相当于输入捕获,为什么叫正交编码,因为编码器的A相和B相相差90度(如果两个信号相位相差90度，则这两个信号称为正交)因此可以根据两个信号哪个先哪个后来判断方向、根据每个信号脉冲数量的多少及整个编码轮的周长就可以算出当前行走的距离、如果再加上定时器的话还可以计算出速度。</p><p>要明白的一点就是为什么要用编码器模式，而不是直接用输入捕获。<br>最主要的原因就是编码器采集的是两个信号，根据两个信号的高低电平来判断是正转还是反转，比输入捕获用一个信号的抗干扰能力强。如果一个信号有干扰，而另一个信号没有干扰，则计数器不会计数，</p><h2 id="编码器分类："><a href="#编码器分类：" class="headerlink" title="编码器分类："></a>编码器分类：</h2><h3 id="增量式编码器"><a href="#增量式编码器" class="headerlink" title="增量式编码器"></a>增量式编码器</h3><blockquote><p>只有当设备运动时才会输出信号。</p></blockquote><blockquote><p>一般会输出通道A和通道B 两组信号，并且有90° 的相位差（1&#x2F;4个周期），同时采集这两组信号就可以计算设备的运动速度和方向。</p></blockquote><blockquote><p>正转的时候信号线A先输出信号,信号线B后输出  A相超前B相90度  证明是正转,反转则相反</p></blockquote><blockquote><p>除通道A、通道B 以外，还会设置一个额外的通道Z 信号，表示编码器特定的参考位置</p></blockquote><blockquote><p>如下图，传感器转一圈后Z 轴信号才会输出一个脉冲，在Z轴输出时，可以通过将AB通道的计数清零，实现对码盘绝对位置的计算。</p></blockquote><blockquote><p>增量式编码器只输出设备的位置变化和运动方向，不会输出设备的绝对位置。<br><img src="http://45.92.193.42:7788/i/2022/07/12/62cd39fc95ea0.jpg" alt="04.jpg"></p></blockquote><h3 id="绝对值型："><a href="#绝对值型：" class="headerlink" title="绝对值型："></a>绝对值型：</h3><blockquote><p>对应一圈，每个基准的角度发出一个唯一与该角度对应二进制的数值，通过外部记圈器件可以进行多个位置的记录和测量。<br><img src="http://45.92.193.42:7788/i/2022/07/12/62cd39fd98477.jpg" alt="06.jpg"></p></blockquote><h2 id="编码器采集原理"><a href="#编码器采集原理" class="headerlink" title="编码器采集原理"></a>编码器采集原理</h2><p><img src="http://45.92.193.42:7788/i/2022/07/12/62cd39fa4d7f4.jpg" alt="01.jpg"></p><p>上图是定时器的框图，首先我们会从电机屁股后面的编码器引出两根信号线<code>就是编码器的AB相</code>接到单片机的编码器引脚，如上图第一个框内，接到某定时器的TIMx_CH1和TIMx_CH2两个通道的引脚上。进来之后进行滤波和边沿检测之后输出TI1FP1和TI1FP2，之后就直接到2号框了。2号框是将TI1FP1和TI1FP2接入编码器接口，在这里判断是该向上还是向下计数，之后来到3号框，进行分频，最后来到CNT计数器进行计数。我们可以定时采集CNT里面的值，这样就能算出电机的转速和其他一些参数了。</p><h2 id="计数原理及计数方式"><a href="#计数原理及计数方式" class="headerlink" title="计数原理及计数方式"></a>计数原理及计数方式</h2><h3 id="正反转计数原理"><a href="#正反转计数原理" class="headerlink" title="正反转计数原理"></a>正反转计数原理</h3><p>编码器模式下，计数器的计数方向代表的电机的正转与反转，计数的大小代表了转速的大小。<br>如下图，电机正转时，编码器的通道A（TI1）的信号超前通道B，计数器向上计数，反转时，通道A的信号滞后，向下计数。<br><img src="http://45.92.193.42:7788/i/2022/07/12/62cd39ff5375b.jpg" alt="09.jpg"></p><p>设置信号的极性反相，可以使向下计数代表电机正转。<br><img src="http://45.92.193.42:7788/i/2022/07/12/62cd3a0005b63.jpg" alt="10.jpg"><br>以STM32 芯片为例，其内部有专门用来采集增量式编码器方波信号的接口，这些接口实际上是STM32 定时器的其中一种功能。不过编码器接口功能只有高级定时器TIM1、TIM8 和通用定时器的TIM2~TIM5 才有。<br><img src="http://45.92.193.42:7788/i/2022/07/12/62cd3a0081cc6.jpg" alt="11.jpg"></p><h3 id="计数方式"><a href="#计数方式" class="headerlink" title="计数方式"></a>计数方式</h3><p><img src="http://45.92.193.42:7788/i/2022/07/12/62cd39fa87c2c.jpg" alt="02.jpg"><br><img src="http://45.92.193.42:7788/i/2022/07/12/62cd39facf3b3.jpg" alt="03.jpg"></p><p>首先假定此时是电机正转，还有一点要知道，编码器两个信号相差90°的相位角。一个周期的信号可以分为0 π&#x2F;2 π 3&#x2F;2*π 2π，如上图，刚好差了π&#x2F;2。上图是两个通道上下边沿都检测（SMS&#x3D;’011’） 。<br>当TI1为上升沿时时，此时TI2为低电平，对应下面的图，先看<code>有效边沿</code>，因为是看的TI1上升沿，所以第一项选择<code>仅在TI1计数</code>，之后找对应的<code>TI1FP1 信号项</code>，选择上升。因为图中TI1是上升沿，对应TI2是低电平，因此在<code>相对信号的电平</code>那一项应该选择低，对应起来就是向上计数。<br>理解了TI1上升沿计数之后，其他的都一样了。</p><h2 id="编码器倍频的原理"><a href="#编码器倍频的原理" class="headerlink" title="编码器倍频的原理"></a>编码器倍频的原理</h2><blockquote><p>编码器倍频是什么意思，比如某光栅编码器一圈有N个栅格，理论上电机带动编码器转一圈，只能输出N个信号，通过倍频技术，可以实现转一圈，却能输出N*n个信号，这里的n为倍频数。</p></blockquote><p><img src="http://45.92.193.42:7788/i/2022/07/12/62cd39fd0d2af.jpg" alt="05.jpg">增量式编码器输出的脉冲波形一般为占空比50% 的方波，通道A 和B 相位差为90°。</p><blockquote><p>如果只使用通道A计数，并且只捕获通道A的上升沿，则一圈的计数值&#x3D;码盘的栅格数，即为1倍频（没有倍频）<br>如果只使用通道A计数，并且捕获了通道A的上升沿和下降沿，则编码器转一圈的计数值翻倍，实现2倍频<br>如果既使用通道A计数，又使用通道B计数，且都捕获了上升沿和下降沿，则实现了4倍频</p></blockquote><p><img src="http://45.92.193.42:7788/i/2022/07/12/62cd39fe7aad2.jpg" alt="07.jpg"></p><p>假设某个增量式编码器它的分辨率是600PPR，能分辨的最小角度是0.6°，对它进行4 倍频之后就相当于把分辨率提高到了600*4&#x3D;2400PPR，此时编码器能够分辨的最小角度为0.15°。</p><blockquote><p><code>个人理解</code>:在A先达到上升沿,B处于低电平时,则向上计数,电机正转,一个周期只有一个上升沿,每个周期计数一次,AB通道相差四分之一个周期,四倍频相当于在这一个向上计数的周期里捕获了四次,A上升A下降B上升B下降达到四倍频效果</p></blockquote><h2 id="编码器测速原理及测速方法"><a href="#编码器测速原理及测速方法" class="headerlink" title="编码器测速原理及测速方法"></a>编码器测速原理及测速方法</h2><h3 id="测速原理"><a href="#测速原理" class="headerlink" title="测速原理"></a>测速原理</h3><blockquote><p>STM32的编码器模式共有三种</p></blockquote><blockquote><p>仅在TL1计数(A相)</p></blockquote><blockquote><p>仅在TL2计数(B相)</p></blockquote><blockquote><p>在TL1和TL2都计数(A相和B相都计数)</p></blockquote><blockquote><p>编码器相当于内外两个环,一个A一个B,相位差为90度<br>A上升沿,B处于低电平,则为正转<br>A下降沿,B处于高电平,则为反转<br>定时器在编码器模式下记得数则为总的脉冲数,由于是TL12模式,四倍频,所以总的脉冲数&#x3D;线数<em>减速比</em>4</p></blockquote><blockquote><p>把TIM3理解为一个计数器而不是一个定时器，则没有了时序信号。<br>这里TIM3的时钟信号（或者说是计数信号）将由电机编码器输出的脉冲代替，也就是说电机脉冲信号成为TIM3的信号，电机每产生一个脉冲被TIM3检测到，则计数器CNT加一（类比于时序信号时每隔一个时间段计数值加一）</p></blockquote><blockquote><p>这样的话，输入捕获的自动重装载值period则影响着脉冲值计数到多少之后就溢出，比如65535的话，则接收到65535个脉冲信号之后计数值置零溢出</p></blockquote><blockquote><p>这样的话，输入捕获的预分频系数prescaler的作用是，当我不分频时，来一个电机脉冲信号我计数值就加一，当我二分频时，只有接收到两个脉冲信号我才认为是一个有效脉冲，计数值才加一，简单来说就是计数值总体除以二了</p></blockquote><blockquote><p>这样我们就把输入捕获初始化完成了，接下来是编码器模式的初始化<br>设为<code>TIM_EncoderMode_TI12</code>模式，即计数器在TI1和TI2上升沿处均计数，再根据设置的极性是<code>TIM_ICPolarity_Rising</code>，也就是在TI1和TI2的上升沿计数器累加（或累减）–&gt;那么到时候要除以二<br>这样，编码器的初始化就完成了，接下来我们只要通过函数得出它的计数值，就可以知道电机产生的脉冲数，再根据电机的参数（每转产生多少个脉冲）就可以得到电机转了几圈</p></blockquote><h3 id="测速方法"><a href="#测速方法" class="headerlink" title="测速方法"></a>测速方法</h3><h4 id="M法测速"><a href="#M法测速" class="headerlink" title="M法测速"></a>M法测速</h4><p>又叫做频率测量法。该方法是在一个固定的时间内（以秒为单位），统计这段时间的编码器脉冲数，计算速度值。M法适合测量高速。</p><p>假设：</p><p>编码器单圈总脉冲数为C（常数）</p><p>统计时间为T0</p><p>该时间内统计到的编码器脉冲数为M0</p><p>则：转速n（圈&#x2F;秒）的计算公式为：![]!<img src="http://45.92.193.42:7788/i/2022/07/12/62cd39fea709a.jpg" alt="08.jpg"></p><p>如何理解这个公式：<br> M0&#x2F;C 即统计时间内有多少个编码器脉冲，再除以统计时间T0，即1s（单位时间）内转了多少圈</p><h4 id="T法测速"><a href="#T法测速" class="headerlink" title="T法测速"></a>T法测速</h4><blockquote><p>待更新……..</p></blockquote><h4 id="MT法测速"><a href="#MT法测速" class="headerlink" title="MT法测速"></a>MT法测速</h4><blockquote><p>待更新……..</p></blockquote><h2 id="使用编码器模式时需要注意以下几点："><a href="#使用编码器模式时需要注意以下几点：" class="headerlink" title="使用编码器模式时需要注意以下几点："></a>使用编码器模式时需要注意以下几点：</h2><blockquote><p>1.编码器有个转速上限,超过这个上限是不能正常工作的,这个是硬件的限制,原则上线数越多转速就越低,这点在选型时要注意。</p></blockquote><blockquote><p>定时器初始化好以后,任何时候CNT寄存器的值就是编码器的位置信息,正转他会加反转他会减这部分是不需要软件干预的,初始化时给的TIM_Period 值应该是码盘整圈的刻度值,在减溢出会自动修正为这个数.加超过此数值就回0.</p></blockquote><blockquote><p>计数值偶尔也会有出错误的情况,一圈多计一个或少计一个数都是很正常的特别是转速比较高的时候尤其明显,有个绝对位置信号做修正是很有必要的.绝对位置信号不需要一定在零位置点,收到这个信号就将CNT修正为一个固定的数值即可.</p></blockquote><h2 id="编码器模式基础配置"><a href="#编码器模式基础配置" class="headerlink" title="编码器模式基础配置"></a>编码器模式基础配置</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">void encoder_init(void)&#123;  GPIO_InitTypeDef GPIO_InitStructure;  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;  TIM_ICInitTypeDef TIM_ICInitStructure;   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);    GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_6 | GPIO_Pin_7;  GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF;    GPIO_InitStructure.GPIO_PuPd &#x3D; GPIO_PuPd_NOPULL;  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);  GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_TIM3);      GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_TIM3);&#x2F;&#x2F;Specifies the prescaler value used to divide the TIM clock.&#x2F;&#x2F;也就是说，这里的TIM3的时钟信号其实是由A&#x2F;B相的频率来决定的，类似于外部时钟，然后分频就是对这个脉冲频率分频，比如二分频就是把两个脉冲记为一个脉冲。TIM_TimeBaseStructure.TIM_Prescaler &#x3D; 1-1;  &#x2F;&#x2F;这里我们把它设为1，即不分频TIM_TimeBaseStructure.TIM_Period &#x3D; 65535;  &#x2F;&#x2F;每来一个脉冲信号的上升沿（下面有设置）计数值就累加（或累减），65535则为最大计数值，就溢出了TIM_TimeBaseStructure.TIM_ClockDivision &#x3D; TIM_CKD_DIV1;TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising ,TIM_ICPolarity_Rising);   &#x2F;&#x2F;配置为编码器模式，计数器在TI1和TI2上升沿处均计数TIM_SetCounter(TIM3, 0);&#x2F;&#x2F;将脉冲计数值设为零TIM_Cmd(TIM3, ENABLE);&#x2F;&#x2F;使能TIM3&#125;&#x2F;&#x2F; 读取定时器计数值uint32_t read_cnt(void)&#123;uint32_t encoder_cnt;encoder_cnt &#x3D; TIM3-&gt;CNT;&#x2F;&#x2F;读取计数器CNT的值，CNT系uint32_t型的变量TIM_SetCounter(TIM3, 0);&#x2F;&#x2F;每一次读取完计数值后将计数值清零，重新开始累加脉冲，方便下一次计数return encoder_cnt;&#x2F;&#x2F;返回的值就是本次读到的计数值&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="有个问题"><a href="#有个问题" class="headerlink" title="有个问题"></a>有个问题</h2><p>编码器配置的时候,TI1,TI2捕获的都是上升沿,应该是二倍频为什么&#x2F;4,为什么不配置成上下都捕获的</p><blockquote><p>小白,还在努力学习,如有错误,请多指教</p></blockquote><p><a href="https://blog.csdn.net/hbsyaaa/article/details/113784920">参考文章1</a></p><p><a href="https://blog.csdn.net/hbsyaaa/article/details/114715319?ops_request_misc=&request_id=&biz_id=102&utm_term=%E7%BC%96%E7%A0%81%E5%99%A8%E8%BD%AC%E4%B8%80%E5%9C%88%E7%9A%84%E8%84%89%E5%86%B2%E6%95%B0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-114715319.142%5Ev10%5Econtrol,157%5Ev4%5Econtrol&spm=1018.2226.3001.4187">参考文章2</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32f407 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32f401搭建工程</title>
      <link href="/2022/05/12/10h-stm32f401-project/"/>
      <url>/2022/05/12/10h-stm32f401-project/</url>
      
        <content type="html"><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="Error-L6218E-Undefined-symbol-xxx-referred-from-xxxx-o"><a href="#Error-L6218E-Undefined-symbol-xxx-referred-from-xxxx-o" class="headerlink" title="Error: L6218E: Undefined symbol xxx (referred from xxxx.o)."></a>Error: L6218E: Undefined symbol xxx (referred from xxxx.o).</h3><p>正常是因为缺文件,加进去就行了,可是我这个不缺文件</p><blockquote><p>解决:全删了重新加</p></blockquote><h3 id="文件有钥匙出现-error过多"><a href="#文件有钥匙出现-error过多" class="headerlink" title="文件有钥匙出现,error过多"></a>文件有钥匙出现,error过多</h3><p>文件为只读状态,无法取消只读状态</p><blockquote><p>解决:从没有只读状态的文件夹里复制进去即可</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32F401 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发板供电相关问题</title>
      <link href="/2022/05/09/9h-destroy-chips/"/>
      <url>/2022/05/09/9h-destroy-chips/</url>
      
        <content type="html"><![CDATA[<h1 id="😭喜得一具f407板砖"><a href="#😭喜得一具f407板砖" class="headerlink" title="😭喜得一具f407板砖"></a>😭喜得一具f407板砖</h1><p>用l298n5v给单片机供电</p><p>l298n5v接单片机5v,我刚开始寻思为啥灯不亮,后来灯亮了,芯片也烧了</p><p>为什么这么做:</p><blockquote><p>之前使用arduion的时候是用l298n5v直接接单片机5v的,f103c8t6也是这么干的</p></blockquote><blockquote><p>我好像记得的手册上写引脚是耐5v的</p></blockquote><blockquote><p>恩3.3V的芯片，最大3.6V电压</p></blockquote><blockquote><p>引脚是可以兼容5.0V的 ，但是电源不可以</p></blockquote><h2 id="no-device-jlink不识别开发板芯片"><a href="#no-device-jlink不识别开发板芯片" class="headerlink" title="no device,jlink不识别开发板芯片"></a>no device,jlink不识别开发板芯片</h2><p>下载程序后,突然就显示<code>no device sw...</code>,不能下载程序</p><h3 id="原因-程序占用了sw的io口"><a href="#原因-程序占用了sw的io口" class="headerlink" title="原因:程序占用了sw的io口"></a>原因:程序占用了sw的io口</h3><h3 id="解决"><a href="#解决" class="headerlink" title="解决:"></a>解决:</h3><blockquote><p>(1)BOOT0拉高,复位,下载,再拉低(我用不好使)</p></blockquote><blockquote><p>(2)删掉有关jlink配置的文件,在keil中重新配置(不会,不敢删,没有实践过)</p></blockquote><blockquote><p>(3)使用串口,将原来的程序替换掉(不知道为啥,串口下不进去,但是jlink好了)</p></blockquote><blockquote><p>(4)串口下载的提示:</p></blockquote><blockquote><p>在串口COM6连接成功@76800bps，耗时406毫秒<br>芯片内BootLoader版本号：3.1<br>芯片PID：00000413<br>芯片已设置读保护，无法读取更多信息<br>初始化RamIsp<br>调试信息：-8RamIsp:STM_WriteMemory<br>写入出错在初始化:下载,耗时453毫秒</p></blockquote><p>出现这种情况看2.2.1串口注意事项,有可能是这些方面出了问题</p><blockquote><p>解决:<br>理论上串口下载完,jlink就可以正常下载了,因为换程序不占用io了<br>后来使用FlyMcu串口下载时,正常了</p></blockquote><h4 id="串口注意事项"><a href="#串口注意事项" class="headerlink" title="串口注意事项"></a>串口注意事项</h4><p>(1)正点原子波特率76800,使用串口时,其他串口需要用跳线帽连接<br>(2)不要勾选编程到flash<br>(3)不要勾选ramsip</p><h4 id="插入jlink-无法识别usb"><a href="#插入jlink-无法识别usb" class="headerlink" title="插入jlink,无法识别usb"></a>插入jlink,无法识别usb</h4><blockquote><p>卸载干净驱动,安装个新的,不行再换,也可能是反复拔插产生静电,断电重启即可</p></blockquote><h4 id="串口下载的问题"><a href="#串口下载的问题" class="headerlink" title="串口下载的问题"></a>串口下载的问题</h4><p>开始编程芯片，共需写入3KB,耗时187毫秒<br>写入出错在0KB,进度0%,耗时203毫秒</p><blockquote><p>(1)调小波特率试试</p></blockquote><blockquote><p>(2)卸载ch340,重新安装,重新插入usb线(无法解释,我愿意称之为玄学,并且有时候flymcu好使,mcuisp不好使,有时候相反)</p></blockquote><h2 id="关于最近的学习"><a href="#关于最近的学习" class="headerlink" title="关于最近的学习"></a>关于最近的学习</h2><p>最近在学pid,找了很多资料,各个模块代码,总感觉缺点什么,不知道下一步做什么,或者说,不知道怎么把各部分串起来</p><blockquote><p>基础很重要,先分开去写代码,验证,不要一上来,多个代码文件一起写,会导致思路不清晰,有疏漏,一步一步做慢一点,可以巩固一下基础部分,收获到以前没有注意到的知识</p></blockquote><blockquote><p>快即是慢,慢即是快</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32f407 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建linux服务器部分</title>
      <link href="/2022/05/08/8l-hexo-linux/"/>
      <url>/2022/05/08/8l-hexo-linux/</url>
      
        <content type="html"><![CDATA[<h2 id="部署环境与准备"><a href="#部署环境与准备" class="headerlink" title="部署环境与准备"></a>部署环境与准备</h2><p>1.环境</p><ul><li>本地Windows10操作系统<br>Ubuntu20.06系统云服务器</li></ul><p>2.准备</p><ul><li>Hexo 本地博客,上一篇文章本地端已经搭建完成<br><a href="http://www.isgeek.top/2022/05/03/1l-hexo-blog/">linux搭建hexo博客(本地端)</a></li></ul><p>3.流程</p><blockquote><p>安装最新版git,编译并安装,配置环境,</p><p>设置秘钥,新建用户用来连接服务器,安装nginx,建立git库</p></blockquote><h2 id="云服务器配置Git"><a href="#云服务器配置Git" class="headerlink" title="云服务器配置Git"></a>云服务器配置Git</h2><h3 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h3><p>centos</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>debian</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get install -y curl libcurl4-openssl-dev expat libexpat1-dev gettext libgettextpo-dev libssl-dev zlib1g-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h3><p>centos</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install gcc perl-ExtUtils-MakeMaker package<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>debian</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get install -y build-essential perl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看git的版本"><a href="#查看git的版本" class="headerlink" title="查看git的版本"></a>查看git的版本</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git versionyum remove git -y      #删除gitapt-get remove git -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="下载解压最新版"><a href="#下载解压最新版" class="headerlink" title="下载解压最新版"></a>下载解压最新版</h3><p>现在可以使用<strong>apt</strong>安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt updatesudo apt install git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以使用<strong>wget</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;usr&#x2F;local&#x2F;src #切换到下载的目录 wget https:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;software&#x2F;scm&#x2F;git&#x2F;git-2.39.0.tar.gz #下载最新版 tar -zxvf git-2.39.0.tar.gz #解压到当前文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="编译并安装"><a href="#编译并安装" class="headerlink" title="编译并安装"></a>编译并安装</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd git-2.39.0    #进入文件夹make prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git all    #编译源码make prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git install    #安装路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="配置git环境变量"><a href="#配置git环境变量" class="headerlink" title="配置git环境变量"></a>配置git环境变量</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &#39;export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;git&#x2F;bin&#39; &gt;&gt; &#x2F;etc&#x2F;bashrcsource &#x2F;etc&#x2F;bashrc   &#x2F;&#x2F;刷新环境变量git --version        &#x2F;&#x2F;查看版本号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;bin 目录下创建了一个名为 git-receive-pack 的符号链接该链接指向了源文件 &#x2F;usr&#x2F;local&#x2F;git&#x2F;bin&#x2F;git-receive-pack#确保 git-receive-pack 可执行文件可以在系统的 PATH 中找到，从而解决了与 Git 相关的问题ln -s &#x2F;usr&#x2F;local&#x2F;git&#x2F;bin&#x2F;git-receive-pack &#x2F;usr&#x2F;bin&#x2F;git-receive-pack#可能原因为环境变量配置失败,没办法在环境变量中找到执行命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="🚨注意"><a href="#🚨注意" class="headerlink" title="🚨注意:"></a>🚨注意:</h3><p>将 <strong>export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;git&#x2F;bin</strong>添加到当前的 Shell 会话中，以<strong>临时</strong>更改 PATH 环境变量，以便在当前 Shell 会话中查找 <code>git</code> 命令的路径。</p><p>这个更改只在当前会话中有效，当你关闭该终端会话时，它会失效。</p><p><strong>echo export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;git&#x2F;bin&gt;&gt; &#x2F;etc&#x2F;bashrc</strong>：这个命令与上述命令相似，但它将指定的文本附加到 <code>/etc/bashrc</code> 文件的末尾，这是一个系统级的 Bash 配置文件。</p><p>这意味着当任何用户登录到系统时，都会执行 <code>/etc/bashrc</code> 中的命令，从而永久更改 PATH 环境变量</p><h3 id="创建git用户"><a href="#创建git用户" class="headerlink" title="创建git用户"></a>创建git用户</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">adduser 用户   #自己起一个就行passwd 密码    #这个密码必须复杂,过于简单会被破解~mPr^DLB&amp;C^TwYfGI9klL(Pi*TY!(Kyr+n^WJ5IQ#修改权限chmod 740 &#x2F;etc&#x2F;sudoersvim &#x2F;etc&#x2F;sudoers root ALL&#x3D;(ALL) ALL 用户 ALL&#x3D;(ALL) ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="本地端使用Gitbash创建密钥"><a href="#本地端使用Gitbash创建密钥" class="headerlink" title="本地端使用Gitbash创建密钥"></a>本地端使用Gitbash创建密钥</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa.将本地创建&#96;id_rsa.pub&#96;中文件复制(此文件在c盘.&#x2F;ssh文件夹)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">su 用户    mkdir ~&#x2F;.sshvim ~&#x2F;.ssh&#x2F;authorized_keysssh -v 用户@服务器ip  #测试可以连接服务器上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建网站目录并设置权限"><a href="#创建网站目录并设置权限" class="headerlink" title="创建网站目录并设置权限"></a>创建网站目录并设置权限</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">su rootmkdir &#x2F;home&#x2F;hexo#给用户对当前目录下的所有文件与子目录进行相同的拥有者变更chown 用户名:用户名 -R &#x2F;home&#x2F;hexo #chown maobing:maobing -R &#x2F;home&#x2F;hexo#chown用于将指定文件的所有者修改为指定用户或组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt install -y nginx             #可能会出现没有安装包的问题systemctl start nginx.service    #启动服务#如果出现没有可用的软件包的问题yum install epel-release epel    #安装扩展yum update                       #更新<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改Nginx配置文件"><a href="#修改Nginx配置文件" class="headerlink" title="修改Nginx配置文件"></a>修改Nginx配置文件</h3><blockquote><p>vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf </p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen       80 default_server;    listen       [::]:80 default_server;    server_name  fuchenchenle.cn;        #域名    root         &#x2F;home&#x2F;hexo;             #网站目录&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者(推荐)</p><blockquote><p>vim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;hexo.conf</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 80;    server_name www.isgeek.top; # 你的域名    root &#x2F;home&#x2F;hexo; # 网站目录的路径    location &#x2F; &#123;        try_files $uri $uri&#x2F; &#x3D;404;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#检查语法错误nginx -t<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 ln 命令创建一个符号链接到 &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F; 目录。该目录包含了 Nginx 服务器实际使用的虚拟主机配置文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;hexo.conf &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#重启服务器systemctl restart nginx.service  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="⭐️建立git库"><a href="#⭐️建立git库" class="headerlink" title="⭐️建立git库"></a>⭐️建立git库</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;home&#x2F;用户# !!!!新版需要设置,否则会一直找不到到仓库git config --global init.defaultBranch mastergit init --bare blog.gitchown 用户:用户 -R blog.git#chown maobing:maobing -R blog.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="同步网站根目录"><a href="#同步网站根目录" class="headerlink" title="同步网站根目录"></a>同步网站根目录</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim blog.git&#x2F;hooks&#x2F;post-receive#!&#x2F;bin&#x2F;shgit --work-tree&#x3D;&#x2F;home&#x2F;hexo --git-dir&#x3D;&#x2F;home&#x2F;用户&#x2F;blog.git checkout -f#修改权限!chmod +x &#x2F;home&#x2F;用户&#x2F;blog.git&#x2F;hooks&#x2F;post-receive   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在windows10本地hexo目录修改-config-yml文件"><a href="#在windows10本地hexo目录修改-config-yml文件" class="headerlink" title="在windows10本地hexo目录修改_config.yml文件"></a>在windows10本地hexo目录修改_config.yml文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:  type: git   #用户名@服务器Ip:git仓库位置  repository: 用户@49.232.59.235:&#x2F;home&#x2F;fuchen&#x2F;blog.git   branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="本机gitbash部署"><a href="#本机gitbash部署" class="headerlink" title="本机gitbash部署"></a>本机gitbash部署</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo cleanhexo g -dhexo cl &amp;&amp; hexo g &amp;&amp; hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keil常见报错</title>
      <link href="/2022/05/08/7h-keil-error/"/>
      <url>/2022/05/08/7h-keil-error/</url>
      
        <content type="html"><![CDATA[<h2 id="keil出现乱码"><a href="#keil出现乱码" class="headerlink" title="keil出现乱码"></a>keil出现乱码</h2><blockquote><p>edit-&gt;configuration-&gt;在弹出的对话框中选择Editor—&gt;Encoding—–&gt; Chinese GB2312(Simplified)</p></blockquote><h3 id="未显示-h文件-未生成hex文件"><a href="#未显示-h文件-未生成hex文件" class="headerlink" title="未显示.h文件,未生成hex文件,"></a>未显示.h文件,未生成hex文件,</h3><blockquote><p>1.只需编译一下main文件</p></blockquote><blockquote><p>2.可能是因为有错误,需要先编译一下改错</p></blockquote><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><h3 id="Error-L6218E"><a href="#Error-L6218E" class="headerlink" title="Error:L6218E"></a>Error:L6218E</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>…\OBJ\USART.axf: Error: L6218E: Undefined symbol ADC_Cmd (referred from adc.o).</p><blockquote><p>一般出现这个问题是因为没有加入ST的官方库文件<br>在<code>Fwlib</code>文件夹中假如对应的.c文件,比如<code>adc.c</code></p></blockquote><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p>error: L6218E: Undefined symbol Delay_ms (referred from lcd.o).</p><blockquote><p>Delay_ms  Delay_us  这两个没有定义，检查这两处</p></blockquote><h3 id="invalid-in-C99"><a href="#invalid-in-C99" class="headerlink" title="invalid in C99"></a>invalid in C99</h3><blockquote><p>很有可能是头文件书写错误,比如ifndef写成ifdef</p></blockquote><h3 id="error-268-declaration-may-not-appear-after-executable-statement"><a href="#error-268-declaration-may-not-appear-after-executable-statement" class="headerlink" title="error: #268: declaration may not appear after executable statement"></a>error: #268: declaration may not appear after executable statement</h3><blockquote><p>此错误中文意思：声明不能在可执行语句后出现</p></blockquote><blockquote><p>表示有变量在函数后面声明，应该改为在函数开头声明变量。</p></blockquote><blockquote><p>在Keil环境中编译程序，变量的声明应在主函数起始位置，如果有此报错，一定是变量声明在执行函数后</p></blockquote><h3 id="Error-L6915E-Library-reports-error-use-no-semihosting-was-requested"><a href="#Error-L6915E-Library-reports-error-use-no-semihosting-was-requested" class="headerlink" title="Error: L6915E: Library reports error: __use_no_semihosting was requested"></a>Error: L6915E: Library reports error: __use_no_semihosting was requested</h3><blockquote><p>魔术棒-&gt;usemotolLIB</p></blockquote><h2 id="waring"><a href="#waring" class="headerlink" title="waring"></a>waring</h2><h3 id="warning-1295-D-Deprecated-declaration-LED-Init-give-arg-types"><a href="#warning-1295-D-Deprecated-declaration-LED-Init-give-arg-types" class="headerlink" title="warning: #1295-D: Deprecated declaration LED_Init - give arg types"></a>warning: #1295-D: Deprecated declaration LED_Init - give arg types</h3><blockquote><p>.h文件中函数定义()里加上void即可</p></blockquote><h3 id="WARNING-L1-UNRESOLVED-EXTERNAL-SYMBOL"><a href="#WARNING-L1-UNRESOLVED-EXTERNAL-SYMBOL" class="headerlink" title="WARNING L1: UNRESOLVED EXTERNAL SYMBOL"></a>WARNING L1: UNRESOLVED EXTERNAL SYMBOL</h3><p>SYMBOL: ADC_VAL<br>MODULE: .\main.obj (MAIN)<br>ADC_VAL该参数未定义。</p><h3 id="error-165-too-few-arguments-in-function-call"><a href="#error-165-too-few-arguments-in-function-call" class="headerlink" title="error: #165: too few arguments in function call"></a>error: #165: too few arguments in function call</h3><blockquote><p>添加头文件后源.c文件中函数有参数但是实际调用时没有。</p></blockquote><blockquote><p>方法一：源.c文件中的函数不要有参数</p></blockquote><blockquote><p>方法二：调用函数时把参数写上。</p></blockquote><hr><hr><h3 id="ERROR-167-ARGUMENT-OF-TYPE-“UINT16-T-“-IS-INCOMPATIBLE-WITH-PARAMETER-OF-TYP"><a href="#ERROR-167-ARGUMENT-OF-TYPE-“UINT16-T-“-IS-INCOMPATIBLE-WITH-PARAMETER-OF-TYP" class="headerlink" title="ERROR: #167: ARGUMENT OF TYPE “UINT16_T *“ IS INCOMPATIBLE WITH PARAMETER OF TYP"></a>ERROR: #167: ARGUMENT OF TYPE “UINT16_T *“ IS INCOMPATIBLE WITH PARAMETER OF TYP</h3><p>使用printf串口打印adc数据是报的错<br>变量类型’无符号长整型’与参数类型不匹配”<br>应该是你在第167行调用函数时所传的参数类型是”无符号长整型的”,但这个函数所要求的参数不是这个类型的<br>检查下函数声名,然后按要求给参数试试<br>个人理解,调用printf函数式穿的参数类型与printf函数要求的参数类型不同<br>使用printf是报错,可能是因为使用的是单引号,改成双引号就不报错了</p><h3 id="error-260-D-explicit-type-is-missing-“int”-assumed"><a href="#error-260-D-explicit-type-is-missing-“int”-assumed" class="headerlink" title="error:  #260-D: explicit type is missing (“int” assumed)"></a>error:  #260-D: explicit type is missing (“int” assumed)</h3><p>usart.c文件中</p><blockquote><p>定义  _sys_exit(int x)  以避免使用半主机模式,函数没有返回类型，假定其返回类型为int，可以写为void void  _sys_exit(int x) ，否则编译器会默认为返回int类型，故会出现上述警告。<br>解决办法：应该写成void  _sys_exit(int x) </p></blockquote><p>有的工程会报错,有的工程不会</p><h2 id="开发51单片机时可能出现的报错"><a href="#开发51单片机时可能出现的报错" class="headerlink" title="开发51单片机时可能出现的报错"></a>开发51单片机时可能出现的报错</h2><h3 id="error-C129-missing-‘-’-before-‘0000’"><a href="#error-C129-missing-‘-’-before-‘0000’" class="headerlink" title="error C129: missing ‘;’ before ‘0000’"></a>error C129: missing ‘;’ before ‘0000’</h3><p>用汇编写的程序，却用.c文件来保存的。</p><p>解决方案：只要将后缀改成.asm即可。</p><h3 id="关于8051汇编语言的keil中出现的A45-UNDEFINED-SYMBOL-PASS-2-错误"><a href="#关于8051汇编语言的keil中出现的A45-UNDEFINED-SYMBOL-PASS-2-错误" class="headerlink" title="关于8051汇编语言的keil中出现的A45: UNDEFINED SYMBOL (PASS-2)错误"></a>关于8051汇编语言的keil中出现的A45: UNDEFINED SYMBOL (PASS-2)错误</h3><p>这里的代码段在END之后,被忽略了.所以就会出现A45: UNDEFINED <a href="https://so.csdn.net/so/search?q=SYMBOL&spm=1001.2101.3001.7020">SYMBOL</a> ,因为在END之后的代码全被忽略了。</p><p>解决方法：将END写在代码的最后面。</p><p> 还有一种情况就是立即数#FFH，要写成#0FFH，因为字母打头。</p><p>(在汇编语言中十六进制的立即数有一个规则，当十六进制数是字母开头时要在前面加0，<br>这也就是为什么时#0C0H 而不是 #C0H的原因了）</p><h2 id="jlink问题"><a href="#jlink问题" class="headerlink" title="jlink问题"></a>jlink问题</h2><p>Error: Flash Download failed - “Cortex-M4”</p><h3 id="缺少flash文件"><a href="#缺少flash文件" class="headerlink" title="缺少flash文件"></a>缺少flash文件</h3><blockquote><p>魔术棒-&gt;debug-&gt;srttings-&gt;flash download-&gt;add</p></blockquote><h3 id="可能是因为开着串口-将串口关闭即可"><a href="#可能是因为开着串口-将串口关闭即可" class="headerlink" title="可能是因为开着串口,将串口关闭即可"></a>可能是因为开着串口,将串口关闭即可</h3><h3 id="cannot-load-flash-device-description"><a href="#cannot-load-flash-device-description" class="headerlink" title="cannot load flash device description"></a>cannot load flash device description</h3><blockquote><p><code>jlink</code>选错了,打开<code>settingsswd</code>有芯片id,<code>flash downloadrese and run</code>选上,最后flash算法必须有,就是下面的空白栏有一条信息<br>如果还报错,<code>Utilities</code>,-&gt;<code>use debug driver</code></p></blockquote><h3 id="jlink无法识别的usb设备"><a href="#jlink无法识别的usb设备" class="headerlink" title="jlink无法识别的usb设备"></a>jlink无法识别的usb设备</h3><blockquote><p>(1)频繁拔插会产生静电,将电脑重启(2)更新驱动,②换一台电脑插一下,再插回去就好了,③如果另一台电脑也不好使,那就说明固件丢失,重新刷入</p></blockquote><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><blockquote><p>串口助手连蓝牙不需要发送新行和回车hc-06()</p></blockquote><h2 id="字体问题"><a href="#字体问题" class="headerlink" title="字体问题"></a>字体问题</h2><h3 id="注释的字横过来可能是因为字体前面有-将字体换为没有-的即可"><a href="#注释的字横过来可能是因为字体前面有-将字体换为没有-的即可" class="headerlink" title="注释的字横过来可能是因为字体前面有@,将字体换为没有@的即可"></a>注释的字横过来可能是因为字体前面有@,将字体换为没有@的即可</h3><h3 id="注释中的汉字变成了问号，显示不出来"><a href="#注释中的汉字变成了问号，显示不出来" class="headerlink" title="注释中的汉字变成了问号，显示不出来"></a>注释中的汉字变成了问号，显示不出来</h3><blockquote><p>view-&gt;configuration-&gt;editor-&gt;encoding-&gt;chinese gb2312 simplified</p></blockquote><h3 id="按回车后光标距离很大"><a href="#按回车后光标距离很大" class="headerlink" title="按回车后光标距离很大"></a>按回车后光标距离很大</h3><p>view-&gt;configuration-&gt;editor-&gt;encoding-&gt;tab size</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> keil </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32f407定时器中断</title>
      <link href="/2022/05/07/6h-f407timer/"/>
      <url>/2022/05/07/6h-f407timer/</url>
      
        <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><h3 id="使用定时器中断-每两秒发送一个以1为步长增长的数"><a href="#使用定时器中断-每两秒发送一个以1为步长增长的数" class="headerlink" title="使用定时器中断,每两秒发送一个以1为步长增长的数"></a>使用定时器中断,每两秒发送一个以1为步长增长的数</h3><h2 id="我的误区"><a href="#我的误区" class="headerlink" title="我的误区"></a>我的误区</h2><p>开始以为在定时器中断得到的数需要发给串口,用<code>USART_SendData(USART1, res);</code>发送给电脑显示数据</p><h2 id="正确方法"><a href="#正确方法" class="headerlink" title="正确方法"></a>正确方法</h2><p>正点原子的<code>usart</code>加入了对<code>printf</code>的支持,所以应该是在哪里都可以使用<code>printf</code>将数据打印发给电脑</p><p>&#x2F;&#x2F;定时器3中断服务函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void TIM3_IRQHandler(void)&#123;   static int time&#x3D;0;if(TIM_GetITStatus(TIM3,TIM_IT_Update)&#x3D;&#x3D;SET) &#x2F;&#x2F;溢出中断&#123;    LED1&#x3D;!LED1;&#x2F;&#x2F;DS1翻转    time+&#x3D;1;    printf(&quot;时间 &#x3D;%d\r\n&quot;,time);&#125;TIM_ClearITPendingBit(TIM3,TIM_IT_Update);  &#x2F;&#x2F;清除中断标志位&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在定时器的基础上加上看门狗-每隔10秒停止喂狗一次-重置"><a href="#在定时器的基础上加上看门狗-每隔10秒停止喂狗一次-重置" class="headerlink" title="在定时器的基础上加上看门狗,每隔10秒停止喂狗一次,重置"></a>在定时器的基础上加上看门狗,每隔10秒停止喂狗一次,重置</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int main(void)&#123;   NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);&#x2F;&#x2F;设置系统中断优先级分组2delay_init(168);&#x2F;&#x2F;延时初始化 uart_init(115200);&#x2F;&#x2F;串口初始化波特率为115200LED_Init();  &#x2F;&#x2F;初始化与LED连接的硬件接口    LED0&#x3D;0;   &#x2F;&#x2F;红  TIM3_Int_Init(20000-1,8400-1); &#x2F;&#x2F;定时器2s中断一次  IWDG_Init(6,1000);   &#x2F;*与分频数为prer4,rlr重载值为500,溢出时间为1s   16*4*500&#x2F;32&#x3D;1000   与分频数为prer6,rlr重载值为1000,溢出时间为10s  256*4*1000&#x2F;32&#x3D;32000  ??????为啥溢出时间不是32秒而是10秒      Tout&#x3D;((4×2^prer)×rlr)32     prer:分频数:0~7(只有低 3 位有效!)  rlr:自动重装载值,0~0XFFF.   分频因子&#x3D;4*2^prer.但最大值只能是256! &#x2F;32  32   rlr:重装载寄存器值:低 11 位有效*&#x2F;while(1)&#123;   if(KEY_Scan(0)&#x3D;&#x3D;WKUP_PRES)&#x2F;&#x2F;如果WK_UP按下,则喂狗&#123;IWDG_Feed();&#x2F;&#x2F;喂狗&#125;delay_ms(10);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32F407 </tag>
            
            <tag> TIMER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm安装依赖问题</title>
      <link href="/2022/05/06/5l-npm-dependence/"/>
      <url>/2022/05/06/5l-npm-dependence/</url>
      
        <content type="html"><![CDATA[<h2 id="搭建hexo博客用npm安装插件出现的问题"><a href="#搭建hexo博客用npm安装插件出现的问题" class="headerlink" title="搭建hexo博客用npm安装插件出现的问题"></a>搭建hexo博客用npm安装插件出现的问题</h2><p>To address issues that do not require attention, run: npm audit fix Some issuse</p><p>通过以下步骤解决</p><h3 id="切换为淘宝的npm国内镜像"><a href="#切换为淘宝的npm国内镜像" class="headerlink" title="切换为淘宝的npm国内镜像"></a>切换为淘宝的npm国内镜像</h3><blockquote><p>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p></blockquote><h3 id="npm更新到最新版本"><a href="#npm更新到最新版本" class="headerlink" title="npm更新到最新版本"></a>npm更新到最新版本</h3><blockquote><p>npm install npm@latest -g</p></blockquote><h3 id="删除package-lock-json文件"><a href="#删除package-lock-json文件" class="headerlink" title="删除package-lock.json文件"></a>删除<code>package-lock.json</code>文件</h3><blockquote><p>重新使用<code>npm i</code>即可</p></blockquote><p>(这个问题也可以这样解决,目前没有遇到.所以还没试过<code>har-validator@5.1.2 Not found</code>问题)</p><h2 id="安装时出现run-npm-audit-fix-to-fix-them-or-npm-audit-for-details"><a href="#安装时出现run-npm-audit-fix-to-fix-them-or-npm-audit-for-details" class="headerlink" title="安装时出现run npm audit fix to fix them, or npm audit for details"></a>安装时出现run <code>npm audit fix</code> to fix them, or <code>npm audit</code> for details</h2><blockquote><p>1 npm audit fix</p></blockquote><blockquote><p>2 npm audit fix –force</p></blockquote><blockquote><p>3 npm audit</p></blockquote><p>如果还是不行的话，可以把<code>node_modules</code>和<code>package-lock.json</code>删掉</p><blockquote><p>运行<code>npm install</code></p></blockquote><p>再运行上述的3行代码</p><h2 id="npm-install-报错-gyp-info-it-worked-if-it-ends-with-ok-npm-ERR-gyp-verb-cli"><a href="#npm-install-报错-gyp-info-it-worked-if-it-ends-with-ok-npm-ERR-gyp-verb-cli" class="headerlink" title="npm install 报错 gyp info it worked if it ends with ok npm ERR! gyp verb cli"></a>npm install 报错 gyp info it worked if it ends with ok npm ERR! gyp verb cli</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">ERR! code 1npm ERR! path C:\Users\Administrator\Desktop\14531\mall-admin-web\node_modules\node-sassnpm ERR! command failednpm ERR! command C:\Windows\system32\cmd.exe &#x2F;d &#x2F;s &#x2F;c node scripts&#x2F;build.jsnpm ERR! Building: C:\Program Files\nodejs\node.exe C:\Users\Administrator\Desktop\14531\mall-admin-web\node_modules\node-gyp\bin\node-gyp.js rebuild --verbose --libsass_ext&#x3D; --libsass_cflags&#x3D; --libsass_ldflags&#x3D; --libsass_library&#x3D;npm ERR! gyp info it worked if it ends with oknpm ERR! gyp verb cli [npm ERR! gyp verb cli   &#39;C:\\Program Files\\nodejs\\node.exe&#39;,npm ERR! gyp verb cli   &#39;C:\\Users\\Administrator\\Desktop\\14531\\mall-admin-web\\node_modules\\node-gyp\\bin\\node-gyp.js&#39;,npm ERR! gyp verb cli   &#39;rebuild&#39;,npm ERR! gyp verb cli   &#39;--verbose&#39;,npm ERR! gyp verb cli   &#39;--libsass_ext&#x3D;&#39;,npm ERR! gyp verb cli   &#39;--libsass_cflags&#x3D;&#39;,npm ERR! gyp verb cli   &#39;--libsass_ldflags&#x3D;&#39;,npm ERR! gyp verb cli   &#39;--libsass_library&#x3D;&#39;npm ERR! gyp verb cli ]npm ERR! gyp info using node-gyp@3.8.0npm ERR! gyp info using node@14.16.0 | win32 | x64npm ERR! gyp verb command rebuild []npm ERR! gyp verb command clean []npm ERR! gyp verb clean removing &quot;build&quot; directorynpm ERR! gyp verb command configure []npm ERR! gyp verb check python checking for Python executable &quot;python2&quot; in the PATHnpm ERR! gyp verb &#96;which&#96; failed Error: not found: python2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>解决方法</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">npm install -g mirror-config-china --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.orgnpm install node-sassnpm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux搭建MC服务器</title>
      <link href="/2022/05/04/4l-linux-establish-minecraft/"/>
      <url>/2022/05/04/4l-linux-establish-minecraft/</url>
      
        <content type="html"><![CDATA[<h2 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h2><p>Minecraft服务端也需要jre才能运行<br>(1)</p><blockquote><p>sudo yum install java-1.8.0-openjdk</p></blockquote><p>(2)<a href="https://www.oracle.com/java/technologies/javase-jre8-downloads.html%EF%BC%89linux">官网下载,上传到服务器</a></p><h3 id="创建安装目录"><a href="#创建安装目录" class="headerlink" title="创建安装目录"></a>创建安装目录</h3><blockquote><p>mkdir &#x2F;usr&#x2F;local&#x2F;java&#x2F;</p></blockquote><h4 id="解压当前目录下的JDK压缩文件-版本不一样文件名也会不一样，善用tab自动补全"><a href="#解压当前目录下的JDK压缩文件-版本不一样文件名也会不一样，善用tab自动补全" class="headerlink" title="解压当前目录下的JDK压缩文件(版本不一样文件名也会不一样，善用tab自动补全)"></a>解压当前目录下的JDK压缩文件(版本不一样文件名也会不一样，善用tab自动补全)</h4><blockquote><p>tar -zxvf jdk-8u271-linux-x64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;java&#x2F;</p></blockquote><h4 id="方便后面配置环境，改一下文件名"><a href="#方便后面配置环境，改一下文件名" class="headerlink" title="方便后面配置环境，改一下文件名"></a>方便后面配置环境，改一下文件名</h4><blockquote><p>mv &#x2F;usr&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_271 &#x2F;usr&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0</p></blockquote><h4 id="设置环境变量-安装-VIM-输入-yum-y-install-vim"><a href="#设置环境变量-安装-VIM-输入-yum-y-install-vim" class="headerlink" title="设置环境变量(安装 VIM 输入 yum -y install vim)"></a>设置环境变量(安装 VIM 输入 yum -y install vim)</h4><p>vim &#x2F;etc&#x2F;profile</p><h4 id="在末尾添加对应变量"><a href="#在末尾添加对应变量" class="headerlink" title="在末尾添加对应变量"></a>在末尾添加对应变量</h4><blockquote><p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0<br>export JRE_HOME&#x3D;${JAVA_HOME}&#x2F;jre<br>export CLASSPATH&#x3D;.:${JAVA_HOME}&#x2F;lib:${JRE_HOME}&#x2F;lib<br>export PATH&#x3D;${JAVA_HOME}&#x2F;bin:$PATH</p></blockquote><h4 id="应用修改后的环境变量"><a href="#应用修改后的环境变量" class="headerlink" title="应用修改后的环境变量"></a>应用修改后的环境变量</h4><blockquote><p>source &#x2F;etc&#x2F;profile  </p></blockquote><h4 id="软链接-windows里的快捷方式-程序到环境变量中"><a href="#软链接-windows里的快捷方式-程序到环境变量中" class="headerlink" title="软链接(windows里的快捷方式)程序到环境变量中"></a>软链接(windows里的快捷方式)程序到环境变量中</h4><blockquote><p>ln -s &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0&#x2F;bin&#x2F;java &#x2F;usr&#x2F;bin&#x2F;java</p></blockquote><h4 id="测试是否安装正常，显示-java-version-“1-8-0-261”-则为正常"><a href="#测试是否安装正常，显示-java-version-“1-8-0-261”-则为正常" class="headerlink" title="测试是否安装正常，显示 java version “1.8.0_261” 则为正常"></a>测试是否安装正常，显示 java version “1.8.0_261” 则为正常</h4><blockquote><p>java -version</p></blockquote><h2 id="安装screen"><a href="#安装screen" class="headerlink" title="安装screen"></a>安装screen</h2><blockquote><p>yum install -y screen</p></blockquote><p>(1)创建进程名称</p><blockquote><p>screen -S xxx   </p></blockquote><p>(2)查看创建的进程</p><blockquote><p>screen -ls</p></blockquote><p>(3)常用命令</p><blockquote><p>screen -S session_name              # 新建</p></blockquote><blockquote><p>screen -ls（或者screen -list）      # 列出所有session</p></blockquote><blockquote><p>screen -r session_name               # 回到session_name这个session</p></blockquote><blockquote><p>screen -d session_name               # 远程detach某个session</p></blockquote><blockquote><p>screen -d -r session_name            # 结束当前session并回到session_name这个session</p></blockquote><blockquote><p>screen -XS session_name  quit     #杀死名为seesion_name的screen</p></blockquote><p>在 screen 中，如果想翻看之前的屏幕输出，使用向上键和pageUp 都是不行的，这时候使用</p><blockquote><p>ctrl + a + [{ </p></blockquote><blockquote><p>从后台进程里出来，按键：ctrl+A+D，回到主终端。</p></blockquote><blockquote><p>但如果在主进程里ctrl+A+D，就会断开ssh连接</p></blockquote><p>结束当前screen窗口</p><blockquote><p>exit 或者 ctrl+d</p></blockquote><h2 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h2><p>添加一个端口（25565默认）</p><blockquote><p>firewall-cmd –zone&#x3D;public –add-port&#x3D;25565&#x2F;tcp –permanent</p></blockquote><p>然后 重启防火墙</p><blockquote><p>firewall-cmd –reload</p></blockquote><p>查看端口状态</p><blockquote><p>firewall-cmd –zone&#x3D; public –query-port&#x3D;25565&#x2F;tcp</p></blockquote><p>有安全组的记得放行端口</p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>不建议使用root系统进行后面的操作，接下来为Minecraft创建一个专门的用户。</p><blockquote><p>useradd -m Minecraft# 新建一个名为Minecraft的用户</p></blockquote><blockquote><p>passwd Minecraft# 为用户Minecraft设置密码</p></blockquote><blockquote><p>su - Minecraft# 切换至Minecraft用户</p></blockquote><h2 id="Minecraft服务端"><a href="#Minecraft服务端" class="headerlink" title="Minecraft服务端"></a>Minecraft服务端</h2><p>给MC服务端创建一个文件夹</p><blockquote><p>cd ~</p></blockquote><blockquote><p>mkdir MinecraftServer#创建文件夹</p></blockquote><blockquote><p>cd MinecraftServer#进入文件夹</p></blockquote><h3 id="获取服务端"><a href="#获取服务端" class="headerlink" title="获取服务端"></a>获取服务端</h3><p>MC目前主流的服务端分很多种，简单可以分为三类：</p><p>①原版纯净：官网直接下服务端，不能装mod不能装插件</p><p>②<a href="http://files.minecraftforge.net/">forge服务端</a>：Mod服，只能装Mod，不能装插件<br>③Craftbukkit、Spigot服务端：插件服，只能装插件，不能装Mod</p><p>④<a href="https://catmc.org/">CatSetver服务端</a>：国人开发的，MOD+插件服，白火现在在用。</p><p>也可以去论坛下载配置好的服务端</p><p>你可以在自己的电脑上下载好服务端，然后利用Xshell等远程终端的lrzsz插件，传输到服务器上。</p><h4 id="Forge服"><a href="#Forge服" class="headerlink" title="Forge服"></a>Forge服</h4><blockquote><p>java -jar forge-1.12.2-14.23.4.2705-installer.jar -nogui -installServer</p></blockquote><h4 id="CatServer服"><a href="#CatServer服" class="headerlink" title="CatServer服"></a>CatServer服</h4><blockquote><p>java -Xmx2G -jar CatServer-2a9163f-universal.jar<br>安装服务端，下载一会服务端资源，网络比较慢。其中<code>CatServer</code>服端安装服务端的指令，和后面正真运行服务端的指令是一样的。（<code>Forge</code>则是不同的）</p></blockquote><p>如果提示下载失败了，或部分资源下载超时了，就再重执行一次上面的&gt;forge-*-installer.jar</p><p>用ls指令查看文件</p><h4 id="同意协议"><a href="#同意协议" class="headerlink" title="同意协议"></a>同意协议</h4><blockquote><p>vim eula.txt</p></blockquote><p>将<code>eula=false</code>改成<code>eula=true</code>即可</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>方便以后开服，我们创建一个<code>startServer.sh</code>文件（别人配置好的服务端可能已经创建过了）</p><blockquote><p>vim startServer.sh</p></blockquote><p>#Forge服</p><blockquote><p>java -Xmx1G -jar forge-1.12.2-14.23.4.2705-universal.jar</p></blockquote><p>#CatServer服</p><blockquote><p>java -Xmx2G -jar CatServer-2a9163f-universal.jar</p></blockquote><p>#其实就是把运行服务器的指令，写进了<code>shell</code>中，省的敲指令了，直接运行shell即可。</p><p>#这和windows的bat批处理性质相似</p><p>#在windoes中开服，也是把开服的指令写进]bat中，每次运行bat就省的敲指令了。</p><p>给start.sh执行权限</p><blockquote><p>chmod 777 startServer.sh</p></blockquote><p>执行start.sh即可开服</p><blockquote><p>.&#x2F;startServer.sh</p></blockquote><p> 控制台不再跳新的信息时，说明开服成功<br> 我们先结束服务器，完成服务器配置<br><code>stop</code>或者<code>ctrl c</code></p><p>首次成功开服后，会产生一个server.properties文件，是服务器的配置文件。</p><blockquote><p>vim server.properties#修改配置文件</p></blockquote><p>其中online-mode&#x3D;true是检测正版登录用户，<br>true是只允许正版玩家进入可以使用，false则允许离线进入。<br><code>非官方客户端要改成</code>false</p><p><a href="https://minecraft-zh.gamepedia.com/index.php?title=Server.properties&variant=zh">更多配置参考</a></p><h2 id="正式开服"><a href="#正式开服" class="headerlink" title="正式开服"></a>正式开服</h2><p>创建一个名为MinecraftServer的screen，可以让服务器在后台运行，断开远程连接也不终止进程。</p><blockquote><p>screen -S MinecraftServer</p></blockquote><p>启动服务器</p><blockquote><p>.&#x2F;start.sh</p></blockquote><p>然后按住Ctrl + A +D ，将screen加入后台运行</p><p>当你需要回到这个sreen页面时</p><blockquote><p>screen -ls# 查看screen，记下MinecraftServer的编号</p></blockquote><blockquote><p>screen -r &lt;MinecraftServer的编号&gt;</p></blockquote><p>客户端输入ip:放行端口</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果服务端正常开服，但是<code>游戏就是无法连接服务器</code>，一般都是防火墙的问题。再配置下防火墙。</p><p>Mod放在MinecraftServer&#x2F;mods下</p><p>前提是你的服务器端支持mod，如Forge端、CatServer端。</p><p>插件放在MinecraftServer&#x2F;plugins下。</p><p>前提是服务端支持插件，如Craftbukkit、Spigot、CatServer。</p><p>我还是个小白,如有纰漏,请多多包涵,欢迎指正</p><p><a href="https://www.cnblogs.com/shiraka/p/14532465.html">附上原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Minecraft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2022/05/04/3l-linux-common-command/"/>
      <url>/2022/05/04/3l-linux-common-command/</url>
      
        <content type="html"><![CDATA[<p>ps:刚写完死活发不出来,后来发现题目少个空格</p><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><blockquote><p>systemctl stop firewalld</p></blockquote><blockquote><p>systemctl start firewalld</p></blockquote><blockquote><p>systemctl stop firewalld</p></blockquote><blockquote><p>systemctl status firewalld</p></blockquote><blockquote><p>firewall-cmd –reload</p></blockquote><blockquote><p>yum install firewall -y, apt-get install firewalld</p></blockquote><p>开放&#x2F;关闭特定端口<br><code>Ubuntu</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;firewall-cmd --zone&#x3D;public --add-port&#x3D;25565&#x2F;tcp --permanentfirewall-cmd --zone&#x3D;public --add-port&#x3D;25565&#x2F;tcp --permanent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> ‘有安全组的需要在安全组开放端口,我有的时候调不好直接把防火墙关了’</p><h2 id="Screen的安装与使用"><a href="#Screen的安装与使用" class="headerlink" title="Screen的安装与使用"></a>Screen的安装与使用</h2><blockquote><p>yum install -y screen</p></blockquote><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">(1)创建进程名称&gt;screen -S xxx   (2)查看创建的进程&gt;screen -ls(3)常用命令&gt;screen -S session_name              # 新建&gt;screen -ls（或者screen -list）      # 列出所有session&gt;screen -r session_name               # 回到session_name这个session&gt;screen -d session_name               # 远程detach某个session&gt;screen -d -r session_name            # 结束当前session并回到session_name这个session&gt;screen -XS session_name  quit     #杀死名为seesion_name的screen或者kill 进程号在 screen 中，如果想翻看之前的屏幕输出，使用向上键和pageUp 都是不行的，这时候使用&gt;ctrl + a + [&#123; &gt;从后台进程里出来，按键：ctrl+A+D，回到主终端。&gt;但如果在主进程里ctrl+A+D，就会断开ssh连接结束当前screen窗口&gt;exit 或者 ctrl+d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测速脚本"><a href="#测速脚本" class="headerlink" title="测速脚本"></a>测速脚本</h2><blockquote><p>wget -qO- bench.sh | bash</p></blockquote><ul><li><p>lemonbench</p><blockquote><p>curl -fsL <a href="https://ilemonra.in/LemonBenchIntl">https://ilemonra.in/LemonBenchIntl</a> | bash -s fast<br>个人常用快速fast的<br>curl -fsL <a href="https://ilemonra.in/LemonBenchIntl">https://ilemonra.in/LemonBenchIntl</a> | bash -s full</p></blockquote></li><li><p>完整测试</p><blockquote><p>curl -sL yabs.sh | bash<br>yabs.sh</p></blockquote></li><li><p>备用地址</p><blockquote><p>curl -sL <a href="https://jsdelivr.zeruns.tech/gh/masonr/yet-another-bench-script@master/yabs.sh">https://jsdelivr.zeruns.tech/gh/masonr/yet-another-bench-script@master/yabs.sh</a> | bash</p></blockquote></li></ul><blockquote><p>wget -N –no-check-certificate <a href="https://raw.githubusercontent.com/FunctionClub/ZBench/master/ZBench-CN.sh">https://raw.githubusercontent.com/FunctionClub/ZBench/master/ZBench-CN.sh</a> &amp;&amp; bash ZBench-CN.sh  汉化</p></blockquote><h3 id="全流媒体解锁测试"><a href="#全流媒体解锁测试" class="headerlink" title="全流媒体解锁测试"></a>全流媒体解锁测试</h3><blockquote><p>bash &lt;(curl -L -s <a href="https://raw.githubusercontent.com/lmc999/RegionRestrictionCheck/main/check.sh">https://raw.githubusercontent.com/lmc999/RegionRestrictionCheck/main/check.sh</a>)</p></blockquote><h3 id="综合工具箱"><a href="#综合工具箱" class="headerlink" title="综合工具箱"></a>综合工具箱</h3><blockquote><p>wget -O box.sh <a href="https://raw.githubusercontent.com/BlueSkyXN/SKY-BOX/main/box.sh">https://raw.githubusercontent.com/BlueSkyXN/SKY-BOX/main/box.sh</a> &amp;&amp; chmod +x box.sh &amp;&amp; clear &amp;&amp; .&#x2F;box.sh<br>Superspeed.sh</p></blockquote><h3 id="一键测试服务器到国内的速度脚本Superspeed-sh"><a href="#一键测试服务器到国内的速度脚本Superspeed-sh" class="headerlink" title="一键测试服务器到国内的速度脚本Superspeed.sh"></a>一键测试服务器到国内的速度脚本Superspeed.sh</h3><blockquote><p>wget <a href="https://raw.githubusercontent.com/oooldking/script/master/superspeed.sh">https://raw.githubusercontent.com/oooldking/script/master/superspeed.sh</a><br>chmod +x superspeed.sh<br>sudo .&#x2F;superspeed.sh<br>SuperBench.sh</p></blockquote><p>一键检测VPS的CPU、内存、负载、IO读写、机房带宽和服务器类型等脚本SuperBench.sh：</p><blockquote><p>wget -N –no-check-certificate <a href="https://raw.githubusercontent.com/oooldking/script/master/superbench.sh">https://raw.githubusercontent.com/oooldking/script/master/superbench.sh</a><br>sudo bash superbench.sh</p></blockquote><p>或者</p><blockquote><p>curl -Lso- <a href="https://raw.githubusercontent.com/oooldking/script/master/superbench.sh">https://raw.githubusercontent.com/oooldking/script/master/superbench.sh</a> | bash</p></blockquote><h3 id="Zench"><a href="#Zench" class="headerlink" title="Zench"></a>Zench</h3><p>Zench可以看作是Bench.sh 和 SuperBench的结合版本，加入 Ping 以及 路由测试 功能，会生成测评报告，可以很方便地分享给其他朋友看自己的测评数据 ：</p><blockquote><p>wget -N –no-check-certificate <a href="https://raw.githubusercontent.com/FunctionClub/ZBench/master/ZBench-CN.sh">https://raw.githubusercontent.com/FunctionClub/ZBench/master/ZBench-CN.sh</a></p></blockquote><p>sudo bash ZBench-CN.sh<br><a href="https://github.com/FunctionClub/ZBench">项目地址</a></p><h3 id="Serverreview-benchmark综合评测工具"><a href="#Serverreview-benchmark综合评测工具" class="headerlink" title="Serverreview-benchmark综合评测工具"></a>Serverreview-benchmark综合评测工具</h3><p>这是一个老外写的VPS主机综合评测工具，主要评测的项目有VPS主机磁盘IO、内存读写、CPU性能以及Benchmark性能，还有美国、欧洲、亚洲等不同节点的下载速度。主页：<a href="https://github.com/sayem314/serverreview-benchmark">https://github.com/sayem314/serverreview-benchmark</a></p><blockquote><p>curl -LsO <a href="https://raw.githubusercontent.com/sayem314/serverreview-benchmark/master/bench.sh">https://raw.githubusercontent.com/sayem314/serverreview-benchmark/master/bench.sh</a>; chmod +x bench.sh &amp;&amp; .&#x2F;bench.sh -a share</p></blockquote><p>mPing</p><h3 id="一键测试回程Ping值工具：mPing"><a href="#一键测试回程Ping值工具：mPing" class="headerlink" title="一键测试回程Ping值工具：mPing"></a>一键测试回程Ping值工具：mPing</h3><blockquote><p>wget <a href="https://raw.githubusercontent.com/helloxz/mping/master/mping.sh">https://raw.githubusercontent.com/helloxz/mping/master/mping.sh</a></p></blockquote><p>bash mping.sh</p><h2 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h2><blockquote><p>netstat   -nultp</p></blockquote><blockquote><p>netstat -lnp|grep 44380</p></blockquote><blockquote><p>netstat -lnp|grep nginx</p></blockquote><p>关进程</p><blockquote><p>kill -9 进程号</p></blockquote><h2 id="报错问题"><a href="#报错问题" class="headerlink" title="报错问题"></a>报错问题</h2><h3 id="curl-command-not-found-，"><a href="#curl-command-not-found-，" class="headerlink" title="curl: command not found ，"></a>curl: command not found ，</h3><p>原因:没装 Curl<br>(1)ubuntu&#x2F;debian 系统安装 Curl 方法</p><blockquote><p>apt-get install curl &amp;&amp; apt-get install curl -y</p></blockquote><p>(2)centos 系统安装 Curl 方法</p><blockquote><p>yum install curl -y</p></blockquote><h2 id="cmd连接服务器"><a href="#cmd连接服务器" class="headerlink" title="cmd连接服务器"></a>cmd连接服务器</h2><blockquote><p>ssh -p 端口 用户名@ip</p></blockquote><p>默认端口用这个</p><blockquote><p>ssh 用户名@ip</p></blockquote><h2 id="解压-移动文件夹"><a href="#解压-移动文件夹" class="headerlink" title="解压,移动文件夹"></a>解压,移动文件夹</h2><blockquote><p>tar -zxvf xxx<br>unzip xxxx</p></blockquote><p>1.将一个文件夹下的所有内容复制到另一个文件夹下</p><blockquote><p>cp -r &#x2F;home&#x2F;packageA&#x2F;* &#x2F;home&#x2F;cp&#x2F;packageB&#x2F;<br>或cp -r &#x2F;home&#x2F;packageA&#x2F;. &#x2F;home&#x2F;cp&#x2F;packageB&#x2F;<br>这两种方法效果是一样的<br>2.将一个文件夹复制到另一个文件夹下<br>cp -r &#x2F;home&#x2F;packageA &#x2F;home&#x2F;packageB</p></blockquote><p>运行命令之后packageB文件夹下就有packageA文件夹了。<br>3.删除一个文件夹及其下面的所有文件</p><blockquote><p>rm -rf &#x2F;home&#x2F;packageA</p></blockquote><p>-r表示向下递归，不管有多少级目录，一并删除<br>-f表示直接强行删除，不作任何提示的意思<br>4.移动一个文件夹到另一个文件夹下面</p><blockquote><p>mv &#x2F;home&#x2F;packageA &#x2F;home&#x2F;packageB&#x2F;<br>或<br>mv &#x2F;home&#x2F;packageA &#x2F;home&#x2F;packageB<br>这两种方法效果是一样的<br>5.移动一个文件夹下的所有内容到另一个文件夹下面<br>mv &#x2F;home&#x2F;packageA&#x2F;* &#x2F;home&#x2F;packageB&#x2F;</p></blockquote><h2 id="安装类命令"><a href="#安装类命令" class="headerlink" title="安装类命令"></a>安装类命令</h2><h3 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#获取安装包wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.8.10&#x2F;Python-3.8.10.tgz#下载完成之后，将安装包解压到当前目录：tar xvf Python-3.8.10.tgz#安装需要的依赖apt -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel#先进入Python3目录下的Python-3.8.10目录：cd Python-3.8.10#指定python3安装路径：.&#x2F;configure prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3.8.10#编译+安装make &amp;&amp; make install#添加python3软链接：ln -s &#x2F;usr&#x2F;local&#x2F;python3.8.10&#x2F;bin&#x2F;python3.8.10 &#x2F;usr&#x2F;bin&#x2F;python3#添加pip3软链接： ln -s &#x2F;usr&#x2F;local&#x2F;python3.8.10&#x2F;bin&#x2F;pip3.8.10 &#x2F;usr&#x2F;bin&#x2F;pip3#配置python环境变量配置环境变量主要是能快速使用pip3安装命令。vi ~&#x2F;.bash_profile添加如下配置export PYTHON_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;python3.8.10export PATH&#x3D;$PYTHON_HOME&#x2F;bin:$PATH#使配置生效source ~&#x2F;.bash_profile#检查版本python3 --versionpython3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p><a href="http://nodejs.cn/download/">nodejs官网</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">wget https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v12.18.1&#x2F;node-v12.18.1-linux-x64.tar.xz         &#x2F;&#x2F; 下载tar xf node-v12.18.1-linux-x64.tar.xz                                        &#x2F;&#x2F; 解压cd node-v12.18.1-linux-x64                                                   &#x2F;&#x2F; 进入解压目录&#x2F;&#x2F;解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以修改linux系统的环境变量（profile）来设置直接运行命令：&#x2F;&#x2F;建议先备份，养成修改重要文件之前先备份的好习惯。cp &#x2F;etc&#x2F;profile &#x2F;etc&#x2F;profile.bakvim &#x2F;etc&#x2F;profile&#x2F;&#x2F;在最下面添加 export PATH&#x3D;$PATH: 后面跟上 node 下 bin 目录的路径export PATH&#x3D;$PATH:&#x2F;root&#x2F;node-v12.18.1-linux-x64&#x2F;bin&#x2F;&#x2F;立即生效source &#x2F;etc&#x2F;profile&#x2F;&#x2F;查看版本node -vv12.18.1&#x2F;&#x2F;安装成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建过程中遇到的坑</title>
      <link href="/2022/05/03/2l-hexo-pit/"/>
      <url>/2022/05/03/2l-hexo-pit/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo常用命令："><a href="#hexo常用命令：" class="headerlink" title="hexo常用命令："></a>hexo常用命令：</h2><blockquote><p>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</p><p>hexo s &#x3D;&#x3D; hexo server</p><p>hexo g &#x3D;&#x3D; hexo generate</p><p>hexo d &#x3D;&#x3D; hexo deploy</p><p>hexo n &#x3D;&#x3D; hexo new</p><p>hexo clean</p><p>hexo g -d</p><p>hexo new ‘my-first-blog’  </p><p>npm install hexo-cli -g</p></blockquote><p>2024&#x2F;7&#x2F;13出现背景图片无法更改的问题</p><img src="/2022/05/03/2l-hexo-pit/image-20240713192611561.png" class="" title="image-20240713192611561"><p>删掉后变为空白</p><h2 id="Typora与hexo无法同时预览图片的问题"><a href="#Typora与hexo无法同时预览图片的问题" class="headerlink" title="Typora与hexo无法同时预览图片的问题"></a>Typora与hexo无法同时预览图片的问题</h2><p>通过安装某个插件解决，但是该插件可能导致违章封面失效，因为无法识别.png后缀的图片</p><h2 id="预览与上传不可兼"><a href="#预览与上传不可兼" class="headerlink" title="预览与上传不可兼"></a>预览与上传不可兼</h2><p>关于typora预览图片hexo不能显示,hexo显示图片typora上不能预览的问题</p><p>未解决…..</p><img src="/2022/05/03/2l-hexo-pit/image-20230905210325207.png" class="" title="image-20230905210325207"><p>typora的图片路径.&#x2F;${filename}&#x2F;</p><p>当设置为相对路径时,仍不能正常显示</p><p>观察html代码路径发现</p><blockquote><p><img src="/01.jpg" alt="01">这个可以hexo网站显示,也就是说这个是插件可以识别拼接的格式,所以我只需要把图片放到同一个文件夹下,但是就太乱了</p></blockquote><p>因为hexo-assert-image插件的源码</p><p>适配了这个路径将它替换为,但是不能预览</p><img src="/2022/05/03/2l-hexo-pit/image-20230908214200264.png" class="" title="image-20230908214200264"><p>官方使用方法</p><p><img src="/2022/05/03/2l-hexo-pit/image-20230908230632842.png" alt="image-20230908230632842"></p><p>所以只要增加对两种格式代码的替换即可</p><img src="/2022/05/03/2l-hexo-pit/image-20230905210813363.png" class="" title="image-20230905210813363"><p>这个是.&#x2F;${filename}&#x2F;下,相对路径时,网站的显示,差了一个日期和解码的问题</p><img src="/2022/05/03/2l-hexo-pit/image-20230905210938026.png" class="" title="image-20230905210938026"><p>但是,<code>如01.jpg在同一个目录里面,那么就可以实现即可以预览又可以在网站中正确显示</code></p><p>剩下的就要研究js了</p><hr><p>我感觉js加一个匹配就可以了,但是我不会,开发的重要性</p><p>markdown用法和表情</p><p>兼的的办法是md与图片放在一起</p><p>或者说,关于链接的问题</p><p>或者,匹配到相对路径,去掉前面部分</p><p>2024&#x2F;01&#x2F;29</p><blockquote><p>发现了另一个hexo-assert-img插件,可以实现相对路径拼接图片链接</p></blockquote><p>下一阶段目标,自己写一个这样的插件</p><p><a href="https://www.freesion.com/article/78201400603/">hexo 图片显示问题及使用typora设置图片路径 - 灰信网（软件开发博客聚合） (freesion.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/645679541">解决Hexo+Github+Typora图片无法正确显示的问题 - 知乎 (zhihu.com)</a></p><h2 id="err-Error-Spawn-failed"><a href="#err-Error-Spawn-failed" class="headerlink" title="err: Error: Spawn failed."></a>err: Error: Spawn failed.</h2><p>he correct access rights and the repository exists</p><p> (1)首先重新设置一下git的用户名和邮箱</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">git config --global user.name &quot;xxx&quot;    git config --global user.email &quot;xxx&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(2) 删除.ssh文件夹</p><p>(3)git输入</p><blockquote><p>‘ssh-keygen -t rsa ‘    放到github上时要加上邮箱</p></blockquote><p>(4)服务端</p><blockquote><p>su fuchen</p></blockquote><blockquote><p>mkdir ~&#x2F;.ssh</p></blockquote><blockquote><p>vim ~&#x2F;.ssh&#x2F;authorized_keys</p></blockquote><p>(5)如果重复出现此错误,检查一下是否用root建立了.ssh文件</p><p>(还有一种可能是git环境的配置问题)</p><h2 id="ERROR-Deployer-not-found-git"><a href="#ERROR-Deployer-not-found-git" class="headerlink" title="ERROR Deployer not found: git"></a>ERROR Deployer not found: git</h2><p>运行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d命令,出现</p><blockquote><p>原因：少了hexo针对git的deploy组件</p></blockquote><blockquote><p>解决方法：npm install –save hexo-deployer-git</p></blockquote><blockquote><p>搞定，运行成功之后提示：INFO  Deploy done: git</p></blockquote><h3 id="git报错—The-authenticity-of-host-can’t-be-established"><a href="#git报错—The-authenticity-of-host-can’t-be-established" class="headerlink" title="git报错—The authenticity of host can’t be established."></a>git报错—The authenticity of host can’t be established.</h3><p>打开本地的.ssh文件夹(C:\Users\Administrator.ssh)会发现有两个文件分别是公钥和私钥</p><p><strong>产生原因：</strong><br>文件夹内少了一个known_hosts文件，本来<a href="https://so.csdn.net/so/search?q=%E5%AF%86%E9%92%A5&spm=1001.2101.3001.7020">密钥</a>文件应该是三个，现在只有两个，便报了这样的错误</p><blockquote><p>解决:输入yes回车，生成known_hosts文件</p><p>注:不要直接按回车,要输入yes后回车</p></blockquote><h3 id="SSL-certificate-problem-unable-to-get-local-issuer-certificate"><a href="#SSL-certificate-problem-unable-to-get-local-issuer-certificate" class="headerlink" title="SSL certificate problem: unable to get local issuer certificate"></a>SSL certificate problem: unable to get local issuer certificate</h3><blockquote><p>这是由于当你通过HTTPS访问Git远程仓库的时候，如果服务器上的<a href="https://so.csdn.net/so/search?q=SSL&spm=1001.2101.3001.7020">SSL</a>证书未经过第三方机构认证，git就会报错。原因是因为未知的没有签署过的证书意味着可能存在很大的风险。解决办法就是通过下面的命令将git中的sslverify关掉：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">git config --global http.sslverify false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　上面这行命令的影响范围是系统当前用户，如果要设置为全局所有用户，可以改成这样：</p><pre class="line-numbers language-none"><code class="language-none">git config --system http.sslverify false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　如果只是想针对当前仓库进行设置，可以在需要修改的仓库目录下执行：</p><pre class="line-numbers language-none"><code class="language-none">git config http.sslverify false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　如果你的仓库中存在嵌套的git子模块（就是子模块中又引用了子模块），在进行初始化时，仍然有可能遇到self signed certificate in certificate chain的错误，此时可以通过执行下面的命令来解决：</p><pre class="line-numbers language-none"><code class="language-none">npm config set strict-ssl false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="执行remote-add时：fatal-Not-a-git-repository"><a href="#执行remote-add时：fatal-Not-a-git-repository" class="headerlink" title="执行remote add时：fatal: Not a git repository"></a>执行remote add时：fatal: Not a git repository</h2><blockquote><p>执行git remote add命令时报这个错误：</p></blockquote><h4 id="fatal-Not-a-git-repository-or-any-of-the-parent-directories-git"><a href="#fatal-Not-a-git-repository-or-any-of-the-parent-directories-git" class="headerlink" title="fatal: Not a git repository (or any of the parent directories): .git"></a>fatal: Not a git repository (or any of the parent directories): .git</h4><blockquote><p>原因：<br>当前所在的目录不是一个git目录，要么切换目录到你想添加的git目录下，或者在当前目录下初始化一个git目录：git init</p></blockquote><h2 id="没有可用软件包nginx"><a href="#没有可用软件包nginx" class="headerlink" title="没有可用软件包nginx"></a>没有可用软件包nginx</h2><blockquote><p>yum install epel-release  epel扩展</p></blockquote><blockquote><p>yum  update</p></blockquote><h2 id="更改-config-yuml后出现YAMLException"><a href="#更改-config-yuml后出现YAMLException" class="headerlink" title="更改_config.yuml后出现YAMLException:"></a>更改_config.yuml后出现YAMLException:</h2><p> YAMLException: duplicated mapping key (25:1)的解决方法</p><blockquote><p>YAMLException:重复的映射键（25:1),观察25行是否重复,是否冲突,</p></blockquote><blockquote><p>比如前面true 后面false<br>需要看看前后有没有多余的粘贴!!</p></blockquote><h2 id="hexo更换主题后：WARN-No-layout-index-html"><a href="#hexo更换主题后：WARN-No-layout-index-html" class="headerlink" title="hexo更换主题后：WARN No layout: index.html"></a>hexo更换主题后：WARN No layout: index.html</h2><p> (1).检查下载的主题是不是放在了themes文件夹下面，比如next主题的放置，</p><blockquote><p>点开themes就看到next的文件夹，next下面就是主题的文件，不能打开next文件夹还有themes<br> 解决方法<br>把theme下的文件夹名称改为next。</p></blockquote><p>(2).检查站点配置_config.yml是不是下面的形式<br>theme: 你的主题名字</p><blockquote><p>注意:（1）这里是theme，不是themes.</p><blockquote><blockquote><p>（2）theme后面与主题名直接有一个空格。</p><blockquote><p>（3）主题名字是否与themes文件夹下 主题的名字一致。</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>比如next：theme: next,冒号后面有空格。</p></blockquote></blockquote></blockquote></blockquote><h3 id="假如全部一致还运行有错，建议每次修改后"><a href="#假如全部一致还运行有错，建议每次修改后" class="headerlink" title="假如全部一致还运行有错，建议每次修改后"></a>假如全部一致还运行有错，建议每次修改后</h3><p>先输入命令’hexo clean’清理一下原来的配置，然后运行</p><h4 id="第二个错误"><a href="#第二个错误" class="headerlink" title="第二个错误"></a>第二个错误</h4><p>本地主题样式修改完之后，本地运行访问都对，</p><p>然后hexo d部署到github上面后访问没有样式。</p><blockquote><p>打开站点配置_config.yml,更改其中的url和root配置</p></blockquote><blockquote><p>url: 这里是GitHub给你分配的地址,root: &#x2F;项目名</p></blockquote><blockquote><p>然后重新 hexo g,hexo d 解决问题。</p></blockquote><h2 id="bash-hexo-command-not-found"><a href="#bash-hexo-command-not-found" class="headerlink" title="bash: hexo: command not found"></a>bash: hexo: command not found</h2><p>(1)git关了重新开一下</p><p>(2)查<code>nodejs</code>和<code>npm</code>是否正常，依次输入命令<code>node -v 和</code>npm -v&#96;看看是否有相关版本信息</p><blockquote><p>(3)此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;选择系统变量 Path</p></blockquote><blockquote><p>将 node_modules 下的 .bin 文件路径添加到 Path 里面</p></blockquote><p>环境变量添加好了之后重新打开 git 即可运行 hexo 命令</p><p>如果此时仍然无法执行 hexo 命令，那就只能重装试试了，</p><blockquote><p>运行命令 npm install hexo-cli -g 重新安装 hexo 即可</p></blockquote><h2 id="YAMLException-end-of-the-stream-or-a-document-separator-is-expected"><a href="#YAMLException-end-of-the-stream-or-a-document-separator-is-expected" class="headerlink" title="YAMLException: end of the stream or a document separator is expected"></a>YAMLException: end of the stream or a document separator is expected</h2><blockquote><p>检查文件头缺空格</p></blockquote><blockquote><p>为了避免配置后出现大量错误,无从下手,建议分部配置,不报错了再继续配置</p></blockquote><h3 id="c-Users-DELL-AppData-Roaming-npm-hexo-line-12-node-command-not-found"><a href="#c-Users-DELL-AppData-Roaming-npm-hexo-line-12-node-command-not-found" class="headerlink" title="&#x2F;c&#x2F;Users&#x2F;DELL&#x2F;AppData&#x2F;Roaming&#x2F;npm&#x2F;hexo: line 12: node: command not found"></a>&#x2F;c&#x2F;Users&#x2F;DELL&#x2F;AppData&#x2F;Roaming&#x2F;npm&#x2F;hexo: line 12: node: command not found</h3><p>重新安装git后,运行hexo出现这样的报错,重新安装一下<a href="https://www.wangfuchao.com/?golink=aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">node.js</a>就可以了</p><p><a href="https://blog.csdn.net/weixin_40486955/article/details/105967026">4.1参考文章</a></p><p><a href="https://blog.csdn.net/qq_55125921/article/details/125220576">4.2参考文章</a>)</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux搭建hexo博客(本地端)</title>
      <link href="/2022/05/03/1l-hexo-blog/"/>
      <url>/2022/05/03/1l-hexo-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="本地电脑安装node-js和git"><a href="#本地电脑安装node-js和git" class="headerlink" title="本地电脑安装node.js和git"></a>本地电脑安装node.js和git</h2><p><a href="https://git-scm.com/downloads">Git下载</a><br><a href="https://nodejs.org/zh-cn/">node下载</a><br>注意配置环境变量 D:\Node,   D:\Git\cmd</p><h2 id="验证node安装完成"><a href="#验证node安装完成" class="headerlink" title="验证node安装完成"></a>验证node安装完成</h2><p>在cmd中输入</p><blockquote><p>node -v<br> npm -v</p></blockquote><p>出现版本号代表安装完成</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p><a href="https://hexo.io/zh-cn/docs/">hexo文档</a></p><p>打开cmd 然后在cmd中输入</p><blockquote><p>npm install -g hexo-cli</p></blockquote><h2 id="生成Hexo"><a href="#生成Hexo" class="headerlink" title="生成Hexo"></a>生成Hexo</h2><blockquote><p>hexo init blog </p></blockquote><p>安装过程中，会自动生成一个文件夹，这个文件夹就是Hexo的配置文件“blog”是你要生成博客的文件夹名称，可以根据自己的喜好来取名等待安装完成</p><p>完成后，我们进入生成的文件夹，用<code>hexo s</code>这个命令来启动Hexo</p><p>输入它提示的网站  进去之后就可以看到<code>localhost:4000</code></p><blockquote><p>暂时有一个问题不明白,可不可以不用本地端,只用服务器,就可以搭建呢</p></blockquote><blockquote><p><a href="http://fuchenchenle.cn/2020/08/17/%E8%85%BE%E8%AE%AF%E4%BA%91%EF%BC%8Bhexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">附上原文链接</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
